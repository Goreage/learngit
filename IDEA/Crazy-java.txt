    数组元素的类型是基本类型中的整数类型（byte, short, int 和 long）,则数组元素的值是0.
    数组元素的类型是基本类型中的浮点类型（float, double）,则数组元素的值是0.0.
    数组元素的类型是基本类型中的布尔类型（char）,则数组元素的值'\u0000'。
    数组元素的类型是引用类型（类， 接口和数组）， 则数组元素的值是null。

局部变量
    形参：在方法签名中定义的局部变量，由方法调用者负责为其赋值，随方法的结束而消亡。
    方法内的局部变量：在方法内定义的局部变量，必须在方法内对其进行显示初始化。这种类型的局部变量从初始化完成后开始生效。
随方法的结束而消亡。
    代码块内的局部变量：在代码块内定义的局部变量，必须在代码块内对其进行显示初始化。这种类型的局部变量从初始化完成后开始生效。
随方法的结束而消亡。

super关键字本身并没有引用任何对象，它甚至不能被当成一个真正的引用变量来使用。
    1.子类方法不能直接使用return super; 但使用return this;返回该方法的对象是允许使用的
    2.程序不允许直接把super当成变量使用，例如，试图判断super和a变。量是否引用同一个Java对象。super == a;这条语句将会引起编译错误。

final修饰符
    final修饰符是Java语言中比较简单的修饰符，但也是一个被”误解“较多的修饰符，对很多Java程序员来说，何时使用final修饰符，使用fianl
修饰符后对程序有何影响....
    1.fianl可以修饰变量，被final修饰的变量被赋值初始值之后，不能对它重新赋值
    2.final可以修饰方法，被final修饰的方法不能被重写。
    3.final可以修饰类，被final修饰的类不能派生子类。

final修饰的变量
    1.定义final实例变量时指定初始值。
    2.在非静态初始块中为final实例变量指定初始值。
    3.在构造器中为final实例变量指定初始值。

对于fianl类变量而言，同样必须显示地指定初始值，而且final类变量只能在两个地方指定初始值。
    1.定义final类变量时指定初始值。
    2.在静态初始化块中为final类变量进行初始化

Java集合的实现细节
    表面上看,Set代表无序，不可重复的集合，而Map则代表key-value对集合，也称为关联数组，但其实Set和Map之间存在很大的类比性。

 HashMap和HashSet
    将一个Set集合扩展成Map集合，由于这个Set采用了HashSet作为实现类，HashSet会使用Hash算法来保存集合中的每一个SimpleEntry元素
，因此扩展出来的Map本质是一个HashMap.
    实际上，HashSet和HashMap之间有很多相似之处，对于HashSet而言，系统采用Hash算法决定集合元素的存储位置，这样可以保证快速存
取集合元素；对于HashMap而言，系统将value当成key的“附属物”，系统根据Hash算法来决定key存储位置，这样可以保证快速存，取集合key,
而value总是紧随key存储。
    在介绍集合存储之前需要指出一点：虽然集合号称存储是Java对象，但实际并不会真正将Java对象放入Set集合中，而只是在Set集合中
保留这些对象的引用而已。也就是说，Java集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的Java对象。
    就像引用类型的数组一样，当把Java对象放入数组中之时，并不是真正把Java对象放入数组中，而只是把对象的引用放入数组中，每个数组
元素都是一个引用的变量。
    ArrayList底层是基于数组实现的，也就是说，ArrayList底层封装的是数组，每次创建ArrayList时传入的int参数就是它所封装的数组的长度
如果创建ArrayList时没有传入int参数，那么ArrayList的初始长度为10，也就是它底层所封装的数组的长度为10，

对于一个排序算法来说，一般从如下三个方面来衡量算法的优劣。
    时间复杂度：主要是分析关键字的比较次数的记录的移动次数。
    空间复杂度：分析排序算法中需要多少辅助内存。
    稳定性：如两个记录A和B的关键字值相等，但排序后A,B先后次序保持不变，则称这种算法是稳定的；反之，就是不稳定。
    选择排序（直接选择排序，堆排序）
    交换排序（冒泡排序，快速排序）
    插入排序（直接插入排序，折半插入排序，Shell排序）
    归并排序
    桶式排序
    基数排序


