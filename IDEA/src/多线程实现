JAVA多线程实现的四种方式
Java多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。

其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。



1、继承Thread类创建线程
创建一个线程继承Thread 重写run()  在新建一个类，在类中new 那个线程类然后start
2.实现Runnable接口 推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。

三 实例变量和线程安全
定义线程类中的实例变量针对其他线程可以有共享和不共享之分
3.1  不共享数据情况: 可以看出每个线程都有一个属于自己实例变量count, 它们之间互不影响。
3.2  共享数据的情况

四 一些常用方法
4.1 currentThread()返回对当前正在执行的线程对象的引用。
4.2 getId()返回此线程的标识符
4.3 getName()返回此线程的名称
4.4 getPriority()返回此线程的优先级
4.5 isAlive()测试这个线程是否还处于活动状态。 什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。
4.6 sleep(long millis)使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。
4.7 interrupt()中断这个线程。
4.8 interrupted() 和isInterrupted()interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但部清楚状态标志
4.9 setName(String name)将此线程的名称更改为等于参数 name 。
4.10 isDaemon()测试这个线程是否是守护线程。
4.11 setDaemon(boolean on)将此线程标记为 daemon线程或用户线程。
4.12 join()在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行4.13 yield()yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。4.14 setPriority(int newPriority)更改此线程的优先级

五 如何停止一个线程呢？
stop(), 不安全 suspend()   不安全 ,resume()   本身是死锁
（仅用于与suspend()一起使用）这些方法已被弃用，所以我这里不予讲解。

5.1 使用interrupt()方法
我们上面提到了interrupt()方法，先来试一下interrupt()方法能不能停止线程
5.2 使用return停止线程

六 线程的优先级每个线程都具有各自的优先级，线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这个并不意味着低优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。线程优先级具有继承特性比如A线程启动B线程，则B线程的优先级和A是一样的。线程优先级具有随机性也就是说线程优先级高的不一定每一次都先执行完。Thread类中包含的成员变量代表了线程的某些优先级。如Thread.MINPRIORITY（常数1），Thread.NORMPRIORITY（常数5）,Thread.MAXPRIORITY（常数10）。其中每个线程的优先级都在Thread.MINPRIORITY（常数1） 到Thread.MAXPRIORITY（常数10） 之间，在默认情况下优先级都是Thread.NORMPRIORITY（常数5）。学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理

七 Java多线程分类
7.1 多线程分类用户线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程
守护线程：运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 “佣人”。
特点：一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作
应用：数据库连接池中的检测线程，JVM虚拟机启动后的检测线程最常见的守护线程：垃圾回收线程

7.2 如何设置守护线程？
可以通过调用Thead类的setDaemon(true)方法设置当前的线程为守护线程

注意事项：1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常
     2. 在守护线程中产生的新线程也是守护线程
     3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑

