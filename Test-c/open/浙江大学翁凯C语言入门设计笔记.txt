函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值
可以先想象成数学中的函数，y=f(x)
函数的组成	
	函数头 （返回类型 void 不返回任何东西 ） 
	{
	函数体
	}
	函数名  (参数表):()圆括号起到了表示函数调用的重要作用
	即使没有参数也需要圆括号（）
	如果有参数，则需要给出正确的数量和顺序
	这些值会被按照顺序依次用来初始化函数中的参数
	
函数原型
函数头，以分号";"结尾，就构成了函数的原型
函数原型的目的是告诉编译器这个函数长什么样
名称
参数返回类型

类型不匹配？
调用函数时给的值与参数的类型不匹配是C语言的传统上最大的漏洞
编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的
c++/Java就好的多

数组的大小
sizeof给出整个数组所占据的内容的大小，单位是字节
sizeof(a)/sizeof(a[0])
sizeof(a[0])给出数组中单元元素的大小，于是想出就得到了数组的单元个数
这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码

数组的赋值
数组变量本身不能被赋值
要把一个数组的所有元素交给另一个元素，必须采用遍历
	for(i=0; i<length; i++){
		b[i] = a[i];
	}
数组作为函数参数时，往往必须再用另一个参数来传人数组的大小
数组作为函数的参数时，
不能在[]中给出数组的大小
不能在利用sizeof来计算数组的元素个数

构造素数表
欲构造N以内的素数表
1.令x为2
2.将2x,3x,4x直至ax<n的数标记为非素数
3.令x为下一个没有被标记为非素数的值，重复2；直到所有的数都已经尝试完毕

sizeof
是一个运算符，给出某个类型或内存中所占据的字节数
sizeof(int) 
sizeof(i)

运算符&
scanf("%d",&i);里的&
获得变量的地址，它的操作数必须是变量
int i; printf("%x",&i);
地址的大小是否与int相同取决于编译器
int i; printf("%p",&i);

作为参数的指针
void f(int *p);
在被调用的时候得到了某个变量的地址：
int i=0; f(&i);
在函数里面可以通过这个指针访问外面的这个i

访问哪个地址上的变量*
*是单目运算符， 用来访问指针的值所表示的地址上的变量
可以做右值也可以做左值
int k = *p;
*p = k + 1;

数组参数
以下四种函数原型是等价的：
int sum(int *ar, int n);
int sum(int *, int );
int sum(int ar[], int n);
int sum(int [], int);

字符类型
char是一种整数，也是一种特殊的类型：字符。这是因为：
用单引号表示的字符字面量；'a','1'
''也是一个字符
printf和scanf里用%c来输出输入；

string.h
strlen  返回长度  sizeof（）会加上回车
strcmp
strcpy
strcat
strchr
strstr

给一个指针加1表示要让指针指向下一个变量
int a[10];
int *p = a;
*(p+1) -> a[1]
如果至真不是指向一片连续分配的空间，如数组，则这种运算没有意义
指针计算
这些算术运算可以对指针做
给指针加，减一个整数(+ += - -=)
递增递减(++/--)
两个指针相减

*p++
取出p所指的那个数据来，完事之后顺便把p移到下一个位置去。
*的优先级虽然高，但是没有++高
常用于数组类的连续空间操作
在某些CPU上，这可以直接被翻译成一条汇编指令