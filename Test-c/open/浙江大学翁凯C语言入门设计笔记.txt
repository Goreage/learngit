函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值
可以先想象成数学中的函数，y=f(x)
函数的组成	
	函数头 （返回类型 void 不返回任何东西 ） 
	{
	函数体
	}
	函数名  (参数表):()圆括号起到了表示函数调用的重要作用
	即使没有参数也需要圆括号（）
	如果有参数，则需要给出正确的数量和顺序
	这些值会被按照顺序依次用来初始化函数中的参数
	
函数原型
函数头，以分号";"结尾，就构成了函数的原型
函数原型的目的是告诉编译器这个函数长什么样
名称
参数返回类型

类型不匹配？
调用函数时给的值与参数的类型不匹配是C语言的传统上最大的漏洞
编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的
c++/Java就好的多

数组的大小
sizeof给出整个数组所占据的内容的大小，单位是字节
sizeof(a)/sizeof(a[0])
sizeof(a[0])给出数组中单元元素的大小，于是想出就得到了数组的单元个数
这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码

数组的赋值
数组变量本身不能被赋值
要把一个数组的所有元素交给另一个元素，必须采用遍历
	for(i=0; i<length; i++){
		b[i] = a[i];
	}
数组作为函数参数时，往往必须再用另一个参数来传人数组的大小
数组作为函数的参数时，
不能在[]中给出数组的大小
不能在利用sizeof来计算数组的元素个数

构造素数表
欲构造N以内的素数表
1.令x为2
2.将2x,3x,4x直至ax<n的数标记为非素数
3.令x为下一个没有被标记为非素数的值，重复2；直到所有的数都已经尝试完毕

sizeof
是一个运算符，给出某个类型或内存中所占据的字节数
sizeof(int) 
sizeof(i)

运算符&
scanf("%d",&i);里的&
获得变量的地址，它的操作数必须是变量
int i; printf("%x",&i);
地址的大小是否与int相同取决于编译器
int i; printf("%p",&i);

作为参数的指针
void f(int *p);
在被调用的时候得到了某个变量的地址：
int i=0; f(&i);
在函数里面可以通过这个指针访问外面的这个i

访问哪个地址上的变量*
*是单目运算符， 用来访问指针的值所表示的地址上的变量
可以做右值也可以做左值
int k = *p;
*p = k + 1;

数组参数
以下四种函数原型是等价的：
int sum(int *ar, int n);
int sum(int *, int );
int sum(int ar[], int n);
int sum(int [], int);

字符类型
char是一种整数，也是一种特殊的类型：字符。这是因为：
用单引号表示的字符字面量；'a','1'
''也是一个字符
printf和scanf里用%c来输出输入；

string.h
strlen  返回长度  sizeof（）会加上回车
strcmp
strcpy
strcat
strchr
strstr

给一个指针加1表示要让指针指向下一个变量
int a[10];
int *p = a;
*(p+1) -> a[1]
如果至真不是指向一片连续分配的空间，如数组，则这种运算没有意义
指针计算
这些算术运算可以对指针做
给指针加，减一个整数(+ += - -=)
递增递减(++/--)
两个指针相减

指针的类型
无论执行什么类型，所有的指针的大小都是一样的，因为都是地址
但是指向不同类型的指针是不能直接相互赋值的
这是为了避免用错指针

指针的类型转换
void* 表示不知道指向什么东西的指针
计算时与char*相同（但不相通）
指针也可以转换类型
int *p &i; void *q = (void*)p;
这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量
我不在当你是int 就认为是个void

用指针来做什么
需要传入较大的数据时用作参数
传入数组后对数组做操作
函数返回不止一个结果
需要用函数来修改不止一个变量
动态申请的内存


*p++
取出p所指的那个数据来，完事之后顺便把p移到下一个位置去。
*的优先级虽然高，但是没有++高
常用于数组类的连续空间操作
在某些CPU上，这可以直接被翻译成一条汇编指令

指针比较
<,<=,==,>,>=,!=都可以对指针做
比较它们在内存中的地址
数组中的单元的地址肯定是线性递增的

0地址
当然你的内存中有0地址，但是0地址通常是个不能随便碰的地址
所以你的指针不应该具有0值
因此可以用0地址来表示特殊的事情；
	返回的指针是无效的
	指针没有被真正初始化（先初始化为0）
NULL是一个预定义的符号，表示0地址
有的编译器不愿意你用0来表示0地址


输入数据
int *a = (int*)malloc(n*sizeof(int)); 

	malloc
#include<stdlib.h>
void malloc(size_t size);
向malloc申请的空间的大小是以字节为单位的
返回的结果是void* 需要类型转换为自己需要的类型
(int*)malloc(n*sizeof(int))

没空间
如果申请失败则返回0，或者叫做NULL
你的系统能给你多大的空间
 
free()
把申请得来的空间还给“系统”
申请过的空间，最终都应该要还
混出来的，迟早都是要还的。
只能还申请来的空间的首地址

常见问题
申请了没free--->长时间运行内存逐渐下降
新手：忘了
老手：找不到合适的free时机
free过了在free
地址变过了，直接去free

putchar
int putchar(int c);
向标准输出一个字符
返回及格字符，EOF(-1) 表示写失败

getchar
int getchar(void)
从标准输入读入一个字符
返回类型是int是为了返回EOF（-1）
Windows ---> Ctrl-Z
Unix ---> Ctrl

字符串数组
char **a
a是一个指针，指向另一个指针，那个指针指向一个字符串
char a[][]

程序参数
int main(int argc, char const *argv[])
argv[0]是命令本身
当使用Unix的符号链接时，反映符号链接的名字

string.h
strlen   size_t strlen(const char *s)
	    
strcmp	:int strcmp(const char *s1,const char *s2)
		比较两个字符串，返回：
		0：s1 == s2
		1: s1 > s2
		-1: s1 < s2
strcpy  :char *strcpy(char *restrict dst, condt char *restrict src);
		把src的字符串拷贝到dst
		restrict表明src和dst不重叠（c99）
		返回dst
		为了能连起代码来
		复制一个字符串
		char *dst = (char*)malloc(strlen(src)+1)
		strcpy(dst,src)
strcat
strchr	: 字符串中找字符
		char * strchr(const char *s, int c); //从数组的左边找c看看在第几行
		char *strrchr(const char *s, int c);//从数组的右边 	找c看看在第几行
		返回NULL表示没有找到
		如何寻找第二个
		
strstr

枚举
枚举是一种用户定义的数据类型，它用关键字enum以如下语法声明：
	enum 枚举类型名字{名字0，...名字n}；
枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是
常量符号，它们的类型是int， 值则一次从0到n。如：
		enum colors{red,yellow,green}
就创建了三个常量，red的值是0，yellow是1， 而green是2
当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字

枚举量可以作为值
枚举类型可以跟上enum作为类型
但是实际上是以整数来做内部计算和外部输入输出的

枚举量
声明枚举量的时候可以指定值
enum COLOR {RED=1, YELLOW, GREEN=5};
枚举只是int

虽然枚举类型可以当做类型使用，当时机上很少用
如果有意义上排比的名字，用枚举比const int 方便
枚举比宏(macro)好， 因为枚举有int 类型

结构成员
结构和数组有点像
数组用[]运算符合下标访问其成员
a[0] = 10;
结构用.运算符和名字访问其成员
today.day
student.firstName
pl.x
pl.y

结构运算
要访问整个结构，直接用结构变量的名字
对于整个结构，可以做赋值，取地址，也可以传递给函数参数
pl = (struct point){5,10}; 	//相当于pl.x=5；
pl.y = 10;
pl = p2;	//相当于pl.x = p2.x; pl.y = p2.y;

结构指针
和数组不同，结构变量的名字并不是结构变量的地址，必须用&运算符&

struct date *pDate = &today;

结构作为函数
int numberOfDays(struct date d)

整个结构可以作为参数的值传入函数
这时候是在函数内新建一个结构变量，并赋值调用者的结构的值。
也可以返回一个结构
这与数组完全不同

输入结构
没有直接的方式可以一次scanf一个结构
如果我们打算写一个函数来读入结构
但是读入的结构如何送回来呢
记住c在函数调用时是传值的
所以函数中的p与main中的y是不同的
在函数读入了p的数值之后，没有任何东西回到main，所以y还是{0,0}

结构指针作为参数
K & R说过（p.|3|）
"If large structre is to be passed to a function, it is generally more 
efficient to pass a pointer than to copy the whole structure"

指向结构的指针
struct date{
	int month;
	int day;
	int year;
}myday;

struct date *p = &myday;

(*p).month = 12;
p-> month = 12;
用->表示指针所指的结构变量中的成员  


结构中的结构
struct dateAndTime{
	struct date sdate;
	struct time stime;
}

嵌套的结构
struct point{
	int x;
	int y;
};
struct rectangle {
	struct point pl1;
	struct point pl2;
}
如果有变量
	struct rectangle r;
就可以有：
	r.ptl.x, r.ptl.y
	r.pt2.x 和 r.pt2.y 

自定义数据类型(typedef)
c语言提供了一个叫做typedef的功能来声明已有的数据类型的新名字。比如
typedef int Length;
使得Length成为int 类型的别名。
这样，Length这个名字就可以替代int 出现在变量 定义和参数声明的地方了；
Length a,b,len;
Length numbers[10];

Typedef
声明新的类型的名字
新的名字是某种类型的别名
改善了程序的可读性

联合
union AnEit{
	int i;
	char c;
}elt1, elt2;
elt1.i = 4;
elt.c = 'a';
elt2.i = 0XDEADBEEF;  

联合
存储
所有的成员共享一个空间
同一时间只有一个成员是有效的
union的大小是其最大的成员
初始化
对第一个成员做初始化


全局变量初始化、没有做初始化的全局变量会得到值
指针会得到NULL值
只能用编译时刻已知的值来初始化全局变量
它们的初始化发生在main函数之前

静态本地变量
在本地变量定义时加上static修饰符就成为静态本地变量
当函数离开的时候，静态本地变量会继续存在并保持其值
静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值
---静态本地变量实际上是特殊的全局变量
它们位于相同的内存区域
静态本地变量具有去、全局的生存期，函数内的局部作用域，
static在这里的意思是局部作用域

*返回指针的函数
返回本地变量的地址是危险的
返回全局变量或静态本地变量的地址是安全的
返回在函数内malloc的内存是安全的，但是容易造成问题
最好的做法是返回传入的指针

tips
不要使用全局变量来在函数间传递参数和结果
尽量避免使用全局变量
丰田的案子
*使用全局变量和静态本地变量的函数线程不安全的

编译预处理指令
#开头的是编译预处理指令
它们不是c语言的成分，但是C语言程序离不开它们
#define用来定义一个宏
#define PI 2.14159  原始的文本替换

#define
#define<名字><值>
注意没有结尾的分号，因为不是C的语句
名字必须是一个单词，值可以是各种东西
在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序的名字换成值
完全的文本替换
gcc -- save-temps

宏
如果一个宏的值中有其他的宏的名字，也是会被替换的
如果一个宏的值超过一行，最后一行之前的行未需要加\
宏的值后面出现的注释不会被当作宏的值的一部分

没有值的宏
#define _DEBUG
这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了

预定义的宏
__LINE__  当前所在的行号
__FILE__  文件名
__DATE__  时间
__TIME__
__STDC__

像函数的宏
#define cube(x) ((x)*(x)*(x))

带参数的宏的原则
一切都要括号
整个值要括号
参数出现的每个地方都要括号
#define RADTODEG(x)((x)*57.29578)
带参数的宏
可以带多个参数
#define MIN(a,b)((a)>(b)?(b):(a))
也可以组合（嵌套）使用其他宏
宏不能在结尾加 ;

带参数的宏
在大型程序的代码中使用非常普遍
可以非常复杂，如“产生”函数体
在#和##这两个运算符的帮助下
存在中西方文化差异
部分宏会被inline函数替代

宏的问题是函数没有类型， 这会让错误不太明显

多个.c文件
main()里的代码太长了适合分成几个函数
一个源代码文件太长了适合分成几个文件
两个独立的源代码文件不能编译形成可执行的程序。

头文件
把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件(.c文件)
中的#include这个头文件，就能让编译器在编译的时候知道函数的原型

#include
%include是一个编译预处理指令，和宏一样，在编译之前就处理了，
它把那个文件的全部文本内容原封不动地插入到它所在的地方
所以也不是一定要在.c文件的最前面#include