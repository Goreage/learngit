一、如何学习Java
1、打牢基础，切勿好高骛远
2、从基础入手、多敲多练
3、按照Java本身的学习规律、踏踏实实的学习
4、扎实的基本功是学习一切Java的关键
二、基础Java
第1章：Java语言概述
1.1 Java语言的发展历史
Java语言历史十多年，已经发展成为人类计算机史上影响深远的编程语言，从某种程度上说，它甚至超出了编程语言的范畴，成为一种开发平台，一种开发规范。
	
	Java语言的诞生具有一定的戏剧性，它并不是经过精心策划、制作而产生的划时代的产品，从某个角度来看，Java语言的诞生完全是一个误会。

	在1990年末，Sun公司预料嵌入式系统将会在未来家电器领域中占有重要地位。于是成立了由詹姆斯.高林斯(James Gosling)领导的“Green计划”，准备为下一代智能家电编写一个通用的控制系统。

	该团队最初考虑使用C++语言，但是很多成员其中包括Sun的首席科学家比尔.乔伊发现C++语言还有可用的API（Application Programming Interface,应用程序编程接口。是一些预先定义的函数，目的是提供应用程序与开发人员基于软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。）在某些方面存在很大问题。而且工作小组使用的是嵌入式平台，可用的系统资源极其有限。并且C++语言太复杂，以至于开发者很容易出错，而且C++缺少垃圾回收机制、可移植性、分布式和多线程等功能。所以比尔.乔伊决定开发一种新语言，它提议在C++的基础上，开发一种面向对象的环境。于是詹姆斯试图修改和扩展C++的功能来满足这个要求，但是后来他放弃了，决定创造一种全新的语言：OaK。

	1992年夏天，Green计划已经完成了新平台的部分功能，包括Green操作系统、Oak的程序设计语言、类库等，同年11月，Green计划被转化成为“FirstPerson有限公司”，一个Sun公司的全资子公司。公司致力于创建一种高度互动的设备，当时代华纳公司发布了一个关于电视机顶盒的征求提议书时，FirstPerson改变了他们的目标，作为对征求提议书的响应，提出了一个机顶盒平台的提议，但是有线电视业界觉得FirstPerson的平台给与用户过多的控制权，因此FirstPerson的投标失败给了SGI，同时与3DO公司的另外一笔关于机顶盒的交易也没有成功。

	在Green项目几乎夭折的情况下，1994年夏天互联网和浏览器的出现不仅给广大互联网用户带来了福音，同时也为Oak语言带来新的生机。詹姆斯意识到这是一个机会，于是对Oak进行了小规模的改造，到了94年秋天，小组中成员诺顿(Naughton)和乔纳森.佩恩(Jonathan Payne)完成了第一个Java语言的网页浏览器：WebRunner。当时Oak这个商标已被别人注册，于是Java诞生了。

	Sun公司在1995年年初发布了Java语言，Sun公司直接把Java放到互联网上，免费给大家使用。甚至源代码也不保留，也放在互联网上向所有人公开。几个月后，让所有人都大吃一惊的事发生了，Java成为互联网上最热门的语言。10多万人次访问了Sun公司的网页，下载Java语言。然后互联网上立即就有数不清的的Java小程序，演示各种小动画、小游戏等。
	
	在Java语言出现之前，互联网的网页实质上就是一张纸，不会由任何动态的内容，有了Java语言之后，浏览器的功能被扩大了，Java程序可以直接在浏览器中运行，可以直接与远程服务器进行交互。
	
	1995年，Sun虽然推出了Java，但这只是一种语言，如果想开发复杂的应用程序，必须要有一个强大的开发类库，因此在1996年年初发布了JDK1.0，这个版本包括两部分：运行环境（JRE）和开发环境（JDK）。运行环境和开发环境共同包括核心API、集成API、用户界面API、发布技术、Java虚拟机（JVM）五部分。而开发环境还包括编译Java程序的编译器，即javac命令。

	Sun在1997年2月18日发布了JDK1.1。JDK1.1增加了JIT（即时编译）编译器，JIT和传统的编译器有所不同，传统的编译器是编译一条，运行完成后将其扔掉；而JIT会将经常用到的指令保存在内存中，当下次调用时就不需要重新编译了，通过这种方式让JDK在效率上有了较大提升。一直以来，Java主要的应用就是网页上的Applet以及一些移动设备。到了1996年年底，Flash面世，这是一种更加简单的动画设计软件，使用Flash几乎无须任何编程语言知识，就可以作出丰富多彩的动画。随后Flash还增加ActionScript编程脚本，Flash逐渐蚕食了Java在网页上的应用。

	从1995年Java的诞生到1998年年底，Java语言虽然成为了互联网上广泛使用的编程单元，但它并没有找到一个准确的定位，也没有找到它必须存在的理由：Java语言可以编写Applet，而Flash一样可以做到，而且更快，开发成本更低。

	直到1998年12月，Sun公司发布了Java历史上最重要的JDK版本：JDK1.2，伴随JDK1.2一同发布的还有JSP/Servlet、EJB等规范，并将Java分成了标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本。
J2SE就是Java2的标准版，主要用于桌面应用软件的编程；
J2ME主要应用于嵌入式系统开发，如手机和PDA的编程；
J2EE是Java2的企业版，主要用于分布式的网络程序的开发，如电子商务网站和ERP系统。

	这标志着Java已经吹响了向企业、桌面和移动3个领域进军的号角，标志着Java已经进入了Java2时代，这个时期也是Java飞速发展的时期。

	不仅如此，JDK1.2还把它的API分成了三类：
?	核心API：由Sun公司制定的基本的API，所有的Java平台都应该提供。这就是Java核心类库。
?	可选API：这是Sun公司为JDK提供的扩充的API，这些API因平台的不同而不同。
?	特殊的API：用于满足特殊要求的API。如JCA和JCE的第三方加密类库。

2002年2月，sun公司发布了JDK历史上最为成熟的版本：JDK1.4。此时由于康柏（Compaq）、富士通（Fujitsu）、SAS、塞班（Symbian）、IBM等公司的参与，使得JDK1.4成为发展最快的一个JDK版本。到JDK1.4为止，我们已经可以使用Java实现大多数的应用了。

在此期间，Java语言在企业应用领域大放光彩，涌现了大量基于Java语言的开源框架：Struts、WebWork、Hibernate、Spring等，大量企业应用服务器中间件也开始涌现：WebLogic、WebSphere、Jboss等，这些都标志着Java语言进入了飞速发展时期。

2004年10月，Sun发布了万众期待的JDK1.5，同时，Sun将JDK1.5改名为Java SE5.0，J2EE、J2ME也相应的改名为Java EE和Java ME。JDK增加了诸如泛型、增强for语句、可变数量的形参、注释、自动拆箱和装箱等功能。同时也发布了新的企业级平台规范，如通过注释等新特性来简化EJB的复杂性，并推出了EJB3.0规范。还推出了自己的MVC框架规范：JSF，JSP规范。

2006年12月，Sun公司发布了JDK1.6，一直以来Sun公司维持着大约2年发布一次JDK新版本的习惯。

但在2009年4月20日，Oracle公司宣布将以每股9.5美元的价格收购Sun公司，该交易总价值为74亿美元。而Oracle通过收购Sun公司获得了两项软件资产：Java和Solaris。

同年java之父詹姆斯离开了Sun公司，进入到了Google公司。

Sun倒下了，不过Java的大旗依然在树立着，2007年11月，Google宣布推出了一款基于Linux平台的开源手机操作系统：Android。Android的出现顺应了即将出现的移动互联网潮流，而且Android系统的用户体验非常好，因此迅速成为手机操作系统中的中坚力量。Android平台使用了Dalvik虚拟机来运行.dex文件，Dalvik虚拟机的作用类似于JVM虚拟机，只是它并未遵循JVM规范而已。Android使用Java语言来开发应用程序。这也给Java语言一个新的机会。

2011年7月28日，oracle公司如约发布了Java SE7.0版本，这次版本升级经过了将近5年时间，Java SE7.0也是Oracle发布的第一个Java版本。JavaSE7.0虽然并未完全满足所有人的期望，不过他也加入了不少新的特性，至此Java发展历程到此结束，而我们学习的也是基于JDK1.6版本，目前大多数公司开发也是基于JDK1.6版本进行的。

1.2 Java程序运行机制
Java语言是一种特殊的高级语言，它既具有解释型语言的特性，也具有编译型语言的特征，因为Java程序要经过先编译，后解释两个步骤。

计算机高级语言按程序的执行方式可以分为编译型和解释型两种。

编译型语言是指使用专门的编译器，针对特定的平台（操作系统）将某种高级语言源代码一次性“翻译”成可被执行的机器码，并包装成该平台所能识别的可执行性程序的格式，这个转换过程成为编译。编译生成的可执行程序可以脱离开开发环境，在特定的平台上独立运行。
举例：First.java   javac.exe   First.class 

解释型语言是指使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行的语言。解释型语言通常不会进行整体性的编译，解释型语言相当于把编译型语言中编译和解释过程混合到一起同时完成。

1.3 运行Java程序的JVM
	Java语言比较特殊，由Java语言编写的程序需要经过编译步骤，但这个编译步骤并不会生成特定平台的机器码，而是生成一种与平台无关的字节码（*.class）。这种字节码不是可执行的，必须使用Java解释器来解释执行。如下图所示：
 

Java语言中负责解释执行字节码文件（*.class）的是Java虚拟机，即JVM（Java Virtual Machine）。JVM是可运行Java字节码文件的虚拟计算。JVM是一个抽象的计算机，和实际的计算机一样，它具有指令集并使用不同的存储区域。它负责执行指令，还要管理数据、内存和寄存器。

1.4 开发Java的准备
第一步：下载并安装、配置Java程序需要的JDK（Java SE Development Kit），即Java标准版开发包。它提供了编译、运行Java程序所需要的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库。
甲骨文官方中文版：http://www.oracle.com/cn/downloads/index.html 
下载JDK的地址：http://www.oracle.com/technetwork/cn/java/archive-139210-zhs.html 

第二步：配置环境变量path
 
环境变量path，在windows系统下path不区分大小写，在Linux系统下区分大小写，所以一般写成PATH。
Path: C:\Java\jdk1.6.0\bin;

1.5 第一个Java程序
使用记事本书写，保存为HelloWorld.java

public class HelloWorld{
	public static void main(String args[]){
	System.out.println(“My First Java Program.”);
}
} 
注意：文件名要与类名相同

使用Javac命令编译此文件: javac HelloWorld.java，会在当期目录下生成一个与此文件名相同的类文件HelloWorld.class。运行此文件：java HelloWorld

1.6 Java程序的组织形式
	Java程序是一种纯粹的面向对象的程序设计语言，因此Java程序必须以类（class）的形式存在，类是Java程序的最小程序单位。Java程序不允许可执行性语句、方法等成分独立存在。

	Java程序源文件的命名不是随意的，后缀名必须是.java，在通常情况下Java程序源文件名是可以任意命的，但有一种情况例外：如果Java程序源代码中定义了一个public的类，那么该源文件名必须与该public类的类名相同，所以一个Java源文件里最多只能定义一个public类。

	为了提供更好的可读性，建议一个Java源文件只定义一个类，不同的类使用不同的源文件定义；让Java源文件名与源文件中定义的public类同名。

	Java语言中是严格区分大小写的语言。
	
	如果需要使用Java解释器直接运行一个Java类，那么这个Java类必须包含main方法，这个方法必须使用public和static类进行修饰。

1.7 垃圾回收机制
	传统的C/C++等编程语言，需要程序员负责回收已经分配出去的内存。显示进行垃圾回收是一件令人头疼的事情，因为程序员并不总是知道内存应该何时进行释放。如果一些分配出去的内存不能及时的回收就会引起系统运行速度下降，甚至导致程序瘫痪，这种现象称为内存泄露。

	与C/C++语言不同，Java语言不需要程序员自己去控制内存回收，Java程序的内存分配和回收都是由JRE在后台自动进行的。JRE会负责回收那些不再使用的内存，这种机制被称为垃圾回收机制（Garbage Collection，也被称为GC）。通常JRE会提供一个后台线程来进行检测和控制，一般都是在CPU空闲或者内存不足时自动进行垃圾回收。

	Java的堆内存是一个运行时数据区，用来保存类的实例对象，Java虚拟机的堆内存中存储着正在运行应用程序所建立的所有对象，这些对象不需要程序通过代码来显示地释放。所以GC回收的是Java堆内存空间。当一个对象不再被引用的时，内存回收它占领的空间。

	垃圾回收的潜在缺点是它的开销影响程序性能，Java虚拟机必须跟踪程序中有用的对象，才能确定哪些对象是无用的，并最终释放这些无用的对象，这个过程需要花费处理器的时间。

?	垃圾回收机制的工作目标是回收无用对象的内存空间，这些内存空间都是JVM堆内存里的内存空间。
?	为了更快的让垃圾回收机制回收那些不再使用的对象，可以将对象的引用变量设置为null。
?	垃圾回收发生的不可预知性，有可能是当CPU空闲是发生，也有可能等到内存消耗出现极限时发生。
?	垃圾回收的精确性主要包括两个方面：一是垃圾回收能够精确的标记活着的对象；二是垃圾回收器能够精确的定位对象之间的引用关系。
?	现在的JVM有多种不同的垃圾回收实现，每种回收机制因其算法差异而表现各异。

第2章：理解面向对象
	Java语言是纯粹的面向对象的程序设计语言，主要表现为Java完全支持面向对象的三种基本特性：封装、继承和多态。

2.1 封装
	封装：将对象的实现细节隐藏起来，然后通过一些公用的方法来暴露该对象的功能。
举例：
package com.langsin.test;
public class Car {
	private String name;
	private String color;
	private String speed;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getColor() {
		return color;
	}
	public void setColor(String color) {
		this.color = color;
	}
	public String getSpeed() {
		return speed;
	}
	public void setSpeed(String speed) {
		this.speed = speed;
	}
	public void run(){
		System.out.println("车的名字："+this.getName());
		System.out.println("车的颜色："+this.getColor());
		System.out.println("车的时速："+this.getSpeed());	
}
	public static void main(String args[]){
		Car car = new Car();
car.setColor("绿色");
		car.setName("解放");
		car.setSpeed("60码/时");
		car.run();
	}
}
输出结果：
车的名字：解放
车的颜色：绿色
车的时速：60码/时

2.2 继承
	继承：继承是面向对象实现软件重用的重要手段，当子类继承父类后，子类将直接调用父类的非私有的属性和方法。

举例：
package com.langsin.test;

public class BmwCar extends Car {
	public static void main(String[] args) {
		BmwCar car = new BmwCar();
		car.setColor("黑色");
		car.setName("BMW");
		car.setSpeed("300码/时");
		car.run();
	}
}
输出结果：
车的名字：BMW
车的颜色：黑色
车的时速：300码/时
2.3 多态
	多态：多态指的是子类的实例对象可以直接赋给父类类型的变量，但运行时依然体现出子类的行为特征，这就意味着同一个类型的对象在执行同一个方法时，表现出多种行为特征。
编译时多态：该去调用那个方法在编译期就确定了
运行时多态：调用那个方法在编译期还不确定

举例：
public class TestCar {
	public static void main(String[] args) {
		Car carOne = new BenzCar();
		carOne.setColor("蓝色");
		carOne.setName("奔驰");
		carOne.setSpeed("300码/时");
		carOne.run();
		System.out.println("-----------------------------");
		Car carTwo = new BmwCar();
		carTwo.setColor("黑色");
		carTwo.setName("BMW");
		carTwo.setSpeed("300码/时");
		carTwo.run();
	}
}
输出结果：
车的名字：奔驰
车的颜色：蓝色
车的时速：300码/时
-----------------------------
车的名字：BMW
车的颜色：黑色
车的时速：300码/时

2.4 Java面向对象特征
	在Java语言中，除了8个基本的数据类型外（byte、short、int、long、char、boolean、float、double），一切都是对象，而对象就是面向对象程序设计的中心。
	
	对象具有状态，一个对象用数据值来描述它的状态。对象实现了数据和操作的结合，对象把数据和对数据的操作封装成一个有机的整体。对象是Java程序的核心，所以Java里的对象具有唯一性。

2.5类和对象
	具有相同或相似性质的一组对象的抽象化就是类，类是对一类事物的描述，是抽象的、概念上的定义，对象是实际存在的该类事物的个体。对象的抽象化是类，类的具体化就是对象，也可以说类的实例对象。

	Java语言使用class关键字定义类，Java语言使用extends关键字来表示继承关系。使用new关键字来创建指定类的具体实例对象。

	举例：
	Public class Car{
}

	Public class BmwCar extends Car{
}
	Car car = new Car();

第3章：数据类型及运算符
	Java语言是一门强类型语言，强类型语言包含两方面含义：
1、所有的变量必须先声明后使用；
2、指定类型的变量只能配置指定类型的值。
	
举例：Car car = null;  car = new Car();
	  car.run();
3.1 注释
?	单行注释：Java语言中使用双斜杠（//）放在要注释的内容之前。
?	多行注释：使用“/*”和“*/”将程序中需要注释的内容包括起来。
?	文档注释：文档注释是已“/**”开始，以星号紧跟一个斜杠（*/）结尾。

举例：
package com.langsin.test;

public class Car {
	//定义String类型的变量表示车的名称
	private String name;
	//定义String类型的变量表示车的颜色
	private String color;
	/*
	 * 多行注释，可进行换行，注释既可以描述代码含义
	 *  也可以注释代码块，使被注释的代码不在被执行
	 */
	private String speed;
	
	/**
	 * Description <br>
	 * 	获取车的名称
	 * @author pengjianming
	 * 	@version 1.0
	 * */
	public String getName() {
		return name;
	}		
}
3.2 标识符
	Java语言里的分号（;）、花括号（{}）、小括号（()）方括号（[]）、空格、圆点（.）都具有特殊的分隔作用因此被统称为分隔符。

	举例1：
	int age = 25;    String name = “zhangsan”; 

	举例2：
	Public void run(){
		//花括号用来包含代码块，代码块在逻辑上是一个整体。
}

举例3：
private int a[] = new int[4];//定义一个4个长度的int类型的数组对象，数组里面必须存放int类型的数值
a[0] = 1; //数组的访问是以索引值（index）开始的，也称为下标，索引（下标）是以0为起始值的。

举例4：
圆括号是一个功能丰富的分隔符，定义方法时必须使用圆括号来包含形参声明，调用方法是也必须使用圆括号来传入参数；例如：
Class类：Car
private String name; 
public void setName(String name){
	this.name = name;
}

public static void main(String args[]){
	Car car = new Car(); //生成类的实例对象时也必须带有小括号，默认的动作是调用类的构造方法。
	car.setName(“BMW”);
}

	举例5：
	Java语言使用空格分隔一条语句的不同部分，如上例所示。

	举例6：
	圆点通常用做（类/对象）和它的成员之间的分隔符，表明调用某个类或者某个实例的指定成员。

3.3 标识符规则
	标识符就是用于给程序中变量、类、方法名的命名的符号，因为Java是区分大小写的所以abc和Abc是两个不同的标识符，规则如下：

?	标识符可以由字母、数字、下划线（_）和美元符号（$）组成，其中数字不能打头。
?	标识符不能是Java的关键字和保留字，可以包含关键字和保留字，例如String abcString = “abc”;
?	标识符不能包含空格。例如：String a bc = “123”;
?	标识符只能包含美元符号（$）不能包含其他特殊字符，如：@ # 

3.4 Java关键字
	Java语言中有一些具有特殊用途的单词被称为关键字，定义标识符时不要让标识符和关键字相同，否则会引起错误。Java的关键字都是小写，Java一共包含48个关键字。
abstract	assert	boolean	break	byte	case	catch	char
class	continue	default	do	double	else	enum	extends
final	finally	float	for	if	implements	import	int
interface	instanceof	long	native	new	package	private	protected
public	return	short	static	strictfp	super	switch	synchronized
this	throw	throws	transient	try	void	volatile	while

3.5 数据类型
	Java语言支持的数据类型分为两类：
基本数据类型
引用类型(对象类型、复杂数据类型)

	1、基本数据类型共8中，分为布尔类型（boolean）和数值类型，数值类型又分为整数类型和浮点类型。整数类型包括byte、short、int、long、char，浮点类型包括float（单精度浮点）和double（双精度浮点）

	2、引用类型包括类、接口、和数组类型，还有一种特殊null类型。引用数据类型就是对一个对象的引用，对象包括实例和数组两种。空类型（null）就是null值类型，这种类型没有名称，所以不能声明一个null类型的变量或者转换到null类型。

3.5.1 整型
byte：byte（字节）类型的整数在内存里占8位，表示的范围是：-128（-2的7次方） ~ 127 （2的7次方-1）
short：short（2个字节长度）类型整数在内存里占16位，表示范围-32768 ~ 32767
int：int（4个字节长度）类型在内存中32位，表示范围-2147483648 ~ 2147483647
long：long（8个字节长度）类型在内存中64位，表示范围-9223372036854775808 ~ 9223372036854775807

int类型是常用的整数类型，Java整数常量默认的就是int类型。使用byte或者short类型时，整数的范围不能超过类型的范围，Java直接将整数常量当成byte或者short类型。例如：
byte a = 24;  short b = 1255;

但是使用几个巨大的整数常量时，Java不会自动把整个整数常量当成long类型，所以需要在整数常量后面加上L作为后缀，例如
long a = 99999999999999999L; 

Java中整数常量有4种表示方式：十进制，二进制（0b或者0B开头），八进制（以0开头），十六进制（以0x或者0X开头）。

举例：int octalValue = 013; //八进制转换成十进制表示11
      int hexValue1 = 0X13; //十六进制转换成十进制表示19
	  int hexValue2 = 0XAF; //十六进制转换成十进制表示175
	  int binValue1 = 0B11011; //二进制转换成十进制表示27（JDK1.7中新增特性）
3.5.2 补码、反码、原码
	所有的数字在计算机底层都是以二进制形式存在，但是计算机以补码的形式保存所有的整数。
	定义32位的二进制整数时，最高位其实是符号位。符号位是1表示负数，0表示正数
	举例：
	int a = 0B10000000000000000000000000000011; //这是一个补码表示-2147483645
2^32
2^64
2^128
	
	原码：直接将一个数值换算成二进制数。
	补码：正数的补码和原码完全相同，负数的补码是其反码加1。
	反码：是对原码按位取反，只是最高符号位保持不变。
源码->反码->补码

	举例：
	1000 0000 0000 0000 0000 0000 0000 0011 为补码，要获得它的具体指需要先获取它的反码
	负数的补码是其反码+1，那么其反码就是补码-1；
	1000 0000 0000 0000 0000 0000 0000 0010 为反码，原码是对反码取反
	1111 1111 1111 1111 1111 1111 1111 1101 为原码，//-2147483645

3.5.3 字符型
	字符型常用于表示单个字符，字符常量必须使用单引号括起来，例如：char a = ‘a’;char类型的值也可以直接作为整数类型的值来使用，是一个16位的无符号整数，范围是0 ~ 65535 表示方式如下：
	
?	直接通过单个字符来指定字符常量，例如’A’ ‘a’  ‘0’
?	通过转义字符表示特殊字符型常量，例如：’\n’ ‘\t’  ‘\r’
?	直接使用Unicode值来表示字符常量，例如：’\uXXXX’，XXXX表示一个十六进制的整数。

举例：
char aChar = 'a';
char enterChar = '\t';
char ch = '\u667F';
char name = '张';
int value = name;
System.out.println(aChar);
System.out.println(enterChar);
System.out.println(ch);
	System.out.println(value);
3.5.4 浮点型
	Java浮点类型：float和double。float占4个字节（byte）32位，double占8个字节（byte）64个长度。
float类型的常量后面必须以f或者F结尾，例如：float a = 12.55f; double类型的常量后面可以d或者D结尾，但是不强制追加，不写也没有问题。
	特殊情况：正无穷大、负无穷大、非数分别用基本数据类型对应的封装类来表示，
浮点数的表示方式分为两种：
1、	十进制方式  float a = 12.55f;
2、	科学计数法形式： float a = 12.5e2f;
举例：
float a = 12.555f;
double b = 12.55;
float a = 12.55e5f;
float c = Float.NaN; //不是一个数
float d = Float.NEGATIVE_INFINITY; //负无穷大
int e = Integer.MIN_VALUE; //最大值
3.5.5 布尔型
	布尔型只有一个boolean类型，用于表示逻辑上的“真”或者“假”，数值只能是true或者false
举例：
boolean a = true; boolean b = false;
常用在逻辑判断上，例如：
if(a){
	System.out.println(“条件为真”);
}else{
	System.out.println(“条件为假”);
}
3.6 基本数据类型转换
	Java程序中，不同的基本类型的值经常需要进行相互转换，Java提供了两种类型转换方式：自动类型转换和强制类型转换。
3.6.1、自动类型转换
将一种基本数据类型的值直接赋给另一种基本数据类型，则这种方式被称为自动类型转换。前提是把一个范围小的数值或变量直接赋值给另一个数据范围大的变量时，系统可以进行自动类型转换。
举例：
byte a = 25;
	short b = a;
	long c = a;
	float d = a;
	System.out.println(d);
注意：不能将数据范围大的变量或数值赋值给范围小的变量，例如：int a = 25; byte b = a; 会直接报错。
换行顺序：byte->short->int->long->float->double
               char->
3.6.2、强制类型转换
	将大范围的数据向小范围的数据进行转换则需要进行强制转换，语法格式为：（targetType）value；
例如：
float d = 12.5F;
	int e = (int)d; //变量e的值为整数12，不会保留小数
	
	如果大范围的数据值超过了小数据的的范围，则按位进行截取。

	int a = 327775;
	short b = (short)a;
	System.out.println(b); //输出结果95

3.7 运算符
	运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。Java语言使用运算符将一个或多个操作数据连接成执行性语句，用以实现特定功能。
?	算术运算符
?	赋值运算符
?	比较运算符
?	逻辑运算符
?	位运算符
?	类型相关运算符
3.7.1 算术运算符
加法运算（+）、减法运算（-）、乘法运算（*）、除法运算（/）、取余（取模）运算（%）、自加运算（++）、自减运算（--）、（+）还可以做为字符串的连接符。
举例：
int a = 12;
		int b = 24;
		System.out.println("加法运算："+(a+b)); // 36
		System.out.println("减法运算："+(a-b)); //-12
		System.out.println("乘法运算："+a*b); //288
		System.out.println("除法运算："+a/b); //0
		System.out.println("取模运算："+a%b); //12
		int c = --a;
		System.out.println(c); //11
		System.out.println(a); //11
		c = b--;
		System.out.println(c); //24
		System.out.println(b); //23
3.7.2 赋值运算符
	Java使用“=”作为赋值运算符，为变量指定变量值。举例：
	int a = 5;   String b = “abc”;
3.7.3 位运算符
	Java支持的运算符有7个：按位与（&）、按位或（|）、按位非（~）、按位异或（^）、左移运算符（<<）、右移运算符（>>）、无符号右移运算符（>>>）

基本运算法则：
第一个运算数	第二个运算数	按位与（&）	按位或（|）	按位异或（^）
0	0	0	0	0
0	1	0	1	1
1	0	0	1	1
1	1	1	1	0

按位非运算，举例：
int a = 19;   System.out.println(~a); //输出结果为-20
运算原理：19的二进制表示方式为：00010011 按位非运算为：11101100 按位计算后的值为补码，（计算机都是按照补码进行表示的），根据补码获取它的反码，前面为1表示为负数，负数的反码是：补码减1，因此其反码为11101011，其原码为10010100，转换成十进制为-20。

右移运算：Java的右移运算符有两个>>和>>>，对于>>运算符，把第一个操作数的二进制码向右移动指定位数后，左边空出来的位数以原来的的符号位填充，如果是正数用0填充，如果是负数用1填充，>>>运算符移动后，只用0填充。
举例：
-5>>2
-5的原码是1000 0101，它的反码为：1111 1010，它的补码为：1111 1011，右移两位为：1111 10，前面用符号位填充为：1111 1110（补码）。将补码转换成十进制数―》先变成反码：1111 1101，其原码为：1000 0010，表示未十进制数为：-2。

-5>>>2用32表示（原因：计算自动转换类型为int，int类型为32位）
-5的原码为：1000 0000 0000 0000 0000 0000 0000 0101，
其反码为：1111 1111 1111 1111 1111 1111 1111 1010
其补码为：1111 1111 1111 1111 1111 1111 1111 1011
右移后为：0011 1111 1111 1111 1111 1111 1111 1110（补码）
其原码为：0011 1111 1111 1111 1111 1111 1111 1110
转换成十进制为：2的30次方减2为：Math.pow(2,30)-2。
3.7.4 扩展后的赋值运算符
	赋值运算符可以与算术运算符、位移运算符结合，扩展成功能更加强大的运算符。
?	+=：对于x += y，表示 x = x + y；
?	-=：对于 x -= y，表示 x = x-y；
?	*=：  x*= y，表示 x = x * y；
?	/= ; %=; &=; |=; ^=; <<= ; >>=; >>>=;
3.7.5 比较运算符
	比较运算符用于判断两个变量或者常量的大小，比较运算的结果是一个boolean值（true或者false）
?	>：大于，只支持左右两边操作数是数值类型。
?	>=：同上
?	<：同上
?	<=：同上
?	==：同上，即使他们数据类型不相同，只要它们的值相同，也返回true，例如：97==’a’，返回true
?	!=：不等于，如果进行比较的两个操作数都是数值类型，只要值不同就返回true，如果比较的是引用类型，只有当两个引用变量相同类型的实例时才可以比较，只要两个引用指向不是同一个对象就返回true，
举例1：
Car car1 = new Car();
TestCar car2 = new TestCar();
	boolean result = (car1 ==car2); //两个类型不同不能进行比较

举例2：
Car car1 = new Car();
Car car2 = new Car();
boolean result1 = car1 !=car2;
boolean result2 = car1 ==car2;
	System.out.println(result1); //输出结果为true
	System.out.println(result2); //输出结果为false

	举例3：
		Car car1 = new Car();
		Car car2 = car1;
		boolean result = car1 ==car2;
		System.out.println(result); //输出结果为true
3.7.6 逻辑运算符
	逻辑运算符用于操作两个布尔型的变量或常量，逻辑返回的值为boolean类型，主要有6个，
?	&&：前后两个操作数都为true时，返回true，否则返回false，例如：32>24 && “abc”==”abc”，返回true
?	||：前后两个操作数，有个为true就返回true，举例：32>24 || “abc”!=”abc”，返回true
?	&（不短路与），|（不短路或），!（非），^（异或）
3.7.7 三目运算符
	三目运算符只有一个：（？：），举例：int a = 5>3 ? (12<22?11:23) : 7；
3.7.8 运算符的优先级 
运算符说明	Java运算符
分隔符	.   []  ()  ,   ;
单目运算符	++  --   ~  !
强制类型转换	(type)
乘除取模运算符	*   /   %
加减运算符	+  -
位移运算符	<<  >>  >>>
关系运算符	<  <=   >  >=
等价运算符	==   !=
按位与运算	&
按位异或运算	^
按位或运算	|
条件与运算	&&
条件或运算	||
三目运算符	? :
赋值运算符	=  +=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=

第4章：流程控制与数组
	任何一门编程语言都会提供两种基本的流程控制结构：分支结构和循环结构。其中分支结构根据条件来选择性地执行某段代码，循环结构则用于实现根据循环条件重复执行某段代码。
	Java中的分支结构语句为：if、switch
	Java中的循环结构语句为：while、do while、for、foreach
	Java中提供了break、continue来控制程序的循环结构
4.1 顺序结构
	顺序结构就是程序从上到下逐行的执行，中间没有任何判断和跳转。
	举例1：
	package com.langsin.test;
public class TestCar {
		public static void main(String[] args) {
			int a = 3;
			int b = 5;
			int c = a+b;
			System.out.println("输出结果："+c);
		}
}
4.2 分支结构
	Java语言使用if语句和switch语句来进行分支控制，其中if语句使用boolean表达式或boolean值来作为分支条件进行分支控制；switch语句则用于对多个整型值进行匹配，从而实现分支。
4.2.1 if条件语句
举例1：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		boolean flag = 5>3;
		//使用变量，此种方式为常用方式
		if(flag){
			System.out.println("条件为真执行");
		}
		//使用常量
		if(true){
			System.out.println("使用常量，此代码永远会被执行");
		}
		//使用表达式，此种方式为常见使用方式
		if(5>3){
			System.out.println("表达式的结果为true时，代码会被执行");
		}
		//完整的if分支结构
		int a = 5;
		int b = 8;
		if(a>b){
			System.out.println("a的值大于b的值");
		}else{
			System.out.println("a的值不大于b的值");
		}
		//分支的嵌套使用
		if(a>b){
			if(b>0){
				System.out.println("a的值大于b的值，并且b的值大于0");
			}
		}
		//此代码段等价于上面的代码
		if(a>b && b>0){
			System.out.println("a的值大于b的值，并且b的值大于0");
		}
		//完整结构下的嵌套
		if(a>b){
			if(b>0){
				System.out.println("a的值大于b的值，并且b的值大于0");
			}else{
				System.out.println("a的值大于b的值，但是b的值不大于0");
			}
		}else{
			if(a>0){
				System.out.println("a的值不大于b，并且a的值大于0");
			}else{
				System.out.println("a的值不大于b，并且a的值不大于0");
			}
		}
		//if语句串联使用
		if(a>b){
			System.out.println("a的值大于b的值");
		}else if(a>0){
			System.out.println("a的值不大于b的值，并且a的值大于0");
		}
	}
}
4.2.2 switch分支语句
	switch语句由一个控制表达式和多个case标签组成，表达式的数据类型只能是byte、short、int、char四个整数类型和枚举类型。
举例1：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		int a = 1;
		switch (a) {
			case 1:
				System.out.println("当key值为1时的运行代码段");
				int x = 2;
				int y = 3;
				int z = x + y;
				System.out.println("计算加法后的结果："+z);
				break;
				
			case 2:
				System.out.println("当key值为2时的运行代码段");
				int x1 = 2;
				int y1 = 3;
				int z1 = x1 - y1;
				System.out.println("计算减法后的结果："+z1);
				break;
				
			default:
				System.out.println("当key值不符合任意条件时，默认执行的代码段");
				break;
		}
	}
}
4.3 循环结构
	循环语句可以在满足循环条件的情况下，反复执行某一段代码，被重复执行的代码段称为循环体，在反复执行循环体的时候，需要在合适的情况下将条件改为假，否则循环将一直执行下去，形成可怕的死循环。
4.3.1 while循环语句
当while条件为真（true）时，执行循环体中的代码
举例1：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		int count = 1;
		while(count<10){
			System.out.println("当前值为："+count);
			count++;
		}
	}
}
4.3.2 do while 循环语句
do代码段中为循环体，先执行循环体中的代码，然后再去判断条件是否为真（true），如果为真再执行do代码段中的循环体。
举例2：
package com.langsin.test;
public class TestCar {
	public static void main(String[] args) {
		int count = 1;
		do {
			System.out.println("当前的数值为："+count);
			count++;
		} while (count<10);
	}
}

4.3.3 for循环
	For循环体是更加简洁的循环语句，在大部分情况下for循环可以代替while循环、do while循环。
举例1：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		System.out.println("--------------开始for循环------------");
		for(int i=0;i<10;i++){
			System.out.println("当前的数值为："+i);
		}
		System.out.println("---------------for循环结束---------------");
	}
}
4.3.4 foreach循环
	Foreach循环更加简洁，循环的必须是个集合或者数组。For表达式中定义的变量执行了数组或集合中的每一个具体的值。
举例：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		System.out.println("--------------开始for循环------------");
		int num[] = {11,20,33,40,55};
		for(int i : num){
			System.out.println("当前数值为："+i);
		}
		System.out.println("---------------for循环结束---------------");
	}
}
4.4 控制循环结构
	Java语言提供了continue语句和break语句来控制循环结构，除此之外还可以使用return语句来结束整个方法体。
4.4.1 break结束循环
	在代码体中，一旦执行到break语句，那么就结束整个循环，跳出循环体，不在执行，即使还没有执行完成也将不再执行。
举例1：
package com.langsin.test;
public class TestCar {
	public static void main(String[] args) {
		for(int i=0;i<10;i++){
			System.out.println("当前执行第"+(i+1)+"次");
			if(i==5){
				break;//当执行第6次的时候跳出循环体
			}
		}
		System.out.println("循环结束");
	}
}
4.4.2 continue结束本次循环
	与break有点类似，区别是终止后面代码的执行，跳出本次循环，继续执行下一次循环。
举例1：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		for(int i=0;i<5;i++){
			if(i==2){
				continue;
			}
			System.out.println("当前执行第"+(i+1)+"次");
		}
		System.out.println("循环结束");
	}
}
4.4.3 return结束方法
	return关键字，并不是专门用于结束循环体的，return的功能时结束一个方法。return关键字后面还可以跟变量、常量、表达式用于对方法的返回值。
举例1：
package com.langsin.test;

public class TestCar {
	public static void main(String[] args) {
		for(int i=0;i<5;i++){
			if(i==2){
				return;
			}
			System.out.println("当前执行第"+(i+1)+"次");
		}
		System.out.println("循环结束");
	}
}
举例2：
package com.langsin.test;
public class TestCar {
	public int getNum(int a,int b){
		return a+b;
	}
	public static void main(String[] args) {
		TestCar test = new TestCar();
		int result = test.getNum(5, 6);
		System.out.println("计算后的结果为："+result);
	}
}
4.5 数组类型
	数组是编程语言中最常见的一种数据结构，可以存储多个数据，每个数组元素存放一个数据，通过数组元素的索引（或者称为下标index）来访问数组元素。数组也是一种类型，它是引用类型。

4.5.1 定义数组
	Java语言支持两种语法格式来定义数组：
举例1：
int[] a;    int[] a; //int类型的数组，只能放int类型的值
int a[] = new int[5] ;
a[0] = 10;  //如果a[0] = 12.5f;则报错，因为12.5f是float类型的常量
System.out.println(a[0]);
基本数据类型、引用数据类型都可以定义数组，举例
bouble b[] ;  Car car[]; 
4.5.2 数组的初始化
举例1：只初始化数组的长度，不带有默认值
int[] a = new int[10];

举例2：初始化长度，同时带有默认值
int[] a = new int[]{11,12,13,14,15};
或者 int[] a = {11,12,13,14,15};
4.5.3 使用数组
	数组常用的方法就是访问数组元素，包括对数组元素进行赋值、取出数组元素的值。访问数组元素都是通过在数组引用变量后紧跟一个方括号[]，方括号中是数组元素的索引值，索引值都是从0开始的。一个数组的索引值最大等于这个数组的长度减1。

	举例1：int a[] = new int[10]，这个int类型的数组长度为10，那么取第10个数就是a[9]，如果编写代码的时候写成了a[10]，编译不会出错，但是在运行时会出现异常：java.lang.ArrayIndexOutOfBoundsException:异常，这个就是数组索引越界异常。

	举例2：
package com.langsin.test;

public class TestCar {
		public static void main(String[] args) {
			int num[] = {11,22,33,44,55} ;
			for(int i=0;i<num.length;i++){
				System.out.println("当前数值中的第"+(i+1)+"元素的值为"+num[i]);
			}
		}
}

输出结果为：当前数值中的第1元素的值为11
当前数值中的第2元素的值为22
当前数值中的第3元素的值为33
当前数值中的第4元素的值为44
当前数值中的第5元素的值为55

举例3：使用foreach进行遍历
	public static void main(String[] args) {
		int num[] = {11,22,33,44,55} ;
		int i=1;
		for(int n : num){
			System.out.println("当前数值中的第"+i+"元素的值为"+n);
			i++;
		}
	}
4.6 深入数组
	数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。
4.6.1 内存中的数组
	数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当引用指向有效内存后，才可通过该数组变量来访问数组元素。

	举例1：int[] a = {1,3,5,4} a[0]的值为1， int[] a = null; a[0]则报错。

	数组对象被存储在堆内存中（heap），而引用该数组对象的数组引用变量如上例中的a变量，则被存储在栈内存中（stack）。如下图：
 

当一个方法执行时，每个方法都会建立自己的栈内存，这个方法中定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也就会自然销毁，因此所有在方法中定义的局部变量都是放在栈内存中的，当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用，这是因为对象的创建成本通常是比较大的，这个运行时数据区就是堆内存。堆内存中的对象不会随着方法的结束而销毁，即使方法结束后，这个对象可能被另一个变量引用，则这个对象依然会存在。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制（GC）才会在合适的时候回收它，即销毁它。

	为了让垃圾回收机制回收一个数组所占的内存空间，可以将该数组变量赋值为null，也就切断了数组引用变量和实际数组之间的引用关系，实际的数组也就成了垃圾信息。

举例2：
int a[] = {1,5,6,8,10,12}; 
System.out.println(a[0]);
int b[] = a;
a = null;//切断引用数据类型变量a与数组之间的联系，但是变量b又指向了这个数组对象，所以该数组对象不会被GC回收，仍然在堆内存中存在。
b = null; //同上切断变量b与数组之间的联系，没有变量指向这个数组，因此GC会在合适的时候将对象回收销毁。

举例3：
public static void main(String[] args) {
		int a[] = {1,12,13,22};
		int b[] = new int[5];
		System.out.println("数组b的长度为："+b.length);
		for(int i=0;i<a.length;i++){
			b[i] = a[i];
		}
		for(int num : b){
			System.out.print("  "+num);
		}
		b = a;
		System.out.println("数组b的长度为："+b.length);
	}
举例4：定义一个引用数据类型数组
package com.langsin.test;

public class Person {
	Person(String name,String phone,int age){
		this.name = name;
		this.phone = phone;
		this.age = age;
	}
	private String name;
	private String phone;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public static void main(String[] args) {
		Person p[] = new Person[5];
		for(int i=0;i<p.length;i++){
			Person person = new Person("zhangsan"+i,"859949"+i,25+i);
			p[i] = person;
		}
		for(int i=0;i<p.length;i++){
			System.out.print("  姓名："+p[i].getName());
			System.out.print("  年龄："+p[i].getAge());
			System.out.println("  电话："+p[i].getPhone());
			System.out.println("--------------------------------------------------------");
		}
	}
}

基本数据类型数组与引用数据类型数组的差别：基本数据类型数组在初始化时，在堆内存中的数组对象里面已经初始化好数据值并且进行存放。引用数据类型的数组在初始化时，在堆内存中的数组对象上实际存放的是引用数据类型的引用变量。
4.6.2 多维数组
	Java语言中提供了支持多维数组的语法。多维数组在本质上是由一维数组组合而成，只是外层的数组中存放的是内存数组的引用变量而已。
	多维数组的初始化同一维数组相同。
	举例1：
	public static void main(String[] args) {
		int num[][] = {{1,3,5},{2,4,6,9}};
		//num是二维数组，num的长度是最外层数组的长度，它存放的值为里面一层数组的引用地址
		System.out.println(num.length);
		int num2[][] = new int[5][6];
		//给数组num里面的第一个数组对象的第一个对象值赋值
		num2[0][0] = 1;
		//给数组num里面的第一个数组对象的第二个对象赋值
		num2[0][1] = 3;
	}

	如下图所示：
 
4.6.3 操作数组的工具类
java.util.Arrays类，包含了一些用static修饰的方法可以直接操作数组，常用的方法如下：
?	int binarySearch(type[] a,type value)：使用二分法查询value元素值在a数组中出现的索引位置，如果a数组不包含value元素值，则返回负数。该方法要求数组已经按照升序进行了排列。
?	int binarySearch(type[] a,int fromeIndex,int toIndex,type value)：与上一个方法名相同，参数不同，称为方法重载，同样要求数组已经按照升序进行了排列。
举例1：
	public static void main(String[] args) {
		int[] a = {1,3,4,6,7,2,8};
		int index = Arrays.binarySearch(a,10); //输出-8
		System.out.println(index);
		index =  Arrays.binarySearch(a,2);
		System.out.println(index); //输出-2
		index =  Arrays.binarySearch(a,3);
		System.out.println(index); //输出1
index = Arrays.binarySearch(a,1,6,3);
		System.out.println(index);  //输出1
		index = Arrays.binarySearch(a,1,6,1);
		System.out.println(index); //输出负数
		}

?	type[] copyOf(type[] original,int newLength)：这个方法会把original数组复制成一个新数组，其中newLength是新数组的长度，当newLength大于original的长度时，新数组的前面元素就是original的所有元素，后面所有元素进行补充，0（int类型），false（boolean类型）、null（引用类型）。
?	type[] copyOfRange(type[] original,int fromIndex,int toIndex)：这个方法只复制original数值的from索引到to索引的元素。
举例2：
	public static void main(String[] args) {
		int[] a = {1,3,4,6,7,2,8};
		int[] b = Arrays.copyOf(a,5);
		System.out.println(b[1]); //输出：3
		b = Arrays.copyOfRange(a, 2, 5);
		System.out.println(b.length+"===="+b[2]);  //输出: 3====7
		}
?	boolean equals(type[] a1,type[] a2)：如果数组a1与数组a2的长度相同，并且数值a1中元素值与a2中元素值相同，该方法返回true。

举例3：
	public static void main(String[] args) {
		int[] a = {1,3,4,6,7,2,8};
		int[] b = {1,3,4,6,7,2,8};
		System.out.println(Arrays.equals(a, b)); //输出true
	}
?	void fill(type[] a,type val)：该方法对数组进行赋值，将所有元素赋值为val
?	void fill(type[] a,int fromIndex,int toIndex,type val)：该方法仅仅对从fromIndex开始到toIndex索引的的元素进行赋值，赋值为val
举例4：
	public static void main(String[] args) {
		int[] a = new int[5];
		Arrays.fill(a, 12);
		System.out.println(a[1]);
		int[] b = new int[5];
		Arrays.fill(b,1,b.length,13);
		System.out.println(b[0]);
		System.out.println(b[4]);
		}
?	void sort(type[] a)：该方法对数组a中的元素进行排序。
?	void sort(type[] a,int fromIndex,int toIndex)：对数组a中的从fromIndex开始到toIndex的元素进行排序。
?	String toString(type[] a)：该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起，多个数组元素使用英文逗号和空格隔开。
举例5：
	public static void main(String[] args) {
		int a[] = {1,6,3,7,2,8,9,10};
		Arrays.sort(a);
		System.out.println(Arrays.toString(a)); //输出 [1, 2, 3, 6, 7, 8, 9, 10]
		}	

4.7 数组的应用
1、	将字符串形式的浮点数“1245”转换成大写格式 壹仟贰佰肆拾伍
提示：从字符串中取出每个位置的值的方法：
char c = String.charAt(index);
获取字符串的长度为的方法：
Int length = String.length(); 

第5章：面向对象(上)
	JAVA是面向对象的程序设计语言，Java语言提供了定义类（class）、属性（Field）、方法（method）等最基本的功能。类是一个自定义类型的数据类型。所有使用类定义的变量都是引用变量，变量都指向一个具体的类的对象。
	面向对象的三大特征：封装、继承、多态。Java提供了private、protected、public三种访问控制修饰符来实现良好的封装，提供了extends关键字来实现继承关系。子类继承父类就可以继承父类的属性和方法。如果访问控制允许，子类实例就可以直接调用父类里定义的方法。继承是实现类复用的重要手段。

	构造器也称构造方法用于对类实例进行初始化，构造器支持重载，其实也就是构造方法的重载。

作用域	当前类	当前包	子孙类	其他包
public	√	√	√	√
protected	√	√	√	X
private	√	X	X	X
默认(default)	√	√	当前包下继承可以	X


5.1 类和对象
	Java是面向对象的程序设计语言，类是面向对象的重要内容，可以把类当成一种自定义的数据类型，可以使用类来定义变量，这种类型的变量统称为引用变量，所有的类是引用数据类型。
5.1.1 定义类
	面向对象的程序设计过程中有两个重要概念：类（class）和对象（object），其中类是某一批对象的抽象，可以把类理解成某种概念。

一、Java语言里定义类的语法格式：
	[修饰符]  class 类名{
		0到多个构造方法
		0到多个变量
		0到多个方法
}
修饰类的关键字可以是public(公共的)、final（最终的）、abstract（抽象的），或者完全省略这三个修饰符。类名是一个合法的标识符即可。但这仅仅是符合Java的语法要求，实际上从程序的可读性来说，Java的类名必须是由一个或多个有意义的单词连接而成，每个单词首字母大写，其他字母全部小写，单词与单词之间不要使用任何分隔符，例如： public class ProductService{}，从类名上就能看出这是一个为产品操作提供服务的类。

	对于一个类定义而言，可以包含三种最常见的成员，也称为类成员，构造器、变量、方法，三种成员都可以定义0到多个。

	类里面，各成员之间的定义顺序没有任何影响，各成员之间可以相互调用，但是用static修饰的成员只能访问static修饰的成员。

	举例1：
	package com.langsin.test;

public class Student {
		private String gender = "";
		static String name = "";  
		public static void main(String[] args) {
			name = "zhangsan";
			gender = "man";  
		}
}

二、Filed（变量）用于定义该类或该类的实例对象所包含的状态数据，方法则用于定义该类或该类实例的行为特征或者功能实现。构造器（构造方法）用于该类的实例对象的初始化，Java语言使用new关键字来调用构造器（构造方法）从而返回这个类的实例。构造器是一个类创建对象的根本，如果一个类没有构造器，那么Java就会为该类提供一个默认的构造器。
	
举例2：
public class Student{
	private String name = null;
	private int age = 0;
	private String gender = null;
	Student(String name,int age,String gender){
		this.name = name;
		this.age = age;
		this.gender = gender;
}
public void introduce(){
	System.out.println(“My name is ”+this.name+”, age is ”+this.age);
}
}
	
Student st1 = new Student(“zhangsan”,25,”男”);
st1.introduce();
Student st2 = new Student(“lili”,25,”女”);
St2.introduce();

定义类变量（Field）语法格式如下：
1、修饰符可以省略，也可以是public、protected、private、static、final，其中public、protected、private三个只能出现其中一个，可以与static、final组合起来修饰field
2、变量类型：可以是Java语言中的任何数据类型：基本数据类型、引用数据类型。
3、Field名只要是一个合法的Java标识符即可，这是从语法角度来说，如果从程序可读性来说应该是每个单词首字母小写，后面每个单词首字母大写，与类名定义相似。

举例3：public static String name = “abc”;
	    private static age = “23”;  
		private final String classNo = “20130607”;

三、定义类、方法（method）语法格式如下：
1、修饰符：修饰符可以省略，也可以是public、protected、private、static、final、abstract，其中public、protected、private、三个只能出现一个，abstract和final最多只能出现其中之一，可以与static组合起来。
2、方法返回值类型：返回值类型是Java语言允许的任何类型，即：基本类型，引用类型。如果有返回类型，必须有一个有效的return语句，该语句返回一个变量或一个表达式。这个变量或表达式的类型必须与此方法声明的类型一致。
3、方法名：方法名命名规则与Field命名规则基本相同
4、形参列表：形参列表用于定义方法可以接受的参数，形参类型和形参名之间用英文空格隔开。

举例4：:
public int getTotalValue(int a,int b){
	int totalNum = a + b;
	return totalNum;
} 

static是一个特殊的关键字，它可以用于修饰方法，变量（Field）等成员，static修饰的成员表明它属于这个类本身，而不是该类的单个实例，通常把static修饰的变量（Field）和方法（method）称为类变量，类方法。不使用static修饰的普通方法、变量则属于该类的单个实例。
举例5：
public class Student {
	private  String sex = "";
	private static String name = "";
	public static void main(String[] args) {
		name = "zhangsan";
		System.out.println(name);
		Student st = new Student();
		st.name = "lisi";
		System.out.println(st.name); //实例的名称
		System.out.println(name); //类的名称
		st.sex = "男";
		System.out.println(st.sex);
	}
}
四、构造器（构造方法）是一个特殊的方法，定义构造器的语法样式与定义方法的语法格式很像，定义构造器的语法格式如下：
[修饰符]  构造器名（形参列表）{
	//0到多个可执行语句组成的构造器执行体
}
?	修饰符：可以省略，也可以是public、protected、private其中之一。
?	构造器名：必须和类名一样。
?	形参列表：和定义方法形参列表格式完全相同。
注意：构造器既不能定义返回值类型，也不能使用void定义构造器没有返回值。这是Java规范定义的，实际上类的构造器是有返回值的，当使用new关键字来调用构造器时，构造器返回该类的的实例。

举例6：
package com.langsin.test;
public class Student {
	private int age = 29;
	private String name = new String();
	private void say(){
		System.out.println("仅供自身调用");
	}
	public static void main(String[] args) {
		Student st = new Student();
		st.say();
	}
}
5.1.2 对象、引用和指针
	如上例所示：在创建Student对象时，实际创建了两个东西，一个是栈内存中的变量st，存储的是类Student对象的地址值。一个是堆内存（数据区域）中的Student对象本身。在堆内存中的对象本身中，自身的属性变量（Field）并不是存放在栈内存中的，同样也是存放在堆内存中的。对于基本数据类型的变量（Filed）来说，变量存放的是具体的值，对于引用数据类型的变量（Field）来说，存放的同样是该类型指向的具体类型的地址值。引用变量都是指向堆内存里的对象。引用变量与C语言里的指针很像，都是存储一个地址值。
 
5.1.3 对象的this引用
	Java提供了一个this关键字，this关键字总是指向调用该方法的对象。根据this出现位置的不同，this作为对象的默认引用有两种情况：
1、	构造器中引用，this指的是该构造器正在初始化的对象。
2、	在方法中引用，this指的是调用该方法的对象。
this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或Field。

举例1：
package com.langsin.test;

public class Student {
	Student(){
		gender = "男";
	}
	private String gender = "";
	private static String name = "";
	public void standUp(){
		this.say();
	}
	private void say(){
		System.out.println("仅供自身调用");
	}
	public static void main(String[] args) {
		Student st = new Student();
		st.standUp();
	}
}
注意：在默认情况下，因为调用关系都是对象本身的方法或者Field，所以this可以省略。
5.2 Java中的方法
	方法是类或者对象的行为特征抽象，方法是类或者对象最重要的组成部分。Java中的方法不能独立存在，所有的方法要么属于类，要么属于对象。
5.2.1 方法的所属性
	在Java语言中，方法不能独立存在，方法必须属于类或者对象。因此如果定义方法，那么方法只能定义在类体内，不能独立定义一个方法。如果方法使用static修饰，那么这个方法属于这个类，否则这个方法属于这个类的实例。因此方法的执行者要么是类或者类的实例对象。
5.2.2 方法的参数传递机制	
	在方法声明时如果包含了形参声明，则调用方法时必须给这些形参指定参数值，调用方法时实际传递给形参的参数值也被称为实参。Java里方法的参数传递方式只有一种：值传递。所谓的值传递就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受任何影响。
举例1：
package com.langsin.test;

public class Test {
	public void getSum(int a,int b){
		a = a+b;
		System.out.println("参数a的值改变为："+a); // 10
	}
	public static void main(String[] args) {
		int a = 5;
		int b = 5;
		Test test = new Test();
		test.getSum(a, b);
		System.out.println(a); // 5
	}
}
基本数据类型为参数时的传递，引用数据类型为参数时的传递，传递的同样是实际值的副本，但要注意的是引用数据类型的值存放的是地址值，即指向实际对象的那个地址值。所以调用方法时将地址值传递给了方法，方法操作时根据地址值找到了具体的对象，将具体对象的信息发生了变化。
举例2：
Student类：
package com.langsin.test;
public class Student {
	protected String name = "zhangsan";
}
Test类：
package com.langsin.test;
public class Test {
	private static void changeValue(Student st){
		st.name = "李四";
	}
	public static void main(String[] args) {
		Student st = new Student();
		System.out.println(st.name); //zhangsan
		Test.changeValue(st);
		System.out.println(st.name); //李四
	}
}
5.2.3 递归方法
	一个方法体内调用它自身，被称为方法递归。方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制。

例如1：计算1+2+3+4+…..+100的和为多少？
public class Test {
	public static int getSum(int num){
		if(num>1){
			return num+getSum(num-1);
		}else{
			return num;
		}
	}
	public static void main(String[] args) {
		int total = Test.getSum(100);
		System.out.println(total);
	}
}
练习：已知有一个数列，f(0)=1，f(1)=4，f(2) =2*f(1)+f(0)，f(3)=2*f(2)+f(1)，f(n) = 2*f(n-1)+f(n-2)

其中n是大于等于0的整数，求f(10)的值。
5.2.4 方法重载
	Java允许同一个类里定义多个同名方法，只要形式参数列表不同就行。如果同一个类中包含了两个或两个以上方法的方法名相同，但形参不同，则被称为方法重载。至于方法的其他部分，如方法返回值类型、修饰符等与方法重载没有任何关系。

	举例1：
public class Test {
		public void printMsg(){
			System.out.println("输出打印信息");
		} 
		public String printMsg(String msg){
			System.out.println("输出打印信息："+msg);
			return msg;
		}
		public static void main(String[] args) {
			Test test = new Test();
			test.printMsg();
			test.printMsg("你好");
		}
}
5.3 成员变量和局部变量
	在Java语言中，根据定义变量位置的不同，可以将变量分成两大类：成员变量和局部变量。成员变量和局部变量的运行机制存在较大差异。
5.3.1 成员变量和局部变量
	成员变量指的是在类范围里定义的变量，也就是介绍的Field；局部变量指的是在方法里定义的变量。成员变量又分为类变量与实例变量。其中使用static修饰的就是类变量，可以通过类直接访问，没有用static修饰的是实例变量。类变量从这个类的准备阶段开始就存在，直到系统完全销毁这个类。实例变量从该类的实例被创建时开始存在，直到系统销毁这个类的实例。

举例1：
package com.langsin.test;

public class Test {
	public static String name = "zhangsan";  //类变量
	public String age = "25"; //实例变量
	public static void main(String[] args) {
		Test test = new Test();
		test.age = "36";  
		test.name = "张三";
		System.out.println(test.age);  
		System.out.println(test.name);
		Test test1 = new Test();
		System.out.println(test1.age);
		System.out.println(test1.name);
	}
}
注意：实例Field随着实例的存在而存在，而类Field则随着类的存在而存在。实例也可以访问类Field，同一个类的所有实例访问类Field时，实际上访问的是该类本身的同一个Field。

局部变量的分类：
1、	形参：在定义方法名时定义的变量，形参的作用域在整个方法内有效。
2、	方法局部变量：在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效。
3、	代码块局部变量：由代码块中定义的局部变量，这个局部变量的作用域从定义该变量的地方生效，到该代码块结束时失效。

举例2：
	public void getSum(int a,int b){     //a，b为形参局部变量
		 int num = a+b;              // num为方法局部变量
		 for(int i=0;i<5;i++){          // i 为代码块局部变量，for循环结束时，i失效
			 num = num + i;
		 }
		 System.out.println(num);
	}

在Java中，成员变量的作用域是整个类内有效，一个类里不能定义两个同名的成员变量，一个方法里不能定义两个相同的局部变量，但是Java允许局部变量和成员变量同名，如果方法里的局部变量跟成员变量同名，那么在一个方法内使用成员变量时，需要使用this关键字。

举例3：
public class Test {
	public String name = "zhangsan";
	public void printName(String name){
		String result = this.name + name;
		System.out.println(result);
	}
	public void printName(){
		System.out.println(this.name);
	}
	public static void main(String[] args) {
		Test test = new Test();
		test.printName("是张三");
		test.printName();
	}
}
5.3.2 变量的使用规则
	在Java中定义变量时，需要根据不同情况来定义变量的范围。
?	如果变量是用来描述类或者对象的固有信息，比如一些固定不变的值的信息，需要将变量定义成类变量。
?	如果在某个类中需要定义一个变量来保存该类或者实例运行时的状态信息。或者变量需要在整个类范围内有效，则定义成成员变量。
?	如果只需要在方法中运行，则变量需要定义成局部变量。
在程序中，应该尽可能地缩小局部变量的作用范围，局部变量的作用范围越小，在内存中停留的时间越短，程序运行性能就越好。

	举例1：
public class Test {
	public static int RUN_SUCCESS = 0;
	public static int RUN_FAILURE = 1;
	public int runStatus(int a){
		if(a>0){
			return Test.RUN_SUCCESS;
		}else{
			return Test.RUN_FAILURE;
		}
	}
	public static void main(String[] args) {
		Test test = new Test();
		int result = test.runStatus(10);
		if(result==Test.RUN_SUCCESS){
			System.out.println("程序运行正常");
		}else{
			System.out.println("程序运行失败");
		}
	}
}

5.4 隐藏与封装
	在程序中经常出现通过某个对象的直接访问其Field的情况，这会存在一系列的问题，比如定义一个Person的对象，其中有age这样一个属性，如果将属性值赋值为1000，虽然程序不会出错，但是逻辑是错误的，人不可能活1000岁，因此通常将成员变量定义使用private关键字进行修饰，然后通过方法的方式向外提供服务
举例1：
package com.langsin.test;
public class Test {	
	private int age = 0;
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		if(age>100){
			this.age = 100;
		}else{
			this.age = age;
		}
	}
	public static void main(String[] args) {
		Test test = new Test();
		test.setAge(125);
		System.out.println(test.getAge());
	}
}

5.4.1 理解封装
	封装是面向对象的三大特征之一，它指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。
	封装可以实现以下目的：
1、	隐藏类的实现细节
2、	使用者只能通过提供的方法来访问数据，从而可以在方法中加入控制逻辑，限制对变量的不合理的访问。
3、	可进行数据检查，从而有利于保证对象信息的完整性。
4、	便于修改，提高代码的可维护性。
封装的实际含义就是该隐藏的隐藏，该暴漏的暴漏。
5.4.2 package、import
	Oracle公司提供的JDK、各种软件厂商、众多的开发商，会提供成千上万、具有各种用途的类，那么类名肯定会出现同名的这种情况，为了处理重名问题，Java引入了包（package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理问题。

	Java源文件中使用了pageckage语句，就意味着该源文件里定义的所有类属于这个包下。位于包中的每个类的完整类名都应该是包名和类名的组合。

	举例1：
public class Test {
		public static void main(String[] args) {
			com.langsin.vo.Page page1 = new com.langsin.vo.Page();
		}
}
	为了简化编程，Java引入了import关键字，import可以向某个Java文件中导入指定包层次下的某个类或全部类，import语句出现在package语句之后，类定义之前。
举例2：
	package com.langsin.test;
import com.langsin.vo.Page;
public class Test {
		public static void main(String[] args) {
			Page page = new Page();
			System.out.println(page.getLineNum());
		}
}
	Import语句可以简化编程，可以导入包下某个类或者全部类，导入全部类的方式用*表示，
举例3:
import com.langsin.vo.*;
表示导入com.langsin.vo包下的所有类。
5.4.3 Java的常用包
	Java的核心类都放在java这个包以及其子包下，Java扩展的许多类都放在javax包以及其子包下，这些实用类也就是前面所说的API。
?	java.lang：这个包下包含了Java语言的核心类，如String、Math、System、和Thread类等，使用这个包下的类无须使用import语句导入，系统会自动导入这个包下的所有类。
?	java.util：这个包下包含了Java的大量工具类/接口和集合框架类/接口，例如Arrays和List、Set等。
?	java.net：这个包下包含了一些Java网络编程相关的类和接口。
?	java.io：这个包下包含了一些Java输入/输出编程相关的类和接口。
?	java.text：这个包下包含了一些Java格式化相关的类。
?	java.sql：这个包下包含了Java进行JDBC数据库编程的相关类和接口。
?	java.awt：这个包下包含了抽象窗口工具集的相关类和接口，这些类主要用于构建图形用户界面（GUI）程序。
?	java.swing：这个包下包含了Swing图形用户界面编程的相关类和接口，这些类可用于构建平台无关的GUI程序。
5.5 深入构造器
	构造器是一个特殊的方法，这个特殊方法用于创建实例时执行初始化。构造器是创建对象的重要途径，因此Java类必须包含一个或一个以上的构造器。
5.5.1 使用构造器进行初始化
	构造器最大的用处就是在创建对象时执行初始化，所谓的初始化就是创建对象时，系统对这个对象的Field进行赋值处理。
举例1：
package com.langsin.test;
public class Person {
	private String name = null;
	private int age = 0;
	Person(String name,int age){
		this.name = name;
		this.age = age;
	}
	public String getName(){
		return this.name;
	}
	public void setName(String name){
		this.name = name;
	}
	public int getAge(){
		return this.age;
	}
	public void setAge(int age){
		this.age = age;
	}
	public static void main(String[] args) {
		Person p1 = new Person("张三",35);
		System.out.println(p1.getName());
		System.out.println(p1.getAge());
	}
}
注意：如果程序员提供了自定义的构造器，系统就不再提供默认的构造器，因此上例中Person类中提供了构造器因此不能再通过new Person()代码来创建实例，因为该类不再包含无参数的构造器。
5.5.2 构造器重载
	同一个类里具有多个构造器，多个构造器的形参列表不同，即被称为构造器重载。构造器重载允许Java类里包含多个初始化逻辑，从而允许使用不同的构造器来初始化java对象。
举例1：
package com.langsin.test;
public class Test {
	private String name = null;
	private int age = 0;
	Test(String name,int age){
		this.name = name;
		this.age = age;
	}
	Test(){
		
	}
	public String getName(){
		return this.name;
	}
	public void setName(String name){
		this.name = name;
	}
	public int getAge(){
		return this.age;
	}
	public void setAge(int age){
		this.age = age;
	}
	public static void main(String[] args) {
		Test test = new Test("张三",35);
		System.out.println(test.getName());
		Test test1 = new Test();
		System.out.println(test1.getName());
	}
}
5.6 类的继承
	继承是面向对象的又一大特征，也是实现软件复用的重要手段。Java的继承具有单继承的特点，每个子类只有一个直接父类。
5.6.1 继承的特点
	Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类被称为父类（或者称为基类、超类）。父类和子类的关系是一种一般和特殊的关系。子类扩展了父类，将可以获得父类全部的Filed成员变量和方法。
	因为子类是一种特殊的父类，因此父类包含的范围总比子类包含的范围要大，所以可以认为父类是大类，而子类是小类。

	Java类只能有一个直接的父类，但是Java类可以有无限多个间接父类。例如：
public  class  HighGradeCar  extends  Car{} 
	public  class  BmwCar  extends  HighGradeCar{}
	BmwCar类有两个父类，一个是Car，一个是HighGradeCar。
	如果定义一个Java类时并未显示指定这个类的直接父类，则这个类默认扩展java.lang.Object类，因此java.lang.Object类是所有类的父类，要么是其直接父类，要么是其间接父类。
5.6.2 重写父类的方法 
	子类扩展了父类，子类是一个特殊的父类。大部分情况下子类总是以父类为基础，额外增加新的Field和方法，但是有一种特殊的情况例外：子类需要重写父类的方法。
举例1：父类Bird类
package com.langsin.test;
public class Bird {
	public void fly(){
		System.out.println("可以在天空中飞翔....");
	}
}

package com.langsin.test;
public class Ostrich extends Bird {
	@Override
	public void fly() {
		System.out.println("只能在地上跑......");
	}
	public static void main(String[] args) {
		Ostrich os = new Ostrich();
		os.fly();
	}
}
程序执行时，不再执行父类Bird中fly()方法，而是执行了自身的fly()方法，这种子类包含与父类同名方法的现象称为重写，也称为方法覆盖(Override)。方法的重写要遵循如下规则：
1、	方法名相同、形参列表相同
2、	子类方法返回值类型应比父类方法返回值类型相等或者更小
3、	子类方法声明抛出的异常类应该比父类方法更小或相等。

当子类覆盖了父类方法后，子类对象将无法访问父类中被覆盖的方法，但可以在子类方法中调用父类中被覆盖的方法，需要使用super关键字。如果父类方法具有private访问权限，则该方法对其子类是隐藏的，也就无法重写该方法。如果子类中定义了一个与父类private方法相同的方法名、相同形参列表、相同返回值类型的方法，依然不是重写，只是在子类中定义了一个新的方法而已。
举例2：
package com.langsin.test;
public class Bird {
	public void fly(){
		System.out.println("可以在天空中飞翔....");
	}
	private void getFood(){
		System.out.println("得到小虫子");
	}
}

package com.langsin.test;
public class Ostrich extends Bird {
	@Override
	public void fly() {
		super.fly();
		System.out.println("只能在地上跑......");
	}
	public static void main(String[] args) {
		Ostrich os = new Ostrich();
		os.fly();
	}
}
父类中定义的fly方法，使用super可以调用到，但是getFood()方法缺无法调用到，因为此方法是私有方法，只有父类本是可调用。使用super关键字调用fly()方法，就可以执行父类中被重写的方法。

5.6.3 super限定
	super是Java提供的关键字，super用于限定该对象调用从父类继承得到的Field成员变量或方法。如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的Field，而不是该类自己定义的Field。
	在子类进行实例化时，会首先调用父类的构造方法，对父类中的Field成员变量或者方法进行初始化，但不会创建父类对象。

举例1：
package com.langsin.test;
public class Bird {
	Bird(){
		System.out.println("=========");
	}
	private String name = "";
	public void setName(String name){
		this.name = name;
	}
	public String getName(){
		return this.name;
	}
	public void fly(){
		System.out.println("可以在天空中飞翔....");
	}
}
子类：
package com.langsin.test;

public class Ostrich extends Bird {
	Ostrich(){
		super.setName("小鸟");
	}
	private String name = "鸵鸟";
	public String getName(){
		return this.name;
	}
	@Override
	public void fly() {
		System.out.println("只能在地上跑");
		System.out.println(super.getName());
		System.out.println(this.getName());
	}
	public static void main(String[] args) {
		Ostrich os = new Ostrich();
		os.fly();
	}
}
5.6.4 调用父类构造器
	子类继承父类，子类在实例化时会首先调用父类的构造方法，对父类成员进行初始化。如果父类的构造方法是隐式的，那么Java会帮我们进行自动调用。而如果父类的构造方法是显式的，那么子类就必须声明一个显示的构造方法，同时在构造器中显示的调用父类的构造器。
举例1：
package com.langsin.test;
public class Bird {
	Bird(String name){
		System.out.println("=========");
	}
}

package com.langsin.test;
public class Ostrich extends Bird {
	Ostrich() {
		super("小鸟");
	}
}
5.7 多态
	Java引用变量有两个类型，一个是编译时类型，一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现多态。所谓的多态就是同样一个东西表现出多种不同方式。
5.7.1 多态性
	Java中的多态性也是由Java面向对象中继承特征导致的。因为子类是一种特殊的父类，因此Java允许把一个子类对象直接赋值给父类引用变量，无须任何类型转换。或者称为向上转型，向上转型由系统自动完成。如果子类重写了父类的方法，那么使用父类引用变量指向不同的子类时，调用方法相同，但表现形式有所不同，这种现象就成为多态。

举例1：
	package com.langsin.test;
public class BmwCar extends Car {
		public void run() {
			System.out.println("我是宝马车。。。。");
		}
}
=======================================================
package com.langsin.test;
public class BenzCar extends Car {
	public void run() {
		System.out.println("我是兰博基尼车。。。。");
	}
}
========================================================
package com.langsin.test;

public class Car {
	public void run(){
		System.out.println("我是所有车的父类......");
	}
	public static void main(String args[]){
		//编译时类型与运行时类型完全一致，所以不存在多态
		Car car = new Car();
		car.run();
		//编译时类型与运行时类型不一致，所以存在多态
		car = new BmwCar();
		car.run();
		//编译时类型与运行时类型不一致，所以存在多态
		car = new BenzCar();
		car.run();
	}
}
5.7.2 引用变量的强制类型转换
编写Java程序时，引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法，即使它实际引用的对象确实包含该方法，也无法引用到。如果需要让这个引用变量调用它运行时类型的方法，则必须把它强制转换成运行时类型，强制类型转换需要借助于类型转换运算符。
举例1：
package com.langsin.test;
public class BmwCar extends Car {
	public void run() {
		System.out.println("我是宝马车。。。。");
	}
	public void description(){
		System.out.println("高端、大气、上档次");
	}
}

package com.langsin.test;
public class Car {
	public void run(){
		System.out.println("我是所有车的父类......");
	}
	public static void main(String args[]){
		Car car = new BmwCar();
		car.run(); //调用本身类所定义的方法
		((BmwCar)car).description(); //进行强制转换后调用子类对象中的方法
	}
}
强制类型转换不是万能的，当进行强制类型转换时需要注意：
1、	基本类型之间的转换只能在数值类型之间进行，数值类型包括整数型、字符型和浮点型。但数值类型和布尔类型之间不能进行类型转换。
2、	引用类型之间的转换只能具有继承关系的两个类之间进行，如果两个没有任何继承关系的类型，则无法进行类型转换。如果将一个父类类型转换成子类类型，那么这个父类类型指向的实例必须是子类类型的实例才行，否则在运行时会引发类型转换异常（ClassCastException）。

举例1：
package com.langsin.test;
public class Test {
	public static void main(String[] args) {
		double d = 13.4;
		long li = (long)d;
		int a = 4;
		boolean b = (boolean)a;
		Object obj = "Hello World";
		String str = (String)obj;
		obj = new Integer(5);
		str = (String)obj;
	}
}
5.7.3 instanceof运算符
	instanceof运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是接口，接口也是类，是一种特殊的类），它用于判断前面引用变量所指向的具体对象是否是后面这个类，或者后面这个类的子类或者后面这个类的实现类的一个实例对象。是则返回ture，否则返回false。
举例1：
package com.langsin.test;
public class Test {
	public static void main(String[] args) {
		Object obj = "hello";

		System.out.println(obj instanceof Object);
		//
		System.out.println(obj instanceof String);
		//
		System.out.println(obj instanceof Math);
		String a = "hello";
		//
		System.out.println(a instanceof Math);
	}
}

5.8 继承与组合
	继承是实现类重用的重要手段，但是继承带来了一个最大的坏处：破坏封装。相比之下，组合也是实现类重用的重要方式，而采用组合方式来实现类重用并能提供更好的封装。下面详细介绍继承和组合之间的联系与区别。
5.8.1 使用继承的注意点
	子类继承父类时，子类可以从父类继承得到Filed和方法。如果访问权限允许，子类可以直接访问父类的Field和方法，相当于子类可以直接复用父类的Field和方法。继承带来了高度复用的同时，也带来了一个严重的问题：那就是继承严重破坏了父类的封装性。封装：每个类都不可以随意访问其父类的Field和方法，父类而只需要暴漏必要的方法给其他类使用。但是在继承关系中，子类可以直接访问父类的Field和方法，从而造成子类与父类的严重耦合。
	父类的实现细节对于子类来说不再透明，子类可以访问父类的Field和方法，并可以改变父类的方法的实现细节，从而导致子类可以任意的篡改父类的方法和属性（Field）
	举例1：
package com.langsin.test;
public class Bird {
		public String name = "小鸟";
		public void fly(){
			System.out.println(this.name+"可以在天空中自由飞翔。。。");
		}
}
	篡改属性：
	package com.langsin.test;
public class Ostrich extends Bird {
		this.name = "大象"; //任意篡改了父类的属性信息
		public static void main(String[] args) {
			Ostrich os = new Ostrich();
			os.fly();
		}
}
	篡改方法：
package com.langsin.test;
public class Ostrich extends Bird {
		//任意篡改方法
		public void fly(){
			System.out.println(this.name+"在水中游来游去。。。");
		}
		public static void main(String[] args) {
			Ostrich os = new Ostrich();
			os. fly();
		}
}
对于此种问题，基于保证父类有良好的封装，不会被子类随意改变，设计父类时通常遵循如下规则。
1、	尽量隐藏父类的内部数据，尽量把父类的所有Field都设置成private访问类型，不让子类直接访问父类的Field.
2、	不要让子类可以随意访问、修改父类的方法。父类中作为辅助其他方法的工具方法，应该使用private访问控制符修饰，让子类无法访问该方法。如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望被子类重写该方法，可以使用final修饰符来修饰，表示最终的方法。如果父类的方法可以让子类重写，但是又不希望被其他类自由访问，可以使用protected来修饰该方法。
3、	不要在父类构造方法中调用将会被子类重写的方法。因为如果方法被子类重写，那么子类在实例化时，会调用父类的构造方法来进行父类初始化时，构造方法中调用的是被子类重写的方法，而不是本身的那个方法。
举例2：
package com.langsin.test;
public class Bird {
	Bird(){
		this.fly();
	}
	public void fly(){
		System.out.println("小鸟可以在天空中自由飞翔。。。");
	}
}

package com.langsin.test;
public class Ostrich extends Bird {
	public void fly(){
		System.out.println("鱼儿在水中游来游去。。。");
	}
	public static void main(String[] args) {
		Ostrich os = new Ostrich();  //在创建子类对象时，父类构造方法调用了被子类重写的方法。
	}
}
注意：如果把某些类设置成最终类，即使用final修饰符修饰这个类，那么这个类将不能被当成父类。例如JDK所提供的java.lang.String类，java.lang.System类，都是最终类。
5.8.2 利用组合实现复用
	如果需要复用一个类，除了把这个类当成父类来继承之外，还可以把该类当成另外一个类的组成部分，从而允许新类直接复用该类的public方法。因此，不管是继承还是组合，都允许在新类中直接复用旧类的方法。
	举例1：
package com.langsin.basic;
//商品类
public class Product {
	private String p_name;
	private String p_price;
	private String p_num;
	public Product(String p_name, String p_price, String p_num) {
		this.p_name = p_name;
		this.p_price = p_price;
		this.p_num = p_num;
	}
	public String getP_name() {
		return p_name;
	}
	public void setP_name(String p_name) {
		this.p_name = p_name;
	}
	public String getP_price() {
		return p_price;
	}
	public void setP_price(String p_price) {
		this.p_price = p_price;
	}
	public String getP_num() {
		return p_num;
	}
	public void setP_num(String p_num) {
		this.p_num = p_num;
	}
}

package com.langsin.basic;
//订单类
public class Order {
	private String orderName;
	private String date;
	private String orderId;
	private double money;
	private Product[] prods = new Product[5];

	Order(String orderName,String date,String orderId){
		this.orderId = orderId;
		this.date = date;
		this.orderName = orderName;
	}
	public Product[] getProds() {
		return prods;
	}
	public void setProds(Product[] prods) {
		this.prods = prods;
	}
	public String getOrderName() {
		return orderName;
	}
	public void setOrderName(String orderName) {
		this.orderName = orderName;
	}
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
	public String getOrderId() {
		return orderId;
	}
	public void setOrderId(String orderId) {
		this.orderId = orderId;
	}
	public double getMoney() {
		return money;
	}

	public void setMoney(double money) {
		this.money = money;
	}
	public static void main(String[] args) {
		Product[] prods = new Product[3];
		Product p1 = new Product("笔记本","1200","1");
		Product p2 = new Product("电视机","2000","1");
		Product p3 = new Product("冰箱","1500","1");
		prods[0] = p1;
		prods[1] = p2;
		prods[2] = p3;
		//商品购买完成
		Order order = new Order("张三","20151212","CD001");
		order.setProds(prods);
		//查看此订单的详细信息
		System.out.println("订单用户："+order.orderName +"      订单日期："+order.date);
		System.out.println("此订单的详细商品如下：==================");
		for(int i=0;i<order.getProds().length;i++){
			Product prod = order.getProds()[i];
			System.out.println("商品名称："+prod.getP_name()+"     商品价格："+prod.getP_price()+"    购买数量："+prod.getP_num());
		}
	}
}
5.9 初始化块
	Java使用构造器来对单个对象进行初始化操作，使用构造器先完成整个Java对象的状态初始化，然后将Java对象返回给程序，从而让该Java对象的信息更加完整。与构造器作用非常类似的是初始化块，也可以对Java对象进行初始化操作。
5.9.1 使用初始化块
	初始化块是Java类里可以出现的第四种成员，一个类里可以有多个初始化块，相同类型的的初始化块之间有顺序：前面定义的初始化块先执行，后面定义的初始化块后执行。
	语法格式如下：
	[修饰符]{
		//初始化块的可执行代码
}
	初始化块的修饰符只能是static，使用static修饰的初始化块被称为静态初始化块。初始化块里的代码可以包含任何可执行性语句，包括定义语句变量、调用其他对象的方法，以及使用分支、循环语句等。
举例1：
package com.langsin.test;
public class Person {
	Person(){
		System.out.println(this.gender);
	}
	//一行代码的初始化块，先执行下面代码
	private String gender = "女";
//初始化块
	{
		System.out.println(this.gender); // 女
		this. gender = "男";
		System.out.println(this.gender);  // 男
	}
	public static void main(String[] args) {
		Person person = new Person();
		//对象创建之后，首先执行初始化块，private String gender = “女”;也是初始化块
	}
}

5.9.2 初始化块和构造器
	初始化块先于构造器执行，系统可以同样使用初始化块来进行对象的初始化操作。初始化块是一段固定执行的代码，它不能接收任何参数，因此如果对象有一段初始化处理代码对所有对象都完全相同，且无须接收任何参数，就可以把这段初始化代码提取到初始化块中。
	
举例1：
public class Person {
	Person(){
		this.currentCityName = "青岛";
		System.out.println(this.nation+":"+this.currentCityName);
	}
//如果仅仅是定义变量且初始化的代码块，则可以不放到{}中
	private String nation = "中国";
	private String currentCityName = "济南";
	//代码块会被首先执行，如果是可执行的语句必须将代码放到代码块中，即{}中
	{	
		System.out.println(this.nation+":"+this.currentCityName);
		This.currentCityName = “淄博”;
System.out.println(this.nation+":"+this.currentCityName);
	}
	public static void main(String[] args) {
		Person person = new Person();
	}
}
输出信息：中国 济南
          中国 淄博
          中国 青岛
5.9.3 静态初始化块
	定义初始化块时使用了static修饰符，则这个初始化块就变成了静态初始化块，也被称为类初始化块。静态初始化块是类相关的，系统在类初始化阶段时执行静态初始化块，而不是在创建对象时才执行。因此静态初始化块总是比普通初始化块先执行。

举例1：
package com.langsin.test;

public class Person {
	Person(){
		this.currentCityName = "青岛";
		System.out.println(this.nation+":"+this.currentCityName);
	}
	private String nation = "中国";
	private String currentCityName = "济南";
	{
		System.out.println(this.nation+":"+this.currentCityName);
	}
	private static String flag = "success";
	static{
		System.out.println(Person.flag);
		Person.flag = "false";
		System.out.println(Person.flag);
	}
	public static void main(String[] args) {
		Person person = new Person();
	}
}
第6章：面向对象(下)
	Java提供了final关键字来修饰变量、方法和类，系统不允许为final变量重新赋值，子类不允许覆盖父类的final方法，final类不能派生子类。通过使用final关键字、允许Java实现不可变类，不可变类会让系统更加安全。
	abstract和interface两个关键字分别用于定义抽象类和接口，抽象类和接口都是从多个子类中抽象出来的共同特征。但抽象类主要作为多个类的模板，而接口则定义了多类应该遵守的规范。enum关键字用于创建枚举类，枚举类是一种不能自由创建对象的类，枚举类的对象在定义类时已经固定下来。
6.1 Java增强的包装类
	Java是面向对象编程语言，但同样提供了8中基本数据类型，这8种基本数据类型不支持面向对象的编程机制，基本数据类型同样也不具备“对象”的特征：没有Field成员变量、没有方法可以被调用。8种基本数据类型带来一定的方便性，即：可以进行简单、有效的常规数据处理。但在某些时候基本数据类型会有一些制约。例如：所有的引用类型的变量都继承Object类，都可以当成Object类型变量使用，但是基本数据类型则不可以，如果某些类提供的方法需要Object类型的参数，但实际的数值确是1、2、3、4等数值，这种情况就难以处理。
	为了解决8中基本数据类型的变量不能当成Object类型变量使用的问题，Java提供了包装类的概念，为8中基本数据类型分别定义了相应的引用类型，并称为基本数据类型的包装类。
数据类型	byte	char	short	float	int	double	long	boolean
包装类	Byte	Character	Short	Float	Integer	Double	Long	Boolean

举例1：如何将基本数据类型转换成对应的包装类
	public static void main(String[] args) {
		int a = 5;
		Integer ia = new Integer(a);
		System.out.println(ia);
		boolean b = true;
		Boolean bl = new Boolean(b);
		System.out.println(bl);
		Float fl = new Float(12.5);
		System.out.println(fl);
		float f = 12.5f;
		fl = new Float(f);
		System.out.println(fl);
		fl = new Float("12.5");
		System.out.println(fl);
	}
所有基本数据类型包装类，都提供通过向包装类构造器中传入一个字符串参数的方式来创建包装类对象。但是如果传入的字符串参数不符合基本数据类型格式，那么将引发java.lang.NumberFormatException异常。数据转换格式化异常。
例如：Integer a = new Integer(“aaa”);就会引发数据转换格式化异常。

?	装箱与拆箱
Java提供的基本数据类型与包装类之间的转换有点繁琐，在JDK1.5版本中提供了自动装箱与拆箱的功能。所谓的自动装箱与拆箱就是可以把一个基本类型的数据变量赋值为包装类变量，或者赋值给Object变量，子类对象可以直接赋值给父类变量就是装箱的一种体现。
自动拆箱则与之相反，允许直接把包装类对象直接赋值给一个对应的基本类型变量。

举例2：
	public static void main(String[] args) {
		//自动装箱
		Integer a = 5;
		Object obj = new Float("12.5");
		//自动拆箱
		int b = new Integer(6);
	}
?	基本数据类型与字符串之间的转换
1、	利用包装类提供的parseXxx(String s)的静态方法，将String类型的数据转换成相应的基本数据类型
2、	利用包装类提供的Xxx(String s)构造器
3、	String类型提供了多个valueOf()方法，用于将基本类型变量转换成字符串。

举例3：
	public static void main(String[] args) {
		int a = Integer.parseInt("125");
		float f = Float.parseFloat("12.5");
		boolean b = Boolean.parseBoolean("true");
		String str = String.valueOf(a);
		str = String.valueOf(f);
		str = String.valueOf(b);
	}
6.2 处理对象
	Java对象都是Object类的实例，都可以直接调用Object类中定义的方法，这些方法提供了处理Java对象的通用方法。
6.2.1 打印对象和toString方法
	创建一个对象，并将对象在控制台打印出来。
package com.langsin.test;
public class Test {
	public static void main(String[] args) {
		Test test = new Test();
		System.out.println(test);
	}
}
输出结果：com.langsin.test.Test@de6ced
System.out.println()方法只能在控制台输出字符串，而Test是内存中的一个对象，实际上输出Test的时候默认的调用的是Test从Object对象中继承的toString()方法。等同于System.out.println(test.toString());

Object类提供的toString方法是对该对象的“自我描述”信息，该方法总是返回实现类的“类名+@+hashCode”值，这个返回值并不能真正实现“自我描述”，就必须重写Object类的toString方法。
举例2：
public class Test {
	public String toString(){
		return "自我描述";
	}
	public static void main(String[] args) {
		Test test = new Test();
		System.out.println(test);
	}
}
6.2.2 ==和equals方法
	Java中判断两个变量是否相等有两种方法：一种是利用==运算符，另一种是利用equals方法。当使用==来判断两个变量是否相等时，如果两个变量是基本类型变量，并且是数值类型，只要两个值相等则返回true。对于引用类型，它们指向同一个对象时，“==”判断才返回true。==不可用于比较类型上没有父子关系的两个对象。
举例1：
	public static void main(String[] args) {
		int a = 1;
		int b = 1;
		System.out.println(a==b);  // true
		String s1 = "abc";
		String s2 = "abc";
		System.out.println(s1==s2);  // true
		s2 = new String("abc");
		System.out.println(s1==s2);  // false
		Object obj = "abc";
		System.out.println(s1==obj);  // true
		obj = new String("abc");
		System.out.println(s1==obj);  // false
		System.out.println(s2==obj);  // false
Integer it = 5;
		System.out.println(obj==it);  //false
	}

程序判断两个引用变量是否相等时，equals是进行一种“值相等”的判断，并不严格要求两个引用变量指向同一个对象。例如：对于两个字符串变量，可能只是要求它们引用字符串对象里包含的字符串序列相同即可。
举例2：String s1 = new String(“abc”);  String s2 = new String(“abc”);
判断两个变量所包含的值是否相等时，就可以用equals方法来进行判断。
	public static void main(String[] args) {
		String s1 = new String("abc");
		String s2 = new String("abc");
		System.out.println(s1.equals(s2));
	}
注意：使用equals方法常用于两个字符串之间的值比较。
6.3 类成员
	static关键字修饰的成员就是类成员，其中有类变量Field、类方法、静态初始化块。static修饰的类成员属于整个类，不属于单个实例。

6.3.1 理解类成员
	在Java类里只能包含Field、方法、构造器、初始化块、内部类（接口、枚举）5种成员，其中static可以修饰Field、方法、初始化块、内部类。用static修饰的成员就是类成员。类成员属于整个类，而不是属于单个对象。
	类Field既可以通过类来访问，也可以通过类的对象来访问。但是通过类的对象来访问类Field时，实际上访问的并不是该对象所拥有的Field，而是类所拥有的Field。可以理解为：当通过对象来访问类Field时，系统会在底层转换为通过该类来访问类Field。
举例1：
public class Test {
	public static int a = 1;
	public void run(){
		a++;
		System.out.println(a);
	}
	public static void main(String[] args) {
		Test t1 = new Test();
		t1.run();  //
		Test t2 = new Test();
		t2.run();  //
	}
}
类方法也是类成员的一种，类方法属于类的，通常直接使用类作为调用者来调用类方法，但是可以使用对象来调用类方法，与类Field类似。
静态初始化块也是类成员的一种，静态初始化块用于执行类初始化动作，在类的初始化阶段，系统会调用该类的静态初始化来对类进行初始化。一旦该类初始化结束后，静态初始化块将永远不会获得执行的机会。
	对于static关键字而言，有一条非常重要的规则：类成员不能访问实例成员。因为类成员是属于类的，类成员的作用域比实例成员更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况。如果允许类成员访问实例成员将会引发大量的错误。
6.3.2 单例类
	在Java中，类的构造器默认为public的权限，允许任何类自由的创建该类的对象。但是在某些情况下一些类自由的创建该类的实例对象没有任何意义，比如说：一个系统的窗口管理器、一个数据库引擎访问点，此时如果在系统中为这些类创建多个对象就没有太大的实际意义。 
	所以在这种情况下，可以设计一个类只能创建一个实例，则这个类被称为单例类。
创建单例类的步骤：
1、	使用private关键字修饰构造器
2、	提供一个public的static的类方法调用构造器
3、	创建一个static的成员变量来保存类对象，同时判断对象是否已经创建

举例1：
package com.langsin.test;
public class Singleton {
	private Singleton(){

	}
	private static Singleton single = null;
	public static Singleton getInstance(){
		if(single==null){
			single = new Singleton();
		}
		return single;
	}
	public static void main(String[] args) {
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		System.out.println(s1==s2);
	}
}
6.4 final修饰符	
	final关键字可用于修饰类、变量和方法，用于表示它修饰的类、方法和变量不可改变。final修饰变量时，表示该变量一旦获得了初始值，就不可被改变，final既可以修饰成员变量，也可以修饰局部变量、形参。
6.4.1 final成员变量
	成员变量是随着类初始化或者对象的初始化而初始化的。那么成员变量的初始值可以在定义变量时指定默认的初始值也可以在初始化块或者构造器中指定初始值。
	对于final修饰的成员变量而言，一旦有了初始值，就不能被重新赋值。如果没有在定义成员变量时指定初始值，也没有在初始化块、构造器中指定初始值，那么这些成员变量也就失去了意义。因此Java语法规定：final修饰的成员变量必须由开发人员显示的指定默认值，系统不会对final成员变量进行隐式赋值。
	使用final修饰的成员变量初始化归纳如下：
?	类Field：必须在静态初始化块中或声明该Field时指定初始值。
?	实例Field：必须在非静态初始化块、声明该Field或构造器中指定初始值。
举例1：
package com.langsin.test;

public class Test {
	public Test(){
		s3 = "abc";  //变量s3在构造器中初始化
	}
	public static final int a; //类变量a定义时没有初始化，但在静态化块中进行初始化
	public static final int b = 2; //类变量b在定义时进行了初始化
	static{
		a = 1; //在静态化块中对a进行了初始化
	}
	public final String s1 = "abc"; //普通成员变量在定义时进行了初始化
	public final String s2; //普通成员变量在s2在初始化块中进行了初始化。
	{
		s2 = "123";
	}
	public final String s3; //普通成员变量s3在定义时没有初始化，但是在构造器中进行了初始化。
}
6.4.2 final局部变量
	系统不会对局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值。
	如果final修饰的局部变量在定义时没有指定默认值，则可以在后面代码中对该final变量赋初始值，但只能赋值一次，不能重复赋值。
举例1：
public class Test {
	public void run(){
		final int a = 1;
		for(int i=0;i<5;i++){
			a = i;  //程序编译时报错，提示去掉final
		}
		System.out.println(a);
	}
}
6.4.3 final修饰基本类型和引用类型变量的区别
	使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final只能保证这个引用类型变量所引用的地址不会改变，即一直指向这个对象，但这个对象完全可以改变。
举例1：
package com.langsin.test;

public class Test {
	private final Student st = new Student();
	public void run(){
		st.setAge(36);
		st.setName("王二");
		System.out.println(st.getAge());
		System.out.println(st.getName());
	}
	public static void main(String[] args) {
		Test test = new Test();
		test.run();
	}
}

class Student{
	private int age = 25;
	private String name = "张三";
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
6.4.4 final方法
	final修饰的方法不可被重写，出于某些原因，不希望子类重写父类的某些方法，则可以使用final修饰该方法。
	Java提供的Object类里中提供的getClass()方法就是使用final进行修饰的，因为Java不希望任何类重写这个方法，所以使用final把这个方法封闭起来。但对于该类提供的toString()和equals()方法，都允许子类重写，因此没有使用final修饰他们。
举例1：
package com.langsin.test;
public class Bird {
	private final void fly(){
		System.out.println("小鸟可以在天空中自由飞翔。。。");
	}
}

package com.langsin.test;
public class Ostrich extends Bird {
	public void fly(){
		System.out.println("鱼儿在水中游来游去。。。");
	}
}
子类Ostrich在重写fly方法时编译报错。
注意：对于使用private修饰的方法，表示私有方法，只能是对象本身调用，那么子类在继承时是无法访问该方法的，所以子类无法重写该方法。如果子类中定义一个与父类private方法相同方法名、相同返回值类型、相同参数列表的方法，也不是重写，而是定义了一个新的方法。因此即使使用final修饰一个使用private访问权限的的方法，依然可以在其子类中定义一个与该方法一模一样的方法。

package com.langsin.test;
public class Bird {
	private final void fly(){
		System.out.println("小鸟可以在天空中自由飞翔。。。");
	}
}

package com.langsin.test;
public class Ostrich extends Bird {
	public void fly(){
		System.out.println("鱼儿在水中游来游去。。。");
	}
}
此时，此类中定义的方法将不会编译报错。
6.4.5 final类
	final修饰的类不可以有子类，例如：java.lang.Math类就是一个final类，它不可以有子类。
	当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类的方法来改变父类方法的实现细节，这可能会导致一些不安全的因素。为了确保某个类不被继承，则可以使用final类修饰这个类。
	
6.4.6不可变类
	不可变类的意思是创建该类的实例后，该实例的Field是不可改变的。Java提供的8个基本数据类型的包装类和java.lang.String类都是不可变类，当创建他们的实例后，其实例的Field不可改变。
	
	举例：
Double d = new Double("12.5");
	String str = new String("abc");
创建两个对象，并传入了两个字符串作为参数，那么Double类和String类肯定需要提供实例成员变量来存放这个两个参数，但程序无法修改这两个实例成员的值。
	因此，如果需要创建自定义的不可变类，可遵循如下规则：
?	使用private和final修饰符来修饰该类的Field
?	提供参数构造器，用于根据传入参数来初始化类里的Field
?	仅为该类的Field提供getter方法。
6.5 抽象类 
	当编写一个类时，常常会为该类定义一些方法，这些方法用于描述这个类的行为。但在某些情况下只需要定义出一些方法，而不需要具体的去实现这些行为。也就是说这些方法没有方法体，只是一些签名而已，这样的方法被称为抽象方法，包含抽象方法的类被称为抽象类。
6.5.1 抽象方法与抽象类
	抽象方法与抽象类必须使用abstract关键字进行修饰，有抽象方法的类必须被定义成抽象类，抽象类里面可以没有抽象方法。
抽象类与抽象方法的规则如下：
1、	抽象类与抽象方法必须使用abstract关键字进行修饰，抽象方法不能有方法体。
2、	抽象类不能被实例化。即使抽象类不包含抽象方法，也不能被实例化。
3、	抽象类可以包含field、方法、构造器、初始化块、内部类5种成分。
4、	包含抽象方法的类，只能被定义成抽象类。
举例1：
package com.langsin.test;
public abstract class Test {
	public String name = "zhangsan";
	public abstract void setName();
	public abstract String getName();
	public void run(){
		System.out.println("让类跑起来");
	}
}
举例2：创建一个类继承Test类
package com.langsin.test;
public class TestAbstract extends Test {
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public static void main(String[] args) {
		TestAbstract test = new TestAbstract();
		System.out.println(test.getName());  //打印的是zhangsan
	}
}

举例3：在上面这个类中重写name属性

package com.langsin.test;
public class TestAbstract extends Test {
	public String name;
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void test(){
		super.name = "李四";
		this.name = "张三";
		super.run();
		System.out.println(this.name);
	}
	public static void main(String[] args) {
		TestAbstract ta = new TestAbstract();
		ta.test();
	}
}
利用抽象类和抽象方法的优势，可以更好的发挥多态的优势，使得程序更加灵活。
使用abstract修饰类时，表明这个类只能被继承，当使用abstract修饰方法时，表明这个方法必须由子类实现。而final修饰的类不能被继承，final修饰的方法不能被重写。因此final和abstract永远不能同时使用。除此之外，使用static修饰一个方法时，表示此方法属于该类本身，即通过类就可以调用该方法，但是如果此方法被定义成抽象方法了，则将导致通过该类来调用该方法时出现错误，因此static和abstract也不能同时修饰某个方法，也就是没有类抽象方法。
6.5.2 抽象类的作用
	抽象类不能创建实例，只能当成父类来被继承。抽象类可以看成是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出来的一个抽象类，以这个抽象类作为其子类的模板，从而避免子类设计的随意性。
	抽象类的体现就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。
	编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式，模板模式也是十分常见的设计模式。
举例1：
package com.langsin.test;
public abstract class Test {
	public abstract String getColor();
}

package com.langsin.test;
public class TestOne extends Test {
	public String getColor() {
		return "red";
	}
}

package com.langsin.test;
public class TestTwo extends Test {
	public String getColor() {
		return "green";
	}
	public static void main(String[] args) {
		TestOne one = new TestOne();
		System.out.println("车的颜色是："+one.getColor());
		TestTwo two = new TestTwo();
		System.out.println("车的颜色是："+two.getColor());
	}
}

模板模式在面向对象的软件中很常用，其原理简单，实现也很简单。使用模板模式有如下规则：
抽象父类可以只定义需要使用的方法，把不能实现的部分抽象成抽象方法留给子类去实现。
6.6 接口
	抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的“抽象类”――接口（interface）。接口里不能包含普通方法，接口里的所有方法都是抽象方法。
6.6.1 接口的概念
	Java中的接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。
6.6.2 接口的定义
	和类定义不同，定义接口不在使用class关键字，而是使用interface关键字。接口定义的基本语法如下：
[修饰符]  interface  接口名  extends  父接口1,父接口2{
	零到多个常量定义
	零到多个抽象方法定义
}
?	修饰符可以是public或者protected省略，省略采用默认包权限访问控制符
?	接口名应与类名采用相同的命名规则
?	一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类
接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含Field、方法、内部类定义。因为接口没有构造器与初始化块，因此系统不能为field进行默认的初始化操作，只能由程序编写人员为field指定默认的值，所以field只能是常量。又因为field只能是常量，所以系统自动为这些field增加了static和final两个修饰符。也就是说在接口中定义的Field不管是否使用了public static final修饰符，接口里的Field总是默认的使用这三个修饰符来进行修饰。
举例1：
int MAX_SIZE = 50;
public static final int MAX_SIZE = 50；
两行代码的运行结果完全一致。

接口里定义的方法都是抽象方法，因此系统会自动为方法增加public abstract修饰符。因此不管定义接口方法时是否使用了public abstract修饰符，系统都会默认的使用public abstract修饰符来进行修饰。
举例2：
package com.langsin.test;
public interface TestInterface {
	public static final int WIDTH = 5; //与下行代码运行结果一致
	int LENGTH = 10;
	public abstract void run(); //与下行代码运行结果一致
	void fly();
}
6.6.3 接口的继承
接口的继承与类的继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。和继承相似，子接口扩展父接口，将会获得父接口里定义的所有抽象方法、field、内部类和枚举定义。
一个接口继承多个父接口时，多个父接口排在extends关键字之后，多个父接口之间使用英文逗号（,）进行分隔。
举例1：
package com.langsin.test;
public interface InterfaceA {
	public abstract void testA();
}

package com.langsin.test;
public interface InterfaceB {
	public abstract void testB();
}

package com.langsin.test;
public interface InterfaceC extends InterfaceA, InterfaceB {
	public abstract void testC();
}
6.6.4 使用接口
	接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其实现类的对象。除此之外，接口的主要用途就是被实现类进行实现。
	一个类可以实现多个接口，继承使用extends关键字，而实现则使用implements关键字。
	实现接口与继承类相似，一样可以获得所实现接口里定义的常量field、抽象方法、内部类和枚举类定义。
让类实现接口需要在类定义后面增加implements部分，当需要实现多个接口时，多个接口之间以英文逗号（,）隔开。一个类可以继承一个父类并同时实现多个接口，implements部分必须放在extends部分之后。
	一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法，否则该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。

举例1：
package com.langsin.test;
public interface Product {
	public static final int MAX_SIZE = 10;
	public abstract int getProductNum();
}

package com.langsin.test;
public interface OutPut {
	public abstract void out();
public void addData(String msg);
}

package com.langsin.test;
public class Printer implements Product, OutPut {
	private String[] printData = new String[MAX_SIZE];
	private int currentNum = 0;
	public void out() {
		while(currentNum>0){
			System.out.println(printData[--currentNum]);
		}
	}
	public int getProductNum() {
		return currentNum;
	}
	public void addData(String msg){
		if(currentNum>=MAX_SIZE){
			System.out.println("队列已满，添加失败");
		}else{
			printData[currentNum++] = msg;
		}
	}
	public static void main(String[] args) {
		OutPut out = new Printer();
		out.addData("浪曦云团");
		out.addData("浪曦算法");
		out.addData("浪曦coreJava");
		//out.out();
		Product product = new Printer();
		int num = product.getProductNum();
		System.out.println(num);
	}
}
6.6.5 接口和抽象类差异
1、接口和抽象类都不能进行实例化，它们都位于继承树的顶端，用于被其他类实现和继承。
2、接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务。对于接口的调用者而言，接口规定了调用者可以调用哪些服务。当在一个程序中使用接口时，接口是多个模块间的耦合标准，当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。

	接口类似于系统的总纲，一旦接口发生变化，对于整个系统是辐射式的，所有实现这个接口的普通类都要进行改写。

	抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模版式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品。这个中间产品已经实现了系统的部分功能，但这个类不能称为最终产品，必须有更进一步的完善，这种完善可能有几种不同的方式来实现。

	接口与抽象类在用法上也存在如下差异：
?	接口里只能包含抽象方法，不包含已经提供实现的方法，抽象类则完全可以包含普通方法。
?	接口里不能定义静态方法，抽象类里可以定义静态方法。
?	接口里只能定义静态常量Field，不能定义普通的Field，抽象类里则都可以
?	接口里不包含构造器，抽象类里可以包含构造器，抽象类里的构造器并不是用来创建对象，而是让其子类调用这些构造器完成属于抽象类的初始化操作。
?	接口里不能包含初始化块，但抽象类则完全可以包含初始化块。
?	一个类最多只有一个父类，包括抽象类，但是一个类可以实现多个接口。
6.6.6 面向接口编程
	接口体现的是一种规范和实现分离的设计模式，充分利用接口可以很好降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。
	基于这种原则，软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。下面两种常用场景来示范面向接口编程的优势。

1、	简单工厂模式

假设我们在系统中有个Computer类需要一个输出类Printer类，那么普通的情况下是我们在Computer类中new一个Printer类这个对象就可以，但是如果以后我们的系统进行重构，让BetterPrinter类来代替原有的Printer类，那么我们就需要打开Computer类进行源码的修改，如果系统中只有一个Computer类用到了Printer类还好，如果有10个、100个、1000个Computer类用到了Printer类，那么这将是一个非常庞大的工作量。

如果使用面向接口的方式来处理这种问题，将会变的非常简单。
例如：我们创建输出接口Out，让我们的Printer类来实现这接口，我们使用工厂模式来创建返回的结果。在我们的Computer类中使用工厂来进行创建，实现Computer类与Printer类的一个分离，对Computer类屏蔽到Printer类的实现细节。

package com.langsin.test;
public interface Out {
	public abstract void printer ();
}
=======================================================================
package com.langsin.test;
public class Printer implements Out {
	public void printer() {
		System.out.println("普通打印机");
	}
}
=======================================================================
package com.langsin.test;
public class BetterPrinter implements Out {
	public void printer() {
		System.out.println("高级打印机");
	}
}
=======================================================================
package com.langsin.test;
public class PrinterFactory {
	public static Out getInstance(){
		return new BetterPrinter();
	}
}
========================================================================
package com.langsin.test;
public class Computer {
	Out out = PrinterFactory.getInstance();
}
在进行重构时，我们只需要将工厂源码打开，将返回对象进行修改，所有调用这个方法的类获得的将不再是Printer类对象，而是新的BetterPrinter类对象。

6.7 内部类
	在定义类的时候，我们一般把类定义成一个独立的程序单元。但是在某些情况下，我们会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类，也可以称为嵌套类。包含内部类的类也被称为外部类，也可以称为宿主类。Java从JDK1.1开始引入内部类，内部类的主要作用如下：
?	内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中其他类访问该类。
?	内部类成员可以直接访问外部类的私有数据，因为内部类被当成外部类的成员，同一个类成员之间可以相互访问。
?	匿名内部类适合用于创建那些仅需要一次使用的类。
举例1：
package com.langsin.test;

public class Student {
	private String name = "zhangsan";
	public int age = 25;
	//============内部类开始=======================
	class Action{
		//没有什么特殊意义，就是一个内部类的成员变量
		public String flag = "abc";
		public void change(){
			Student.this.name = "lisi";
			Student.this.age = 35;
		}
	}
	//=============内部类结束========================
	public void run(){
		Action action = new Action();
		action.change();
		System.out.println(this.name);
		System.out.println(this.age);
	}
	public static void main(String[] args) {
		Student sty = new Student ();
		stu.run();
	}
}
6.7.1 非静态内部类
	定义内部类非常简单，只要把一个类放在另一个类内部定义即可。此处的“内部类”包括类中的任何位置，甚至在方法中也可以定义内部类，在方法中定义的内部类叫做局部内部类。
	通常情况下，内部类都被作为成员内部类定义，而不是作为局部内部类。成员内部类是一种与Field、方法、构造器和初始化块相似的类成员。
	成员内部类分为：静态内部类和非静态内部类两种，使用static修饰的成员内部类就是静态内部类，没有使用static修饰的成员内部类就是非静态内部类。
	因为内部类作为其外部类的成员，所以可以使用任意访问控制符：private、protected、public修饰的Field成员。
	如上例所示：
6.7.2 静态内部类
	使用static修饰符来修饰内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为静态内部类。
	静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。
	举例1：
package com.langsin.test;

public class Car {
	private static String name = "zhangsan";
	public int age = 25;
	static class Action{
		public static String flag = "abc";
		public String gender = "1";
		public void change(){
			Car.name = "lisi";
			//下面这行代码编译报错
			Car.this.age = 34;
		}
	}
	public void run(){
		Action action = new Action();
		action.change();
		System.out.println(name);
		System.out.println(this.age);
System.out.println(Action.flag);
	}
	public static void main(String[] args) {
		Car car = new Car();
		car.run();
	}
}
外部类不能直接访问静态内部类的实例成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。
举例2：
package com.langsin.test;
public class Test {
	static class InnerTest{
		public static int num = 1;
		public int num2 = 5;
	}
	public void run(){
		InnerTest.num = 4;
		System.out.println(InnerTest.num); //4
        InnerTest it = new InnerTest();
		System.out.println(it.num); // 4
	}
}
6.7.3 局部内部类
	如果把一个内部类定义在方法里面定义，则这个内部类就是一个局部内部类。
举例1：
package com.langsin.test;
public  class Test {
	public int aa = 12;
	public void run(){
		class InnerTest{
			public int num2 = 5;
			public void run(){
				System.out.println(num2);
			}
		}
		InnerTest it = new InnerTest();
		it.run();
	}
	public static void main(String[] args) {
		Test te = new Test();
		te.run();
	}
}
6.7.4 匿名内部类	
	匿名内部类的语法有些特别，创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。因此匿名内部类适合创建那种只需要一次使用的类。
	匿名内部类的格式如下：
new 父类构造器|实现接口(){
	//匿名内部类的类体部分
}
匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，实现一个接口。
?	匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。
?	匿名内部类不能定义构造器，因为匿名内部类没有类名，也就无法定义构造器，但是匿名内部类可以定义实例初始化块，通过初始化块来完成初始化操作。
举例1：
package com.langsin.test;

public class Test {
	public int aa = 12;
	public void run(InnerTest it){
		System.out.println(it.num2);
		it.run();
	}
	public static void main(String[] args) {
		Test te = new Test();
		te.run(new InnerTest(){
			public void run(){
				System.out.println(“aaaaaaaaaaaaaaaaa”);
}
		});
	}
}

abstract class InnerTest{
	public int num2 = 5;
	public void run();
}
6.8 枚举类
	一个类的对象是有限而且固定的，比如季节，只有四个对象；比如行星，只有8个对象。这种实例有限而且固定的类，在Java里被称为枚举类。
6.8.1 枚举类定义
package com.langsin.test;
public enum Planet {
	MERCURY,
	VENUS,
	EARTH,
	MARS,
	JUPITER,
	SATURN,
	URANUS,
	NEPTUNE
}
使用方式：
package com.langsin.test;
public class Test {
	public static void main(String[] args) {
		System.out.println(Planet.EARTH); // Planet.EARTH返回的是对象，对象的值为枚举值
Planet jupiter = Planet.JUPITER;
		System.out.println(jupiter);
	}
}

第10章：异常处理
	Java的异常机制主要依赖于try、catch、finally、throw和throws五个关键字，其中try关键字后面紧跟着一个花括号括起来的代码块，它里面放置可能会引发异常的代码块。catch后面对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块，多个catch块后面还可以跟一个finally块，用于回收在try块里打开的物理资源，异常机制会保证finally块总会被执行。throws关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；而throw用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。
10.1 异常概述
	异常处理已经成为衡量一门语言是否成熟的标准之一，目前的主流编程语言如C++，C#，Ruby等大都提供了异常处理机制。增加异常处理机制后的程序有更好的容错性，更加健壮。
举例1：
	public static void main(String[] args) {
		List<String> list = new ArrayList<String>();
		list.add("abc");
		list.add("def");
		try {
			for(int i=0;i<4;i++){
				System.out.println(list.get(i));
			}
		} catch (IndexOutOfBoundsException e) {
			System.out.println("已经超出了集合的范围");
		}
	
	}
10.2 异常处理机制
	Java的异常处理机制可以让程序具有极好的容错性，让程序更加健壮。当程序出现意外情形时，系统会自动生成一个Exception对象来通知程序，从而实现将“业务功能实现代码”和“错误处理代码”分离，提供更好的可读性。
10.2.1 使用try…catch捕获异常
	在Java中提出了一种假设：如果程序可以顺利完成，那就“一切OK”，把系统的业务实现代码放在try块中定义，所有的异常处理逻辑放在catch块中进行处理。下面是Java异常处理机制的语法规则。
try{
	//业务实现代码
}catch(ExceptionClass1 e1){
	//错误处理代码
}catch(ExceptionClass2 e2){
	//错误处理代码
}finally{
	//始终会执行的代码
}
Try块后可以有多个catch块，这是为了针对不同的异常类提供不同的异常处理方式。当系统发生不同的意外情况时，系统会生成不同的异常对象，Java运行时就会根据该异常对象所属的异常类来决定使用哪个catch块来处理。
举例1：
public static void main(String[] args) {
		List<String> list = new ArrayList<String>();
		list.add("abc");
		list.add("def");
		list.add(null);
		try {
			for(int i=0;i<4;i++){
				list.get(i).equals("abc");
				System.out.println(list.get(i));
			}
		} catch (IndexOutOfBoundsException e) {
			System.out.println("索引值越界异常");  
		} catch(NullPointerException e){
			System.out.println("空指针异常处理");  
		}finally{
			System.out.println("始终会被执行的代码块");  
		}
	}
10.2.2 异常类的继承体系
	Java提供了丰富的异常类，这些异常类之间有严格的继承关系，如下图所示：
 
在Java中把所有的非正常情况分为两种：异常（Exception）和错误（Error），他们都继承Throwable父类。Error错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不能试图使用catch块来捕获Error对象，在定义方法时也无须其throws子句中声明该方法可能抛出Error及其任何子类。
10.2.3 访问异常信息
	如果程序需要在catch块中访问异常对象的相关信息，则可以通过访问catch块后的异常形参来获得。当Java运行时决定调用某个catch块来处理该异常对象时，会将异常对象赋给catch块后的异常参数，程序即可通过该参数来获得异常的相关信息。
	所有异常对象都包含了如下几个常用方法。
?	getMessage()：返回该异常的详细描述字符串。
?	printStackTrace()：将该异常的跟踪栈信息输出到标准错误输出。
?	printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流中。
?	getStackTrace()：返回该异常的跟踪栈信息。
举例1：
	public static void main(String[] args) {
		List<String> list = new ArrayList<String>();
		list.add("abc");
		list.add("def");
		list.add(null);
		try {
			for(int i=0;i<4;i++){
				list.get(i).equals("abc");
				System.out.println(list.get(i));
			}
		} catch (IndexOutOfBoundsException e) {
			System.out.println("已经超出了集合的范围");
		}catch(NullPointerException e){
			e.printStackTrace();
			System.out.println(e.getMessage());
			System.out.println("空指针异常处理");
		}finally{
			System.out.println("始终会被执行的代码块");
		}
	}
输出信息：
 
10.2.4 使用finally回收资源
	程序在try块里打开了一些物理资源，比如：数据库连接、网络连接、和磁盘文件等，这些物理资源都必须显示回收。
	如果在try块的某条语句引起了异常，该语句后的其他语句通常不会获得执行的机会，这将导致该语句之后的资源回收语句得不到执行。如果在catch块里进行资源回收，但catch块完全有可能得不到执行，这将导致不能及时回收这些物理资源。
	为了保证一定能回收try块中打开的物理资源，异常处理机制提供了finally块。不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或者catch块中执行了return语句，finally块总会被执行。因此回收资源执行语句应该在finally块中执行。
举例1：
public static void main(String[] args) {
		FileInputStream fis = null;
		try {
			fis = new FileInputStream("./a.txt");
		} catch (Exception e) {
			e.printStackTrace();
			return;
		}finally{
			try {
				fis.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
10.2.5 使用throws声明抛出异常
	使用throws声明抛出异常的思路是，当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理；如果main方法也不知道如何处理这种类型的异常，也可以使用throws声明抛出异常，该异常将交给JVM处理。JVM对异常的处理方法是，打印异常的跟踪栈信息，并终止程序执行。
举例1：
	public void dealFile() throws Exception{
		FileInputStream fis = null;
		fis = new FileInputStream("./a.txt");
		fis.close();
	}

	public static void main(String[] args) throws Exception {
		Test test = new Test();
		test.dealFile();
	}
10.2.6 使用throw抛出异常
	如果需要在程序中自主的抛出异常，则应该使用throw语句，throw语句可以单独使用，throw语句抛出的不是异常类，而是一个异常实例，而且每次只能抛出一个异常实例。
举例1：
	public static void main(String[] args){
		for(int num=5;num>=0;num--){
			try {
				if(num<2){
					throw new Exception("数字的值小于2了，停止运行");
				}
			} catch (Exception e) {
				System.out.println("======");
				System.out.println(e.getMessage());
			}
		}
		System.out.println("最终执行完成");
	}

第12章：AWT编程
	现代的编程已经脱离了单调的黑窗体，即Dos环境下运行程序。现代的用户也早已经习惯了GUI（Graphics User Interface）图形化用户界面。
Java使用AWT和Swing类完成图形用户界面编程，其中AWT的全称是抽象窗口工具集(Abstract Window Toolkit)，它是Sun最早提供的GUI（Graphics User Interface图形化用户界面）库，这个GUI库提供了一些基本功能，这个GUI库的功能比较有限，所以后来又提供了Swing库。通过使用AWT和Swing提供的图形界面组件库，Java的图形用户界面编程非常简单，程序只需要依次创建所需要的图形组件，并以合适的方式将这些组件组织在一起，就可以开发出非常美观的用户界面。
	要创建GUI程序，可以大概的分为以下几步：
1、	创建顶层窗口
2、	创建组件、如：文本框、标签、按钮
3、	确定窗口中各组件的排列方式
4、	将组件添加到窗口
12.1 GUI（图形用户界面）和AWT
	JDK1.0发布时，Sun提供了一套基本的GUI类库，这个GUI类库能够在所有平台下都运行，这套基本类库被称为“抽象窗口工具集”，它为Java应用程序提供了基本的图形组件。AWT是窗口框架，它从不同的窗口系统中抽取出共同组件，当程序运行时，将这些组件的创建和动作委托给程序所在的运行平台。AWT编写图形界面应用时，程序仅指定了界面组件的位置和行为，并未提供真正的实现，JVM调用操作系统本地的图形界面来创建和平台一致的对等体。
	使用AWT创建的图形界面应用和所在的运行平台有相同的界面风格，比如在Windows操作系统，它就表现出Windows风格，在Unix操作系统上，就表现出Unix风格。
	但是在实际应用中，AWT出现了几个如下问题：
?	使用AWT做出的图形用户界面在所有的平台上都显得很丑陋，功能也非常有限。
?	AWT为了迎合所有主流操作系统的界面设计，AWT组件只能使用这些操作系统上图形界面组件的交集，所以不能使用特定操作系统上复杂的图形界面组件。
?	AWT用的是非常笨拙的、非面向对象的编程模式。
1996年，网景公司开发了一套工作方式完全不同的GUI库，简称IFC（Internet Foundation Classes），这套GUI库的所有图形界面组件，例如文本框、按钮等都是在空白窗口上的，之后窗口本身借助于操作系统的窗口实现。IFC真正实现了各种平台上的界面一致性。
之后，Sun公司和网景公司合作完善了这种方法，并创建了一套新的用户界面库：Swing。AWT、Swing、辅助功能API、2DAPI以及拖放API共同组成JFC（Java Foundation Classes），其中Swing组件全面代替了AWT组件，保留了AWT组件的事件模型。总体上，AWT是图形用户界面编程的基础，Swing组件替代了绝大部分AWT组件，对AWT图形用户界面编程有极好的补充和加强。
所有的和AWT编程相关的类都放在java.awt包以及它的子包中，AWT编程中有两个基类：Component和MenuComponent。
 
在java.awt包中提供了两种基类表示图形界面元素：Component（普通组件）和MenuComponent（菜单相关的组件），其中Component代表了一个能以图形化方式显示出来，并可与用户交互的对象，例如Button代表了一个按钮，TextField代表一个文本框等；而MenuComponent则代表图形界面的菜单组件，包括MenuBar菜单条，MenuItem菜单项等子类。
除此之外，AWT图形用户界面编程里还有两个重要的概念：Container和LayoutManager，其中Container是一种特殊的Component，它代表一种容器，可以盛装普通的Component；而LayoutManager则是容器管理其他组件布局的方式。
12.2 AWT容器
任何窗口都可被分解成一个空的容器，容器里盛装了大量的基本组件，通过设置这些基本组件的大小、位置等属性，就可以将该空的容器和基本组件组成一个整体的窗口。图形界面编程非常简单，类似于拼图游戏，容器类相当于“模版”，而普通组件则类似于拼图的图块。创建图形用户界面的过程就是完成拼图的过程。
容器（Container）是Component的子类，因此容器对象本身也是一个组件，具有组件的所有性质，可以调用Component类的所有方法。Component类提供了如下几个常用方法来设置组件的大小、位置和可见性等。
?	setLocation(int x,int y)：设置组件的位置。
?	setSize(int width;int height)：设置组件的大小。
?	setBounds(int x,int y,int width,int height)：同时设置组件的位置、大小。
?	setVisible(Boolean b)：设置该组件是否可见。
容器还可以盛装其他组件，容器类（Container）提供了如下几个常用方法来访问容器里的组件：
?	Component add(Component comp)：向容器中添加其他组件，并返回被添加的组件。
?	Component getComponentAt(int x,int y)：返回指定点的组件。
?	int getComponentCount()：返回该容器组件内的数量
?	Component[] getComponents()：返回该容器内的所有组件。
AWT主要提供了如下两种主要的容器类型。
?	Window：可独立存在的顶级窗口。
?	Panel：可作为容器容纳其他组件，单不能独立存在，必须被添加到其他容器中（如：window、Panel或Applet等）

AWT容器之间的继承关系如下图所示：
 
12.2.1 框架（Frame）
Frame代表常见的窗体，它是Window类的子类，具有如下几个特点
?	Frame对象有标题，允许通过拖拉来改变窗口的位置、大小。
?	初始化时不可见，可以使用setVisible(true)使其显示出来。
?	默认使用BorderLayout作为其布局管理器。
举例1：
package com.langsin.awt;
import java.awt.Frame;
public class MyFrame {
	public static void main(String[] args) {
		Frame myFrame = new Frame("我的第一个窗口");
		// setBounds()方法，移动组件并设置其大小，可以用来处理组件的显示位置以及设置组件大小
		myFrame.setBounds(50,50,500,300);
		myFrame.setVisible(true);
	}
}
12.2.2 面板（Panel）
Panel是AWT组件中的另外一个典型的容器，它代表不能独立存在、必须放在其他容器中的容器。Panel的外在表现为一个矩形区域，该区域内可盛装其他组件。Panel容器存在的意义在于为其他组件提供空间，Panel容器具有如下特点：
?	可作为容器来盛装其他组件，为放置组件提供空间。
?	不能单独存在，必须放置到其他容器中。
?	默认使用FlowLayout作为其布局管理器。
举例2：
package com.langsin.awt;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextField;
public class MyFrame {
	public static void main(String[] args) {
		//创建一个窗体，构造函数接收的是窗体的名称
		Frame myFrame = new Frame("第一个窗口");
		//设置窗体的初始坐标位置以及宽度，高度
		myFrame.setBounds(50,50,500,300);
		//创建一个Panel面板组件
		Panel panel = new Panel();
		//在Panel中添加个文本域
		panel.add(new TextField(20));
		//在Panel中添加给按钮
		panel.add(new Button("点击"));
		//将Panel对象加入到Frame窗体中，因为Panel不能独立存在
		myFrame.add(panel);
		//让窗体可见
		myFrame.setVisible(true);
	}
}
ScrollPane是一个带有滚动条的容器，它也不能独立存在，必须被添加到其他容器中。ScrollPane容器具有如下特点：
?	可作为容器来盛装其他组件，当组件占用空间过大时，ScrollPane自动产生滚动条。当然也可以通过构造器参数来指定默认具有滚动条。
?	不能独立存在，必须放置在其他容器中。
?	默认使用BorderLayout作为其布局管理器。ScrollPane通常用于盛装其他容器，所以通常不允许改变ScrollPane的布局管理器。
举例3：
package com.langsin.awt;
import java.awt.Button;
import java.awt.Frame;
import java.awt.ScrollPane;
import java.awt.TextField;
public class MyFrame {
	public static void main(String[] args) {
		//创建一个窗体，构造函数接收的是窗体的名称
		Frame myFrame = new Frame("第一个窗口");
		//设置窗体的初始坐标位置以及宽度，高度
		myFrame.setBounds(50,50,500,300);
		//创建一个Panel面板组件
		ScrollPane panel = new ScrollPane(ScrollPane.SCROLLBARS_ALWAYS);
		//在Panel中添加个文本域
		panel.add(new TextField(20));
		//在Panel中添加给按钮
		panel.add(new Button("点击"));
		//将Panel对象加入到Frame窗体中，因为Panel不能独立存在
		myFrame.add(panel);
		//让窗体可见
		myFrame.setVisible(true);
	}
}
执行结果我们只能看到一个按钮，而看不到文本框，这是由于布局管理器的缘故，BorderLayout导致了该容器中只有一个组件被显示出来。
12.3 AWT常用组件
AWT组件需要调用运行平台的图形界面来创建和平台一致的对等体，因此AWT只能使用所有平台都支持的公共组件，所以AWT只提供了一些常用的GUI组件。
12.3.1 基本组件
AWT提供的基本组件：
?	Button：按钮，可以接收单击事件
?	Canvas：用于绘图的画布
?	CheckBox：复选框组件（也可变成单选框组件）
?	CheckBoxGroup：用于将多个CheckBox组件组合成一组，一组Checkbox组件只有一个可以被选中，即全部变成单选框组件。
?	Choice：下拉选择框组件
?	Frame：窗口，在GUI程序里通过该类创建一个窗口。
?	Label：标签类，用于放置提示性文本
?	List：列表框组件，可以添加多项条目
?	Panel：不能单独存在的基本容器类，必须放到其他容器中去
?	Scrollbar：滑动条组件，如果需要用户输入位于某个范围的值，可以使用滑动条组件。当创建一个滑动条时，必须指定它的方向，初始值、滑块的大小、最小值和最大值
?	ScrollPane：带水平及垂直滚动条的容器组件。
?	TextArea：多行文本域
?	TextField：单行文本框
12.3.2 Button（按钮）
常用的构造方法：
1、	Button()：创建一个按钮，按钮上的标签没有任何内容
2、	Button(String LableContent)：创建一个按钮，自定义按钮标签上的内容
常用的方法：
1、	setBackground(Color color)：设置按钮的背景颜色
2、	setEnable(boolean b)：设置按钮是否可用
3、	setFont(Font f)：设置按钮标签的字体
4、	setForeground(Color color)：设置按钮的前景色
5、	setLabel(String text)：设置按钮标签的内容
6、	setVisible(boolean b)：设置按钮是否可见
举例1：
	public static void main(String[] args) {
		Frame frame = new Frame("我的窗体");
		Button bt1 = new Button("苹果");
		bt1.setBackground(Color.GREEN);
		bt1.setForeground(Color.BLUE);
		frame.add(bt1,BorderLayout.NORTH);
		Button bt2 = new Button("香蕉");
		bt2.setBackground(Color.YELLOW);
		Font font = new Font("微软雅黑", Font.PLAIN, 15);
		bt2.setFont(font);
		frame.add(bt2);
		frame.setSize(500, 500);
		frame.setLocation(100, 100);
		frame.setVisible(true);
	}
12.3.3 Label（标签）
常用的构造方法：
1、	Label()：创建一个标签，标签上没有任何文字
2、	Label(String text)：创建一个标签，并且自定义标签上的文字。
3、	Label(String text,int alignment)：创建一个标签，并且自定义标签上的文字及对齐方式。
常用方法：
1、	setAlignment(int alignment)：设置标签文本的对齐方式
2、	setBackground(Color color)：设置标签的背景色
3、	setEnable(boolean b)：设置标签是否可用
4、	setFont(Font font)：设置标签文本的字体
5、	setForeground(Color color)：设置标签的前景色
6、	setText(String text)：设置标签的内容
7、	setVisible(boolean b)：设置标签是否可见
举例1：
package com.langsin.awt;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.Label;
public class LabelDemo extends Frame {
	Label lab1 = new Label();
	Label lab2 = new Label("Second",Label.LEFT);
	Label lab3 = new Label("Third",Label.RIGHT);
	Label lab4 = new Label();
	LabelDemo(){
		this.setLayout(new GridLayout(2,2));
		this.lab4.setText("Fourth");
		this.lab4.setAlignment(Label.RIGHT);
		this.add(lab1);
		this.add(lab2);
		this.add(lab3);
		this.add(lab4);
		this.setSize(300,200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new LabelDemo();
	}
}
12.3.4 TextField（文本框）
常用的构造方法：
1、	TextField()：创建一个文本域
2、	TextField(String text)：创建一个文本域，并且有初始值
3、	TextField(String text,int columns)：创建一个文本域，有初始值，并且设置列数
4、	TextField(int columns)：创建一个文本域，没有初始内容，可设置列数。
常用方法：
1、	requestFocus()：为文本域请求焦点
2、	setBackground(Color color)：设置标签的背景色
3、	setColumns(int columns)：设置文本域的列数
4、	setEditable(boolean b)：设置文本域是否可编辑
5、	setEnable(boolean b)：设置文本是否可用
6、	setFont(Font f)：设置文本域文字的字体
7、	setForeground(Color color)：设置文本域的前景色
8、	setText(String text)：设置文本域的文本内容
9、	setVisible(boolean b)：设置文本域是否可见
举例1：

package com.langsin.awt;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.TextField;
public class TextFieldDemo extends Frame {
	TextField textField1 = new TextField();
	TextField textField2 = new TextField("second");
	TextField textField3 = new TextField("Third",10);
	TextField textField4 = new TextField(20);
	TextFieldDemo(){
		this.setLayout(new FlowLayout());
		this.textField1.setEnabled(false);
		this.textField2.setEditable(false);
		this.textField4.setText("Fourth");
		this.add(textField1);
		this.add(textField2);
		this.add(textField3);
		this.add(textField4);
		this.setSize(300, 400);
		this.setLocation(100, 200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new TextFieldDemo();
	}
}
12.3.5 TextArea（多行文本域/文本区）
常用的构造方法
1、	TextArea()：创建一个默认大小的空文本区
2、	TextArea(String text)：创建一个默认大小的文本区，并初始其内容
3、	TextArea(String text,int rows,int columns)：创建一个含有初始内容的文本区域，并设定文本区域的行数跟列数。
4、	TextArea(String text,int rows,int columns,int scrollbars)：创建一个文本区，并且自定义文本内容，设定文本区域的内容，设定文本区的行数跟列数，设置滚动条的状态
5、	TextArea(int rows,int columns)：创建一个文本区，并且自定义文本区的行数跟列数。
常用的方法：
1、	append(String text)：在文本结尾追加自定义的文本。
2、	insert(String text,int begin)：在指定的位置插入自定义文本
3、	replaceRange(String text,int begin,int end)：将指定范围内的文本替换为自定义的文本
4、	setRows(int rows)：设置文本的行数
5、	setColumns(int columns)：设置文本的列数
举例1：
package com.langsin.awt;

import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.TextArea;

public class TextAreaDemo extends Frame {
	TextArea textArea1 = new TextArea();
	TextArea textArea2 = new TextArea("Second", 3 , 15);
	TextArea textArea3 = new TextArea("Third",2 , 10);
	TextArea textArea4 = new TextArea("Fourth",2 , 10 ,TextArea.SCROLLBARS_BOTH);
	TextAreaDemo(){
		this.setLayout(new FlowLayout());
		this.textArea2.replaceRange("Hello World", 0, 5);
		this.textArea4.insert(" 你好 ", 6);
		this.add(textArea1);
		this.add(textArea2);
		this.add(textArea3);
		this.add(textArea4);
		this.setSize(400, 400);
		this.setLocation(100, 200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new TextAreaDemo();
	}
}
12.3.6 Checkbox（复选框/单选按钮）
常用的构造方法：
1、	Checkbox()：创建一个复选框
2、	Checkbox(String text)：创建一个复选框，并自定义标签
3、	Checkbox(String text,CheckboxGroup group,boolean state)：创建一个复选框，并将其加入到一个复选框组中，设置复选框是否是被选中，加入到复选框组中的复选框将变成单选。
4、	Checkbox(String text,boolean state)：创建一个复选框，并设置其是否被选中
常用的方法：
1、	setCheckboxGroup(CheckboxGroup group)：将一个复选框加入大一个组中去，将其变为一个单选
2、	setLabel(String label)：为复选框添加一个文本标签
3、	setState(boolean b)：设置浮选框的状态，是否被选中。
举例1：
package com.langsin.awt;

import java.awt.Checkbox;
import java.awt.CheckboxGroup;
import java.awt.Frame;
import java.awt.GridLayout;
public class CheckboxDemo extends Frame {
	CheckboxGroup group = new CheckboxGroup();
	Checkbox box1 = new Checkbox("First", group, false);
	Checkbox box2 = new Checkbox("Second",group, false);
	Checkbox box3 = new Checkbox("Third",group, false);
	Checkbox box4 = new Checkbox("Fourth", false);
	Checkbox box5 = new Checkbox("Fifth", false);
	CheckboxDemo(){
		this.setLayout(new GridLayout(3,2));
		this.box3.setCheckboxGroup(null);
		this.box4.setLabel("第四个");
		this.box5.setState(true);
		this.add(box1);
		this.add(box2);
		this.add(box3);
		this.add(box4);
		this.add(box5);
		this.setSize(300,200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new CheckboxDemo();
	}
}
12.3.7 List（列表框）
常用的构造函数：
1、	List()：创建一个空的列表框
2、	List(int rows)：创建一个空的列表框，并设置其行数
3、	List(int rows,boolean multipleModal)：创建一个空的列表框，并设置其是否使用多选模式。
常用的方法：
1、	add(String item)：为列表框追加项目
2、	add(String item,int index)：在列表框的index位置添加项目，如果此位置上已有项目，则已有的项目以及项目后面的内容相应的向后移动一个位置。
3、	clear()：清除列表框的所有项目
4、	countItems()：返回列表框的项目总数
5、	delItem(int index)：在列表框的index位置处，删除项目
6、	delItem(int start,int end)：删除从列表框的start位置开始到end结束的所有项目
7、	deselect(int index)：排除已选中项目的index位置上的项目
8、	getSelectedItem()：返回String值，返回一个选中的项目
9、	getSelectedItems()：返回String[]数组，返回所有被选中的项目
10、removeAll()：清除列表框的所有项目
11、select(int index)：选中列表框index位置上的项目
12、setMultipleMode(boolean b)：设置是否采用多行选择模式
举例1：
package com.langsin.awt;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.List;
public class ListDemo extends Frame {
	private List list = new List(10,true);
	private List list2 = new List(6);
	ListDemo(){
		this.list.add("apple");
		this.list.add("orange");
		this.list.add("banana",1);
		this.list.setMultipleMode(false);
		this.list2.add("1111");
		this.list2.add("2222");
		this.setLayout(new FlowLayout());
		this.add(this.list);
		this.add(this.list2);
		this.setSize(400, 400);
		this.setLocation(100, 100);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new ListDemo();
	}
}

实例2：
package com.langsin.awt;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.border.TitledBorder;

public class ListDemo extends JFrame {
	public ListDemo(){
		super("点菜系统");
		this.setBounds(100, 100, 800, 500);
		this.setLayout(null);
		this.getContentPane().setBackground(Color.WHITE);
		this.setResizable(false);
		
		Font font = new Font("楷体",Font.BOLD,13);
		
		JButton btn1 = new JButton(new ImageIcon("./image/fish.jpg"));
		btn1.setBounds(20, 40, 140, 100);
		btn1.setText("水煮鱼 ￥50");
		btn1.setHorizontalTextPosition(JButton.CENTER);
		btn1.setVerticalTextPosition(JButton.BOTTOM);
		btn1.setFont(font);
		this.add(btn1);
		
		JButton btn2 = new JButton(new ImageIcon("./image/liji.jpg"));
		btn2.setBounds(180, 40, 140, 100);
		btn2.setText("红烧里脊 ￥30");
		btn2.setHorizontalTextPosition(JButton.CENTER);
		btn2.setVerticalTextPosition(JButton.BOTTOM);
		btn2.setFont(font);
		this.add(btn2);
		
		JButton btn3 = new JButton(new ImageIcon("./image/paigu.jpg"));
		btn3.setBounds(340, 40, 140, 100);
		btn3.setText("红烧排骨 ￥80");
		btn3.setHorizontalTextPosition(JButton.CENTER);
		btn3.setVerticalTextPosition(JButton.BOTTOM);
		btn3.setFont(font);
		this.add(btn3);
		
		//======================================
		JButton btn4 = new JButton(new ImageIcon("./image/tudousi.jpg"));
		btn4.setBounds(20, 160, 140, 100);
		btn4.setText("土豆丝 ￥10");
		btn4.setHorizontalTextPosition(JButton.CENTER);
		btn4.setVerticalTextPosition(JButton.BOTTOM);
		btn4.setFont(font);
		this.add(btn4);
		
		JButton btn5 = new JButton(new ImageIcon("./image/qiezi.jpg"));
		btn5.setBounds(180, 160, 140, 100);
		btn5.setText("风味茄子 ￥15");
		btn5.setHorizontalTextPosition(JButton.CENTER);
		btn5.setVerticalTextPosition(JButton.BOTTOM);
		btn5.setFont(font);
		this.add(btn5);
		
		JButton btn6 = new JButton(new ImageIcon("./image/xiaren.jpg"));
		btn6.setBounds(340, 160, 140, 100);
		btn6.setText("清炒虾仁 ￥20");
		btn6.setHorizontalTextPosition(JButton.CENTER);
		btn6.setVerticalTextPosition(JButton.BOTTOM);
		btn6.setFont(font);
		this.add(btn6);
		//======================================
		
		JButton btn7 = new JButton(new ImageIcon("./image/xiqin.jpg"));
		btn7.setBounds(20, 280, 140, 100);
		btn7.setText("西芹 ￥10");
		btn7.setHorizontalTextPosition(JButton.CENTER);
		btn7.setVerticalTextPosition(JButton.BOTTOM);
		btn7.setFont(font);
		this.add(btn7);
		
		final Vector<String> listData = new Vector<String>();
		final JList<String> list = new JList<String>(listData);
		list.setBorder(BorderFactory.createTitledBorder("已点菜单"));
		list.setBounds(560, 40, 200, 360);
		list.setFont(font);
		TitledBorder border = (TitledBorder)list.getBorder();
		Font font1 = new Font("楷体",Font.BOLD,15);
		border.setTitleFont(font1);
		border.setTitleColor(Color.RED);
		this.add(list);
		
		final JLabel monLab = new JLabel("当前金额：0￥");
		monLab.setFont(font1);
		monLab.setBounds(560, 420, 300, 30);
		this.add(monLab);
		
		ActionListener action = new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				JButton btn = (JButton)e.getSource();
				String text = btn.getText();
				int index = text.indexOf("￥");
				String itemName = text.substring(0,index).trim();
				int money = Integer.parseInt(text.substring(index+1));
				boolean flag = false;
				int itemIndex = -1;
				for(int i=0;i<listData.size();i++){
					if(listData.get(i).contains(itemName)){
						itemIndex = i;
						flag = true;
						break;
					}
				}
				if(flag){
					String item = listData.get(itemIndex);
					int x_index = item.indexOf("X");
					int num = Integer.parseInt(item.substring(x_index+1))+1;
					item = item.substring(0,x_index+1)+num;
					listData.set(itemIndex, item);
				}else{
					String item = itemName + " 	X1";
					listData.add(item);
				}
				String labelText = monLab.getText();
				int begin = labelText.indexOf("：");
				int end = labelText.indexOf("￥");
				int currentMon = Integer.parseInt(labelText.substring(begin+1,end));
				int totalMon = currentMon + money;
				monLab.setText(labelText.substring(0,begin+1)+totalMon+"￥");
				list.updateUI();
			}
		};
		btn1.addActionListener(action);
		btn2.addActionListener(action);
		btn3.addActionListener(action);
		btn4.addActionListener(action);
		btn5.addActionListener(action);
		btn6.addActionListener(action);
		btn7.addActionListener(action);
		
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	
	public static void main(String[] args) {
		new ListDemo();
	}
}
12.3.8 Choice（下拉框）
常用的构造方法：
Choice()：创建一个下拉框
常用的方法：
1、	addItem(String item)：为选择框添加一个项目。
2、	getItem(int index)：返回下拉框中index位置上的项目的文本标签
3、	getItemCount()：返回下拉框中所有的项目总数。
4、	getSelectedItem()：返回以选中的项目的文本标签
5、	insert(String item,int index)：在index位置插入文本标签为item的项目
6、	remove(int index)：删除index位置上的项目。
7、	removeAll()：删除所有项目。
8、	select(int index)：选中index位置上的项目。
举例1：
package com.langsin.awt;

import java.awt.Choice;
import java.awt.FlowLayout;
import java.awt.Frame;

public class ChoiceDemo extends Frame {
	private Choice ch1 = new Choice();
	ChoiceDemo(){
		this.ch1.getSelectedItem();
		this.ch1.add("1111");
		this.ch1.add("2222");
		this.ch1.add("3333");
		this.ch1.add("4444");
		this.setLayout(new FlowLayout());
		this.add(this.ch1);
		this.setSize(300, 300);
		this.setLocation(100, 200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new ChoiceDemo();
	}
}
12.3.9 Dialog（对话框）
Dialog是Windows类的子类，是一个容器类，属于特殊组件。对话框是可以独立存在的顶级窗口，用法与普通窗口没什么区别。使用对话框时需注意以下两点：
?	对话框通常依赖于其他窗口，即含有一个父窗口（parent）
?	对话框有非模式（non-modal）和模式（modal）两种，当某个模式对话框被打开之后，该模式对话框总是位于parent之上；模式对话框被关闭之前，它的依赖窗口无法获得焦点。
Dialog对话框有多个重载的构造器，参数如下：
?	owner：指定该对话框所依赖的窗口，即可以是窗口，也可以是对话框。
?	title：指定该对话框的窗口标题
?	modal：指定该对话框是否是模式的，是Boolean值，true表示模式，false表示非模式。
举例1：
package com.langsin.awt;
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Dialog;
import java.awt.Frame;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class Test {
	// 创建一个父窗体
	static Frame frame = new Frame("测试窗口");
	// 创建两个Dialog对话框，一个为模式，一个为非模式
	static Dialog d1 = new Dialog(frame, "模式对话框", true);
	static Dialog d2 = new Dialog(frame, "非模式对话框", false);
			
	public static void main(String[] args) {
		frame.setBounds(100, 100, 400, 400);
		d1.setBounds(200, 200, 100, 100);
		d2.setBounds(300, 300, 100, 100);
		// 创建两个按钮，通过按钮事件将窗体显示出来
		Button b1 = new Button("模式对话框");
		Button b2 = new Button("非模式对话框");
		// 为了区分模式与非模式的区别，添加一个文本域进行验证
		TextField  text = new TextField(40);
		// 为按钮加上事件，通过事件将模式对话框调用出来
		b1.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				d1.setVisible(true);
			}
		});
		b2.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				d2.setVisible(true);
			}
		});
		frame.add(text,BorderLayout.NORTH);
		frame.add(b1,BorderLayout.EAST);
		frame.add(b2,BorderLayout.WEST);
		frame.pack();
		frame.setVisible(true);
	}
}
12.3.10 FileDialog（文件对话框）
	FileDialog是一个文件对话框，它是Dialog的子类，用于打开或者保存文件。FileDialog提供了几个构造器，分别支持parent、title、mode三个构造参数，其中parent、title指定文件对话框的所属父窗口和标题；mode指定该窗口用于打开文件或保存文件，此参数支持两个值：FileDialog.LOAD、FileDialog.SAVE。
	FileDialog提供了两个方法来获取被打开/保存文件的路径。
?	getDirectory()：获取FileDialog被打开/保存文件的绝对路径。
?	getFile()：获取FileDialog被打开/保存文件的文件名。
举例1：
public class Test {
	// 创建一个父窗体
	static Frame frame = new Frame("测试窗口");
	// 创建两个FileDialog对话框，一个为模式，一个为非模式
	static FileDialog d1 = new FileDialog(frame, "选择需要打开的文件", FileDialog.LOAD);
	static FileDialog d2 = new FileDialog(frame, "选择需要保存的文件", FileDialog.SAVE);
			
	public static void main(String[] args) {
		frame.setBounds(100, 100, 400, 400);
		d1.setBounds(200, 200, 100, 100);
		d2.setBounds(300, 300, 100, 100);
		// 创建两个按钮，通过按钮事件将FileDialog显示出来
		Button b1 = new Button("打开文件");
		Button b2 = new Button("保存文件");
		// 为按钮加上事件，通过事件将文件对话框调用出来
		b1.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				d1.setVisible(true);
				// 打印要保存的文件的路径，以及文件的名称
				System.out.println(d1.getDirectory()+"========="+d1.getFile());
			}
		});
		b2.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				d2.setVisible(true);
				// 打印要保存的文件的路径，以及文件的名称
				System.out.println(d1.getDirectory()+"========="+d1.getFile());
			}
		});
		frame.add(b1,BorderLayout.EAST);
		frame.add(b2,BorderLayout.WEST);
		frame.pack();
		frame.setVisible(true);
	}
}
12.4 布局管理器
	为了使生成的图形用户界面具有良好外观与运行平台没有任何关系，Java提供了布局管理器这个工具类来管理组件在容器中的布局，而不使用直接设置组件位置和大小的方式。
	例如：Lable lable = new Lable(“Hello World”)；如果让lable标签能够刚好容纳Hello World字符串，也就是实现该标签的最佳大小，即：在Windows平台中可能应该设置长100px，高20px；而在Unix系统上需要设置长120px；高24px；如果让程序员去手动控制每个组件的大小、位置，这将给编程带来巨大的困难，为了解决这个问题，Java提供了LayoutManager布局管理器类，LayoutManager可以根据运行平台来调整组件的大小，程序员要做的是就是为容器选择合适的布局管理器。
	所有的AWT容器都有默认的布局管理器，如果没有为容器指定布局管理器，则该容器使用默认的布局管理器。为容器指定布局管理器通过调用容器的setLayout(LayoutManager lm)方法来完成。
	AWT提供了FlowLayout、BorderLayout、GridLayout、GridBagLayout、CardLayout5个常用的布局管理器，Swing还提供了一个BoxLayout布局管理器。
12.4.1 FlowLayout布局管理器
	在FlowLayout（浮动布局管理器）布局管理器中，组件像水流一样向某方向流动（排列），遇到障碍（边界）就折回，重头开始排列。在默认情况下，FlowLayout布局管理器从左向右排列所有组件，遇到边界就会折回下一行重新开始。
	FlowLayout有3个常用的构造方法：
?	FlowLayout()：使用默认的对齐方式及默认的垂直间距、水平间距创建FlowLayout布局管理器。
?	FlowLayout(int align)：使用指定的对齐方式及默认的垂直间距、水平间距创建FlowLayout布局管理器。
?	FlowLayout(int align,int hgap,int vgap)：使用指定的对齐方式以及指定的垂直间距、水平间距创建一个FlowLayout布局管理器。
在Panel（面板）和Applet（Java小应用程序）中默认为使用FlowLayout布局管理器，Frame默认使用BorderLayout布局管理器，下面将使用FlowLayout布局管理器来管理Frame容器中的组件。
举例1：
	public static void main(String[] args) {
		//创建一个窗口
		Frame frame = new Frame("测试窗体");
		frame.setLayout(new FlowLayout(FlowLayout.LEFT, 20, 10));
		for(int i=0;i<5;i++){
			frame.add(new Button("按钮"+(i+1)+"号"));
		}
		//设置窗体的最佳大小，如果子组件未显示开，则适当的将包含组件的容器加宽或加高
		frame.pack();
		//将窗体显示出来
		frame.setVisible(true);
	}
举例2：
public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("测试窗口");
		// 创建一个浮动布局管理器，并且指定容器中的组件的排列方式是居中排列，同时
		// 组件之间的水平间隔与垂直间隔为10个像素
		FlowLayout fl = new FlowLayout(FlowLayout.CENTER, 10, 10);
		// 为窗体设置浮动布局管理器
		frame.setLayout(fl);
		// 添加按钮组件
		frame.add(new Button("button1"));
		frame.add(new Button("button2"));
		frame.add(new Button("button3"));
		frame.add(new Button("button4"));
		frame.add(new Button("button5"));
		frame.add(new Button("button6"));
		// 设置窗体的显示位置，以及窗体容器的宽度与高度
		frame.setBounds(40, 40, 400, 400);
		frame.setVisible(true);
	}
12.4.2 BorderLayout布局管理器
BorderLayout（边界布局管理器）将容器分为EAST、SOUTH、WEST、NORTH、CENTER5个区域，普通组件可以被放置在这个5个区域的任意一个里面。
改变BorderLayout的容器大小时，NORTH、SOUTH会在水平方向上调整，而EAST、WEST在垂直方向上调整，CENTER会根据调整在水平、垂直方向上都进行调整。使用BorderLayout布局管理器时需注意以下两点：
1、向使用BorderLayout布局管理器的容器中添加组件时，需要指定要添加到哪个区域中。如果没有指定添加哪个区域中，则默认添加到中间区域中。
2、如果向同一个区域中添加多个组件时，后放入的组件会覆盖先放入的组件。
Frame、Dialog、ScrollPane默认使用BorderLayout布局管理器，BorderLayout有如下两个构造器。
?	BorderLayout()：使用默认的水平间距、垂直间距创建BorderLayout布局管理器。
?	BorderLayout(int hgap,int vgap)：使用指定的水平间距、垂直间距创建BorderLayout布局管理器。
使用BorderLayout布局管理器时，应该使用BorderLayout类的几个静态常量来指定组件添加到哪个区域内。对应的常量为：EAST、SOUTH、WEST、NORTH、CENTER。
举例1：
	public static void main(String[] args) {
		//创建一个窗口
		Frame frame = new Frame("测试窗体");
		//为窗体创建一个边界布局管理器，同时指定边界的水平方向上的组件之间的间距
//与垂直方向上组件之间的间距
		frame.setLayout(new BorderLayout(5, 5));
		//向北面的边界中添加一个按钮组件
		frame.add(new Button("北面"), BorderLayout.NORTH);
		//向西面的边界中添加一个按钮组件
		frame.add(new Button("西面"), BorderLayout.WEST);
		//向中间的区域内添加一个按钮组件
		frame.add(new Button("中央"), BorderLayout.CENTER);
		//向东面的区域内添加一个按钮组件
		frame.add(new Button("东面"), BorderLayout.EAST);
		//向南面的区域内添加一个按钮组件
		frame.add(new Button("南面"), BorderLayout.SOUTH);
		//将窗体变得更合适一点
		frame.pack();
		frame.setVisible(true);
	}
使用BorderLayout布局管理器时，每个区域的组件都会尽可能大的去占据整个区域，BorderLayout最多只能放置5个组件，但可以放置少于5个组件，如果某个区域没有放置组件，该区域并不会出现空白，旁边的组件会自动占据该区域，从而保证窗口有较好的外观。
	另外，虽然BorderLayout布局管理器最多只能放5个组件，但因为容器也是一个组件，所以我们可以先把组件放到一个容器内，在把容器放到BorderLayout布局管理器中。
	举例2：
	public static void main(String[] args) {
		//创建一个窗口
		Frame frame = new Frame("测试窗体");
		//为窗体创建一个边界布局管理器，同时指定边界的水平方向上的组件之间的间距与
//垂直方向上组件之间的间距
		frame.setLayout(new BorderLayout(5, 3));
		//创建一个面板容器
		Panel panel = new Panel();
		//在面板中添加一个文本框
		panel.add(new TextField(30));
		//将面板添加到窗体中
		frame.add(panel,BorderLayout.NORTH);
		//再创建一个面板，添加按钮
		Panel butPanel = new Panel();
		//设置面板的宽度与高度
		butPanel.setSize(5, 20);
		String[] names = {"0","1","2","3","4","5","6","7","8","9","+","-","*","/","="};
		for(String flag : names){
			butPanel.add(new Button("   "+flag+"   "));
		}
		//将按钮面板添加到窗体中去
		frame.add(butPanel,BorderLayout.CENTER);
		frame.pack();
		frame.setVisible(true);
	}
12.4.3 GridLayout网格布局管理器
	GridLayout（网格布局管理器）布局管理器将容器分割成纵横分隔的网格，每个网格所占的区域大小相同，当向使用GridLayout布局管理器的容器中添加组件时，默认为从左向右，从上向下依次添加到每个网格中，与FlowLayout不同的是，放置在GridLayout布局管理器中的各个组件的大小由组件所处的区域来决定。
	GridLayout有如下两个构造器：
?	GridLayout(int rows,int cols)：采用指定的行数与列数，以及默认的横向间距、纵向间距将容器分割成多个网格。
?	GridLayout(int rows,int cols,int hgap,int vgap)：采用指定的行数、列数，以及指定的水平间距，垂直间距将容器分割成多个网格。
举例1：
	public static void main(String[] args) {
		//创建一个窗口
		Frame frame = new Frame("计算器");
		//创建一个面板容器
		Panel panel = new Panel();
		//在面板中添加一个文本框
		panel.add(new TextField(30));
		//将面板添加到窗体中
		frame.add(panel,BorderLayout.NORTH);
		//再创建一个面板，添加按钮
		Panel butPanel = new Panel(new GridLayout(3,5,4,4));
		//设置面板的宽度与高度
		butPanel.setSize(5, 20);
		String[] names = {"0","1","2","3","4","5","6","7","8","9","+","-","*","/","="};
		for(String flag : names){
			butPanel.add(new Button("   "+flag+"   "));
		}
		//将按钮面板添加到窗体中去
		frame.add(butPanel);
		frame.pack();
		frame.setVisible(true);
	}
12.4.4 GridBagLayout网格包布局管理器
	GridBagLayout（网格包布局管理器）布局管理器的功能最强大，同时也最复杂，与GridLayout布局管理器不同的是，在GridBagLayout布局管理器中，一个组件可以跨一个或多个网格，并可以设置各个网格的大小互不相同，从而增加了布局的灵活性。当窗体的大小发生变化时，GridBagLayout布局管理器也可以准确的控制窗口各部分的拉伸。
	为了处理GridBagLayout中组件的大小，跨越性，Java提供了GridBagConstraints对象，该对象与特定的组件关联，用于控制该GUI组件的大小、跨越性。
GridBagLayout布局管理器的使用方式如下：
1、	创建GridBagLayout布局管理器对象，并指定容器使用该布局管理器。
GridBagLayout gridBagLayout = new GridBagLayout();
container.setLayout(gridBagLayout);
2、	创建GridBagConstrains对象，并设置该对象的相关属性，此对象用于控制要添加的GUI组件的大小及跨越性。
GridBagConstraints gbc = new GridBagConstraints();
gbc.gridx = 2; //设置受该对象控制的GUI组件位于网格中横向索引的位置
gbc.gridy = 1; //设置受该对象控制的GUI组件位于网格中纵向索引的位置
gbc.gridwidth = 2; //设置受该对象控制的GUI组件横向跨越多少个网格
gbc.gridhight = 1; //设置受该对象控制的GUI组件纵向跨越多少个网格
3、	调用GridBagLayout对象的方法来建立GridBagConstraints对象和受控组件之间的关联。
gridBagLayout.setConstraints(comp,gbc);
4、	添加组件，与普通布局管理器添加组件的方法完全一致。
container.add(comp);
注意：如果需要向一个容器中添加多个GUI组件，则需要重复执行2-4的步骤，GridBagConstraints对象可以重复使用，因此在程序中只需要创建此类的一个实例对象即可。每次添加GUI组件时，重新修改GridBagConstraints对象的属性即可。
使用GridBagLayout布局管理器，重点在于GridBagConstraints对象，它能精确控制每个GUI组件与容器之间的布局关系，该类具有如下属性：
?	gridx、gridy：设置受该对象控制的GUI组件从左上角开始在网格的横向索引、纵向索引。这两个值还可以是GridBagConstraints.RELATIVE（默认值），表示当前组件紧跟随在上一个组件之后。
?	gridwidth、gridheight：设置受该对象控制的GUI组件横向、纵向跨越多少个网格，两个属性值默认都是1，表示不进行跨越。如果设置这两个的属性值为：GridBagConstraints.REMAINDER，表示受该对象控制的GUI组件是横向、纵向上的最后一个组件。
?	fill：设置受该对象控制的GUI组件如何占据空白区域。
?	GridBagConstraints.NONE：表示组件不进行扩大。
?	GridBagConstraints.HORIZONTAL：GUI组件水平扩大占据空白区域
?	GridBagConstraints.VERTICAL：GUI组件垂直扩大占据空白区域
?	GridBagConstraints.BOTH：GUI组件水平、垂直扩大占据空白区域
?	ipadx、ipady：设置GUI组件在区域内横向、纵向的大小。如果设置了这两个属性，则组件会在默认的宽度和高度的基础上增加，最小宽度+ipdax*2个像素，最小高度+ipady*2个像素。
?	insets：设置受该对象控制的GUI组件的外部填充的大小，即该组件边界和显示区域边间之间的距离。
?	anchor：设置受该对象控制的GUI组件在其显示区域的布局方式。
?	GridBagConstraints.CENTER：居中显示
?	GridBagConstraints.NORTH：上中显示（即：北面）
?	GridBagConstraints.NORTHWEST：左上显示（西北角）
?	GridBagConstraints.NORTHEAST：右上显示（东北角）
?	GridBagConstraints.SOUTH：下中显示（南面）
?	GridBagConstraints.SOUTHWEST：左下显示（西南角）
?	GridBagConstraints.SOUTHEAST：右下显示（东南角）
?	GridBagConstraints.WEST：左中显示（西面）
?	GridBagConstraints.EAST：右中显示（东面）
?	weightx、weighty：用来设置窗口变大时，各组件跟着变大的比例，当数字越大，表示组件能到更多的空间，默认值为0。
举例1：
public static void main(String[] args) {
		//创建一个窗口
		Frame frame = new Frame("测试窗口");
		//创建一个网个包布局管理器
		GridBagLayout gb = new GridBagLayout();
		frame.setLayout(gb);
		//创建一个网格包布局管理器的约束对象
		GridBagConstraints gbc = new GridBagConstraints();
		//设置所有的组件都可以随着窗口的扩大而扩大
		gbc.fill = GridBagConstraints.BOTH;
		//设置组件在水平位置上的扩展权重
		gbc.weightx = 1;
		//创建一个组件，并将组件与约束对象建立管理，最后将组件加入到容器中
		for(int i=0;i<4;i++){
			Button button = new Button("按钮"+i);
			gb.setConstraints(button, gbc);
			frame.add(button);
		}
		//设置下一个组件为容器中横向位置上的最后一个组件
		Button button = new Button("按钮4");
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gb.setConstraints(button, gbc);
		frame.add(button);
		//创建一个新的组件，设置此组件在水平位置上不会进行扩展，此组件为新的一行的开始位置
		button = new Button("按钮5");
		gbc.weightx = 0;
		gb.setConstraints(button, gbc);
		frame.add(button);
		//设置下一个组件，此组件占据后面以为网格
		button = new Button("按钮6");
		gbc.gridwidth = 2;
		gbc.gridheight = 2;
		gb.setConstraints(button, gbc);
		frame.add(button);
		//设置下一个组件，此组件占据后面以为网格
		button = new Button("按钮7");
		//gbc.gridwidth = 3;
		gbc.gridheight = 2;
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gb.setConstraints(button, gbc);
		frame.add(button);
		//创建一个新的按钮放置在第三行
		button = new Button("按钮8");
		gbc.gridwidth = 1;
		//设置此行的组件跨两行
		gbc.gridheight = 2;
		gbc.weighty = 1;
		gb.setConstraints(button, gbc);
		frame.add(button);
		gbc.weighty = 0;
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		//设置此行的组件重新跨一行
		gbc.gridheight = 1;
		button = new Button("按钮9");
		gb.setConstraints(button, gbc);
		frame.add(button);
		button = new Button("按钮10");
		gb.setConstraints(button, gbc);
		frame.add(button);
		frame.pack();
		frame.setVisible(true);
	}
12.4.5 CardLayout布局管理器
CardLayout（卡片布局管理器）布局管理器以时间来管理它里面的组件，它将加入到容器中的组件看做一叠卡片，每次只能看到最上面的那个组件。CardLayout提供了两个构造器：
?	CardLayout()：创建一个默认的CardLayout布局管理器。
?	CardLayout(int hgap,int vgap)：通过指定卡片与容器左右边界的间距（hgap）、上下边界（vgap）的间距来创建CardLayout布局管理器。
CardLayout用于控制组件可见的5个常用方法：
?	first(Container target)：显示容器target中的第一张卡片
?	last(Container target)：显示容器target中的最后一张卡片
?	previous(Container target)：显示容器target中的前一张卡片
?	next(Container target)：显示容器target中的下一张卡片
?	show(Container target,String name)：显示容器target中指定名称的卡
举例1：
public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("测试窗口");
		// 创建一个卡片布局管理器
		final CardLayout cl = new CardLayout();
		// 创建一个panel面板使用卡片布局管理器
		final Panel panel1 = new Panel();
		panel1.setLayout(cl);
		// 往面板中加入几个按钮
		for (int i = 0; i < 5; i++) {
			panel1.add("按钮" + (i + 1), new Button("按钮" + (i + 1)));
		}
		// 将此面板加入到窗体中
		frame.add(panel1);
		// 再创建一个面板，加几个按钮，同时对按钮添加事件机制
		Panel panel2 = new Panel();
		Button button = new Button("上一张");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cl.previous(panel1);
			}
		});
		panel2.add(button);

		// 在面板中添加第二个按钮
		button = new Button("下一张");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cl.next(panel1);
			}
		});
		panel2.add(button);

		// 在面板中添加第三个按钮
		button = new Button("第一张");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cl.first(panel1);
			}
		});
		panel2.add(button);

		// 在面板中添加第四个按钮
		button = new Button("最后张");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cl.last(panel1);
			}
		});
		panel2.add(button);

		// 在面板中添加第五个按钮
		button = new Button("第三张");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cl.show(panel1,"按钮3");
			}
		});
		panel2.add(button);
		//在往窗体中加入第二个组件及之后的组件必须制定位置，不然会将之前的组件覆盖掉
		frame.add(panel2,BorderLayout.SOUTH);
		frame.pack();
		frame.setVisible(true);
	}
12.4.6 绝对定位
	Java也可以对GUI组件进行绝对定位，在Java容器中采用绝对定位的步骤如下：
1、	将Container的布局管理器设置为null：container.setLayout(null)
2、	向容器中添加组件时，先调用setBounds()或setSize()方法来设置组件的大小、位置，或者直接创建GUI组件时通过构造参数指定该组件的大小、位置，然后将该组件添加到容器中。
举例1：
public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("测试窗口");
		//设置窗体不使用布局管理器
		frame.setLayout(null);
		//创建一个按钮，同时指定它的绝对位置，在X坐标上的值为40，Y坐标上的值为40
		//按钮的宽度为50，高度为20，
		Button button1 = new Button("按钮1");
		button1.setBounds(40, 40, 50, 20);
		frame.add(button1);
		//创建一个按钮2，同时指定它的绝对位置，将按钮放置在第一个按钮的下面
		//则X坐标保持一致，Y坐标在原来的基础上加上第一个按钮的高度
		Button button2 = new Button("按钮2");
		button2.setBounds(40, 60, 50, 20);
		frame.add(button2);
		//设置窗体的出现位置，以及窗体的宽度，高度
		frame.setBounds(40, 40, 600, 600);
		frame.setVisible(true);
	}
12.4.7 BoxLayout布局管理器
GridBagLayout（网格包布局管理器）虽然功能强大，但是使用复杂，所以在swing中引入一个新的布局管理器：BoxLayout（盒子布局管理器），它保留了GridBagLayout的很多优点，同时又比它使用简单。BoxLayout可以在垂直和水平两个方向上摆放GUI组件，BoxLayout提供了一个简单的构造器：
?	BoxLayout(Container c,int axis)：创建一个基于指定容器c的盒子布局管理器，该布局管理器的组件按照axis（轴线）方向排列。其中axis有BoxLayout.X_AXIS（X轴）和BoxLayout.Y_AXIS（Y轴）两个方向。

举例1：
	public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("测试窗口");
		// 创建一个基于frame窗体的盒子布局管理器，同时指定容器中的组件排放顺序是按照Y轴方向排列
		BoxLayout bl = new BoxLayout(frame,BoxLayout.Y_AXIS);
		frame.setLayout(bl);
		frame.add(new Button("按钮1"));
		frame.add(new Button("按钮2"));
		//设置窗体的显示位置，以及宽度及高度
		frame.setBounds(40, 40, 400, 400);
		frame.setVisible(true);
	}
BoxLayout布局管理器通常会与Box容器结合使用，Box是一个特殊的容器，跟Panel面板容器有点类似，都不能单独存在，必须依附于其他容器存在。但Box默认使用BoxLayout布局管理器。Box提供了如下两个静态方法来创建Box对象。
?	createHorizontalBox()：创建一个水平排列组件的Box容器。
?	createVerticalBox()：创建一个垂直排列组件的Box容器。
Box容器创建之后，就可以使用Box容器来盛放普通的GUI组件，然后将box组件添加到其他容器中，形成整体的窗口布局。
举例2：
	public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("测试窗口");
		// 创建一个Box容器，此容器中组件的排放顺序是水平方向的
		Box box1 = Box.createHorizontalBox();
		box1.add(new Button("按钮1"));
		box1.add(new Button("按钮2"));
		box1.add(new Button("按钮3"));
		// 创建一个Box容器，此容器中组件的排放顺序是垂直方向的
		Box box2 = Box.createVerticalBox();
		box2.add(new Button("按钮4"));
		box2.add(new Button("按钮5"));
		// 将两个box容器添加到frame窗体中，frame默认使用边界布局管理器
		frame.add(box1,BorderLayout.NORTH);
		frame.add(box2,BorderLayout.SOUTH);
		frame.setBounds(40, 40, 400, 400);
		frame.setVisible(true);
	}
BoxLayout没有提供设置组件之间间距的构造器和方法，BoxLayout采用另外一种方式来控制组件的间距。BoxLayout使用Glue（橡胶）、Struct（支架）、RigidArea（刚性区域）的组件来控制组件之间的间距。Glue可以在水平、垂直两个方向上进行拉伸，Struct可以在水平或者垂直方向上进行拉伸，RigidArea表示不可拉伸。
Box提供了5个静态方法来创建Glue、Struct、RigidArea。
?	createHorizontalGlue()：创建一个水平Glue。
?	createVerticalGlue()：创建一个垂直Glue
?	createHorizontalStruct(int width)：创建一个指定宽度的水平struct，可在水平方向上进行拉伸
?	createVerticalStruct(int height)：创建一个指定高度的垂直struct，可在垂直方向上进行拉伸
?	createRigidArea(Dimension d)：创建一个指定宽度、高度的RigidArea（不可拉伸）

举例2：
	public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("测试窗口");
		// 创建一个水平方向的盒子容器
		Box horizontal = Box.createHorizontalBox();
		horizontal.add(new Button("button1"));
		// 向盒子中添加一个glue橡胶间距
		horizontal.add(Box.createHorizontalGlue());
		horizontal.add(new Button("button2"));
		// 向盒子中添加一个具有10个像素的支架间距
		horizontal.add(Box.createHorizontalStrut(10));
		horizontal.add(new Button("button3"));
		// 创建一个垂直方向上的盒子容器
		Box vertical = Box.createVerticalBox();
		// 向盒子中添加一个垂直方向上的橡胶间距
		vertical.add(Box.createVerticalGlue());
		vertical.add(new Button("button4"));
		// 向盒子中添加一个垂直方向上的支架间距 
		vertical.add(Box.createVerticalStrut(10));
		vertical.add(new Button("button5"));
		// 将盒子容器添加到frame窗体中去
		frame.add(horizontal, BorderLayout.NORTH);
		frame.add(vertical);
		
		frame.setBounds(40, 40, 400, 400);
		frame.setVisible(true);
	}
作业：
利用AWT中所有的组件和布局管理器来组合一个用户的信息注册窗口
举例1：使用绝对定位进行布局，优点定位准确，确定布局繁琐，组件的长度、位置需要计算，组件定位后即使容器大小发生更改，组件位置仍然不会发生变化
	public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("用户注册");
		// 为frame窗体的布局管理设置为null
		frame.setLayout(null);
		// 创建一个Label提示标签，并放置在窗体中，给它一个合适的位置
		Label userNameInfo = new Label("用户名：");
		userNameInfo.setBounds(45, 45, 60, 20);
		// 设置信息标签的文本靠右对其
		userNameInfo.setAlignment(Label.RIGHT);
		// 将标签添加到frame窗体中
		frame.add(userNameInfo);
		
		// 创建一个文本框TextField，并设置它的显示位置，最后添加到窗体中
		TextField userName = new TextField();
		userName.setBounds(110, 45, 140, 20);
		frame.add(userName);
		
		// 创建一个用户输入的密码
		Label userPassInfo = new Label("密码：");
		userPassInfo.setBounds(45, 70, 60, 20);
		// 设置信息标签的文本靠右对其
		userPassInfo.setAlignment(Label.RIGHT);
		frame.add(userPassInfo);
		// 设置用户的密码输入
		TextField userPass = new TextField();
		userPass.setBounds(110, 70, 140, 20);
		userPass.setEchoChar('*');
		frame.add(userPass);
		
		// 设置用户的学历
		Label eductionInfo = new Label("学历：");
		eductionInfo.setBounds(45, 95, 60, 20);
		eductionInfo.setAlignment(Label.RIGHT);
		frame.add(eductionInfo);
		
		// 设置一个下拉列表框用于进行选择
		Choice eductionList = new Choice();
		eductionList.add("请选择");
		eductionList.add("初中");
		eductionList.add("高中");
		eductionList.add("专科");
		eductionList.add("本科");
		eductionList.add("研究生");
		eductionList.add("博士");
		eductionList.setBounds(110, 95, 140, 20);
		frame.add(eductionList);
		
		// 设置用户的性别提示信息
		Label genderInfo = new Label("性别：");
		genderInfo.setBounds(45, 120, 60, 20);
		genderInfo.setAlignment(Label.RIGHT);
		frame.add(genderInfo);
		
		// 设置性别，创建一个复选框组，将复选框添加到组中变成单选按钮
		CheckboxGroup genderGroup = new CheckboxGroup();
		// 创建单独的复选框
		Checkbox male = new Checkbox("男",genderGroup,true);
		male.setBounds(110, 120, 60, 20);
		frame.add(male);
		Checkbox famale = new Checkbox("女",genderGroup,false);
		famale.setBounds(170, 120, 60, 20);
		frame.add(famale);
		
		// 添加多选框提示信息
		Label hobbyInfo = new Label("爱好：");
		hobbyInfo.setBounds(45, 145, 60, 20);
		hobbyInfo.setAlignment(Label.RIGHT);
		frame.add(hobbyInfo);
		
		// 添加多选框
		Checkbox footBall = new Checkbox("足球");
		footBall.setBounds(110, 145, 45, 20);
		frame.add(footBall);
		
		Checkbox basketBall = new Checkbox("篮球");
		basketBall.setBounds(160, 145, 45, 20);
		frame.add(basketBall);
		
		Checkbox volleyBall = new Checkbox("排球");
		volleyBall.setBounds(210, 145, 45, 20);
		frame.add(volleyBall);
		
		// 添加用户选择项
		Label courseInfo = new Label("选修课：");
		courseInfo.setBounds(45, 170, 60, 80);
		courseInfo.setAlignment(Label.RIGHT);
		frame.add(courseInfo);
		
		// 添加列表框
		List courseList = new List(6,true);
		courseList.add("英语");
		courseList.add("高数");
		courseList.add("信管");
		courseList.setBounds(110, 170, 55, 80);
		frame.add(courseList);
		
		//创建一个按钮进行选择
		Button rbutton = new Button(">>");
		rbutton.setBounds(175, 190, 40, 20);
		frame.add(rbutton);
		Button lbutton = new Button("<<");
		lbutton.setBounds(175, 220, 40, 20);
		frame.add(lbutton);
		// 第二选择框
		List selectedList = new List(6,true);
		selectedList.setBounds(230, 170, 55, 80);
		frame.add(selectedList);
		
		// 添加一个用户的的备注信息
		Label noteInfo = new Label("备注：");
		noteInfo.setBounds(45, 260, 60, 80);
		noteInfo.setAlignment(Label.RIGHT);
		frame.add(noteInfo);
		// 添加一个多行文本框
		TextArea area = new TextArea(10, 6);
		area.setBounds(110,260,180,80);
		frame.add(area);
		
		// 添加两个按钮
		Button subButton = new Button("提交");
		subButton.setBounds(85, 360, 60, 20);
		frame.add(subButton);
		
		Button resButton = new Button("重置");
		resButton.setBounds(200, 360, 60, 20);
		frame.add(resButton);
		
		frame.setBounds(40, 40, 400, 400);
		frame.setVisible(true);
	}
举例2：使用网格包布局管理器进行组装，易于改变，但是使用复杂

	public static void main(String[] args) {
		// 创建一个窗口
		Frame frame = new Frame("用户注册");
		// 为frame窗体创建一个网格包布局管理器
		GridBagLayout gbl = new GridBagLayout();
		frame.setLayout(gbl);
		// 创建一个网格包故居管理器的约束对象
		GridBagConstraints gbc = new GridBagConstraints();
		// 设置组件不随着容器的变大而扩大
		gbc.fill = GridBagConstraints.NONE;
		// 设置所有组件与边界之间的间距
		gbc.insets = new Insets(5, 5, 5, 5);
		// 通过约束对象设置下一个组件将要放置的位置
		gbc.gridx = 1;
		gbc.gridy = 1;
		// 设置组件的对齐方式，让组件靠右对齐
		gbc.anchor = GridBagConstraints.EAST;
		// 放置第一个组件Label
		Label userNameInfo = new Label("用户名：");
		gbl.setConstraints(userNameInfo, gbc);
		// 将组件加入到窗体中
		frame.add(userNameInfo);

		// 添加一个文本框输入用户名
		TextField userName = new TextField(20);
		gbc.gridx = 2;
		// 设置组件靠右对齐
		gbc.anchor = GridBagConstraints.WEST;
		// 设置组件在此水平线上为最后一个组件
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbl.setConstraints(userName, gbc);
		frame.add(userName);

		// 添加一个提示信息Label用于显示用户输入密码
		Label userPassInfo = new Label("密码：");
		// 设置组件的位置
		gbc.gridx = 1;
		gbc.gridy = 2;
		gbc.gridwidth = 1;
		// 设置组件靠右对齐
		gbc.anchor = GridBagConstraints.EAST;
		gbl.setConstraints(userPassInfo, gbc);
		// 将组件加入到窗体中
		frame.add(userPassInfo);

		// 添加一个文本框输入用户密码
		TextField userPass = new TextField(20);
		userPass.setEchoChar('*');
		gbc.gridx = 2;
		// 设置组件靠右对齐
		gbc.anchor = GridBagConstraints.WEST;
		// 设置组件在此水平线上为最后一个组件
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbl.setConstraints(userPass, gbc);
		frame.add(userPass);

		// 添加一个学历提示信息
		Label eductionInfo = new Label("学历：");
		// 设置学历Label的放置位置
		gbc.gridwidth = 1;
		gbc.gridx = 1;
		gbc.gridy = 3;
		gbc.anchor = GridBagConstraints.EAST;
		gbl.setConstraints(eductionInfo, gbc);
		frame.add(eductionInfo);

		// 创建一个学历的下拉框
		Choice eductionList = new Choice();
		eductionList.add("请选择");
		eductionList.add("初中");
		eductionList.add("高中");
		eductionList.add("专科");
		eductionList.add("本科");
		eductionList.add("研究生");
		eductionList.add("博士");
		// 设置学历的位置
		gbc.gridx = 2;
		gbc.anchor = GridBagConstraints.WEST;
		// 设置组件在此水平线上为最后一个组件
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbl.setConstraints(eductionList, gbc);
		frame.add(eductionList);

		// 设置用户的性别提示信息
		Label genderInfo = new Label("性别：");
		// 设置此文本提示信息组件的位置
		gbc.gridwidth = 1;
		gbc.gridx = 1;
		gbc.gridy = 4;
		gbc.anchor = GridBagConstraints.EAST;
		gbl.setConstraints(genderInfo, gbc);
		frame.add(genderInfo);

		// 创建单选按钮，并设置其位置
		CheckboxGroup genderGroup = new CheckboxGroup();
		// 创建单独的复选框
		Checkbox male = new Checkbox("男", genderGroup, true);
		Checkbox famale = new Checkbox("女", genderGroup, false);
		// 创建一个容器存放复选框
		Panel panel = new Panel();
		panel.add(male);
		panel.add(famale);
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbc.gridx = 2;
		gbc.anchor = GridBagConstraints.WEST;
		gbl.setConstraints(panel, gbc);
		frame.add(panel);

		// 添加多选框提示信息
		Label hobbyInfo = new Label("爱好：");
		// 设置此文本提示信息组件的位置
		gbc.gridwidth = 1;
		gbc.gridx = 1;
		gbc.gridy = 5;
		gbc.anchor = GridBagConstraints.EAST;
		gbl.setConstraints(hobbyInfo, gbc);
		frame.add(hobbyInfo);

		// 添加复选框
		Panel hobbyPanel = new Panel();
		Checkbox footBall = new Checkbox("足球");
		Checkbox basketBall = new Checkbox("篮球");
		Checkbox volleyBall = new Checkbox("排球");
		hobbyPanel.add(footBall);
		hobbyPanel.add(basketBall);
		hobbyPanel.add(volleyBall);
		// 设置panel容器的位置
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbc.gridx = 2;
		gbc.anchor = GridBagConstraints.WEST;
		gbl.setConstraints(hobbyPanel, gbc);
		frame.add(hobbyPanel);

		// 添加用户选择项
		Label courseInfo = new Label("选修课：");
		// 设置此文本提示信息组件的位置
		gbc.gridwidth = 1;
		gbc.gridx = 1;
		gbc.gridy = 6;
		gbc.anchor = GridBagConstraints.EAST;
		gbl.setConstraints(courseInfo, gbc);
		frame.add(courseInfo);

		// 创建一个面板添加基本组件
		Panel coursePanel = new Panel(new GridLayout(1, 3, 5, 5));
		// 添加列表框，并设置列表的位置
		List courseList = new List(6, true);
		courseList.add("英语");
		courseList.add("高数");
		courseList.add("信管");
		courseList.setMultipleMode(false);
		coursePanel.add(courseList);

		Panel buttonPanel = new Panel(new GridLayout(2, 1, 30, 30));
		// 创建一个按钮进行选择，并设置按钮的位置
		Button rbutton = new Button(">>");
		buttonPanel.add(rbutton);
		// 创建一个按钮进行选择，并设置按钮的位置
		Button lbutton = new Button("<<");
		buttonPanel.add(lbutton);
		coursePanel.add(buttonPanel);

		// 第二选择框，并设置其位置
		List selectedList = new List(6, true);
		selectedList.setMultipleMode(false);
		coursePanel.add(selectedList);

		// 设置panel的面板位置
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbc.gridx = 2;
		gbc.gridy = 6;
		gbc.anchor = GridBagConstraints.WEST;
		gbl.setConstraints(coursePanel, gbc);
		frame.add(coursePanel);

		// 添加用户选择项
		Label noteInfo = new Label("备注：");
		// 设置此文本提示信息组件的位置
		gbc.gridwidth = 1;
		gbc.gridx = 1;
		gbc.gridy = 7;
		gbc.anchor = GridBagConstraints.EAST;
		gbl.setConstraints(noteInfo, gbc);
		frame.add(noteInfo);

		TextArea area = new TextArea(4, 35);
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbc.gridx = 2;
		gbc.anchor = GridBagConstraints.WEST;
		gbl.setConstraints(area, gbc);
		frame.add(area);

		Panel bPanel = new Panel();
		// 添加两个按钮
		Button subButton = new Button("提交");
		bPanel.add(subButton);

		Button resButton = new Button("重置");
		bPanel.add(resButton);
		
		gbc.gridwidth = GridBagConstraints.REMAINDER;
		gbc.gridx = 1;
		gbc.gridy = 9;
		gbc.anchor = GridBagConstraints.CENTER;
		gbl.setConstraints(bPanel, gbc);
		frame.add(bPanel);

		frame.setBounds(40, 40, 500, 500);
		frame.setVisible(true);
	}

12.5 事件处理
在AWT编程中，所有事件必须由特定对象（事件监听器）来处理，Frame和组件并没有事件处理的能力。

12.5.1 Java事件模型的流程
为了使图形界面能够接受用户的操作，必须给各个组件加上事件处理机制。在事件处理的过程中，主要涉及3类对象。
?	Event Source（事件源）：事件发生的场所，通常就是各个组件，例如按钮、窗口、菜单等
?	Event（事件）：事件封装了GUI组件上发生的特定事情，即：用户的一次操作。如果需要获得GUI组件上发生的事件的相关信息，都必须通过Event对象来获得。
?	Event Listener（事件监听器）：负责监听事件源所发生的事件，并对各种事件做出响应处理。
事件由AWT封装成相应的Event对象，该事件会触发事件源上注册的的事件监听器，事件监听器调用对应的事件处理器（事件监听器的实例方法）来做出相应的响应。
举例1：
package com.langsin.awt;
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
public class Test {
	// 创建一个父窗体
	Frame frame = new Frame("测试窗口");
	// 创建一个文本框
	TextField tf = new TextField();
	// 创建一个内部类，此类实现ActionListener接口
	class MyAction implements ActionListener{
		public void actionPerformed(ActionEvent e) {
			System.out.println("用户单击了添加按钮=========");
			tf.setText("Hello World");
		}
	}
	
	public void init(){
		frame.setBounds(150, 150, 400, 400);
		Button button = new Button("单击");
// 为我们的监听器添加一个事件处理对象
		button.addActionListener(new MyAction());
		frame.add(tf,BorderLayout.SOUTH);
		frame.add(button,BorderLayout.NORTH);
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}
12.5.2 事件和事件监听器
外部动作在AWT上进行操作时，系统会自动生成事件对象，这个事件对象就是EventObject子类的实例，该事件对象会触发注册到事件源（组件）上的监听器。
AWT事件机制涉及3个成员：事件源（组件）、事件（EventObject子类对象）和事件监听器（Listener），其中事件源（组件）直接通过new来创建一个AWT组件即可；事件是系统自动产生的，无须程序员来关心。监听器是整个事件处理的核心。
事件监听器必须实现事件监听接口，AWT提供了大量的事件监听器接口用于实现不同类型的事件监听器，用于监听不同类型的事件。AWT中提供了丰富的事件类，用于封装不同组件上发生的特定操作。AWT的事件类都是AWTEvent类的子类，AWTEvent是EventObject的子类。
AWT事件分为两大类：低级事件和高级事件。
1、	低级事件
低级事件是指基于特定动作的事件。
?	ComponentEvent：组件事件，当组件尺寸发生变化、位置发生移动、显示/隐藏状态发生改变触发该事件。
?	ContainerEvent：容器事件，当容器里发生添加组件、删除组件时触发该事件。
?	WindowEvent：窗口事件，当窗口状态发生改变（打开、关闭、最大化、最小化）时触发该事件。
?	FocusEvent：焦点事件，当组件得到焦点或失去焦点时触发该事件。
?	KeyEvent：键盘事件，当按键被按下、松开、单击时触发该事件。
?	MouseEvent：鼠标事件，当进行单击、按下、松开、移动鼠标等动作时触发该事件。
2、	高级事件
高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此事件的组件类。
?	ActionEvent：动作事件，当按钮、菜单项被单击，在TextField中按Enter键是触发该事件。
?	AdjustmentEvent：调节事件，在滑动条上移动滑块以调节数值时，触发该事件。
?	ItemEvent：选项事件，当用于选中某项、或取消选中某项时触发该事件。
?	TextEvent：文本事件，当文本框、文本域里的文本发生改变时触发该事件。
AWT事件继承层次关系图：
 
不同的事件需要使用不同的监听器监听，不同的监听器需要实现不同的监听器接口，当指定事件发生后，事件监听器就会调用所包含的事件处理器来处理。
事件、监听器接口和处理器之间的对应关系
事件	监听器接口	处理器及触发时机
ActionEvent	ActionListener	actionPerformed：按钮、文本框、菜单项被单击时触发
AdjustmentEvent	AdjustmentListener	adjustmentValueChanged：滑块位置发生改变时触发
ContainerEvent	ContainerListener	componentAdded：向容器中添加组件时触发
		componentRemoved：从容器中删除组件时触发
FocusEvent	FocusListener	focusGainer：组件得到焦点时触发
		focusLost：组件失去焦点时触发

ComponentEvent
	
ComponentListener
	componentHidden：组件被隐藏时触发
		componentMoved：组件位置发生改变时触发
		componentResized：组件大小发生改变时触发
		componentShown：组件被显示时触发

KeyEvent	
KeyListener	keyPressed：按下某个按键时触发
		keyReleased：松开某个按键时触发
		keyTyped：单击某个按键时触发




MouseEvent	

MouseListener	mouseClicked：在某个组件上单击鼠标键时触发
		mouseEntered：鼠标进入某个组件时触发
		mouseExited：鼠标离开某个组件时触发
		mousePressed：在某个组件上按下鼠标键时触发
		mouseReleased：在某个组件上松开鼠标键时触发
	MouseMotionListener	mouseDragged：在某个组件上移动鼠标，且按下鼠标键时触发
		mouseMoved：在某个组件上移动鼠标，且没有按下鼠标键时触发
TextEvent	TextListener	textValueChanged：文本组件里的文本发生改变时触发
ItemEvent	ItemListener	itemStateChanged：某项被选中或取消选中时触发



WindowEvent	


WindowListener	windowActivated：窗口被激活时触发。
		windowClosed：窗口调用dispose()即关闭时触发。
		windowClosing：用户单击窗口右上角的“X”按钮时触发
		windowDeactivated：窗口失去激活时触发
		windowDeiconified：窗口被恢复时触发
		windowIconified：窗口最小化时触发
		windowOpened：窗口首次被打开时触发。

举例1：
package com.langsin.awt;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class Test {
	// 创建一个父窗体
	private Frame frame = new Frame("测试窗口");
	// 创建一个文本域
	private TextArea area = new TextArea(6,50);
	// 创建一个内部类，此类实现ActionListener接口
	class MyActionFirst implements ActionListener{
		public void actionPerformed(ActionEvent e) {
			area.append("第一个单击监听器被触发了，事件源是："+e.getActionCommand()+"\n");
		}
	}
	
	class MyActionSecond implements ActionListener{
		public void actionPerformed(ActionEvent e) {
			area.append("单击了"+e.getActionCommand()+"按钮\n");
		}
	}
	
	public void init(){
		frame.setBounds(150, 150, 400, 400);
		frame.add(area);
		MyActionFirst first = new MyActionFirst();
		Button button1 = new Button("按钮1");
		button1.addActionListener(first);
		button1.addActionListener(new MyActionSecond());
		
		Button button2 = new Button("按钮2");
		button2.addActionListener(first);
		
		Panel panel = new Panel();
		panel.add(button1);
		panel.add(button2);
		
		frame.add(panel,BorderLayout.SOUTH);
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}

举例2：为窗口添加窗口监听器，从而规范窗口监听器的用法，并允许用户单击窗口右上角的“X”按钮来结束程序。
	public class Test {
	// 创建一个父窗体
	private Frame frame = new Frame("测试窗口");
	// 创建一个文本域
	private TextArea area = new TextArea(6,50);
	// 创建一个内部类实现WindowListener
	class MyListener implements WindowListener{

		/**
		 * 窗口被初次打开触发
		 * */
		public void windowOpened(WindowEvent e) {
			area.append("窗口被初次打开！\n");
		}

		/**
		 * 单击窗口右上角的X关闭按钮时被触发
		 * */
		public void windowClosing(WindowEvent e) {
			area.append("窗口被关闭时触发！\n");
			System.out.println("windowClosing");
			System.exit(0);
		}

		/**
		 * 窗口关闭时触发
		 * */
		public void windowClosed(WindowEvent e) {
			area.append("窗口被成功关闭！\n");
		}

		/**
		 * 窗口最小化时触发
		 * */
		public void windowIconified(WindowEvent e) {
			area.append("窗口被最小化\n");
		}

		/**
		 * 窗口被恢复时触发
		 * */
		public void windowDeiconified(WindowEvent e) {
			area.append("窗口被恢复\n");
		}

		/**
		 * 窗口被激活时触发
		 * */
		public void windowActivated(WindowEvent e) {
			area.append("窗口被激活\n");
		}

		/**
		 * 窗口失去焦点时触发
		 * */
		public void windowDeactivated(WindowEvent e) {
			area.append("窗口失去焦点\n");
		}
		
	}
	public void init(){
		frame.setBounds(150, 150, 400, 400);
		frame.add(area);
		frame.addWindowListener(new MyListener());
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}
12.5.3 事件适配器
	事件适配器是监听器接口的空实现――事件适配器实现了监听接口，并为该接口里的每个方法都提供了实现，这种实现是一种空实现。当需要创建监听器时，可以通过继承事件适配器，而不是实现监听器接口。因为事件适配器已经为监听器接口的每个方法提供了空实现，所以程序中只需要重写自己感兴趣的方法，从而简化事件监听器的实现类代码。
监听器接口	事件适配器	监听器接口	事件适配器
ContainerListener	ContainerAdapter	MouseListener	MouseAdapter
FocusListener	FocusAdapter	MouseMoionListener	MouseMontionAdapter
ComponentListener	ComponentAdapter	WindowListener	WindowAdapter
KeyListener	KeyAdapter		

举例1：通过适配器来创建事件监听器，需要大家对接口中定义的方法进行掌握

package com.langsin.awt;

import java.awt.Frame;
import java.awt.TextArea;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class Test {
	// 创建一个父窗体
	private Frame frame = new Frame("测试窗口");
	// 创建一个文本域
	private TextArea area = new TextArea(6,50);
	// 创建一个内部类实现WindowListener
	class MyListener extends WindowAdapter{
		public void windowClosing(WindowEvent e) {
			System.exit(0);
		}
	}
	public void init(){
		frame.setBounds(150, 150, 400, 400);
		frame.add(area);
		frame.addWindowListener(new MyListener());
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}

12.5.4 类本身作为事件监听器类
	类本身作为事件监听器类这种形式使用GUI界面类直接作为监听器类，可以直接在GUI界面类中定义事件处理器方法。这种形式简洁，但是有如下缺点：
1、	这种形式可能造成混乱的程序结构，GUI界面的职责主要是完成界面初始化工作，但此时还包含事件处理器的方法，从而降低了程序的可读性。
2、	如果GUI界面类继承事件适配器，将会导致该GUI界面类不能继承其他父类。
举例1：
package com.langsin.awt;
import java.awt.Frame;
import java.awt.TextArea;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
public class Test extends WindowAdapter{
	// 创建一个父窗体
	private Frame frame = new Frame("测试窗口");
	// 创建一个文本域
	private TextArea area = new TextArea(6,50);
	// 创建一个内部类实现WindowListener
	public void windowClosing(WindowEvent e) {
		System.exit(0);
	}
	public void init(){
		frame.setBounds(150, 150, 400, 400);
		frame.add(area);
		frame.addWindowListener(this);
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}
12.6 AWT菜单
创建GUI界面的方式：将AWT组件按某种布局摆放在容器中即可。创建AWT菜单的方式与此种方式完全一致：将菜单条、菜单、菜单项组合在一起即可。
12.6.1 菜单条、菜单和菜单项
AWT中的菜单由如下几个类组合而成：
?	MenuBar：菜单条，菜单的容器
?	Menu：菜单组件，菜单项的容器。它也是MenuItem的子类，可以作为菜单项使用。
?	PopupMenu：上下文菜单组件。
?	MenuItem：菜单项组件。
?	CheckboxMenuItem：复选框菜单项组件。
?	MenuShortcut：菜单快捷键组件。

package com.langsin.awt;

import java.awt.CheckboxMenuItem;
import java.awt.Frame;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;
import java.awt.MenuShortcut;
import java.awt.TextArea;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;

public class Test {
	// 创建一个父窗体
	private Frame frame = new Frame("测试窗口");
	// 创建一个菜单条
	private MenuBar menuBar = new MenuBar();
	// 为此菜单栏创建两个菜单
	private Menu file = new Menu("文件");
	private Menu edit = new Menu("编辑");
	// 为文件菜单创建三个菜单项================================
	private MenuItem  newFile = new MenuItem("新建");
	private MenuItem  saveFile = new MenuItem("保存");
	// 创建退出菜单项时，同时为此菜单添加一个快捷方式，快捷键通常是以Ctrl键作为辅助键
	private MenuItem  exitFile = new MenuItem("退出",new MenuShortcut(KeyEvent.VK_X));
	//================================================
	// 为编辑菜单创建几个菜单项，首先创建一个复选框菜单项
	private CheckboxMenuItem autoWrap = new CheckboxMenuItem("自动换行");
	private MenuItem copyItem = new MenuItem("复制");
	private MenuItem pasteItem = new MenuItem("粘贴");
	private Menu format = new Menu("格式");
	// 创建commentItem菜单项，指定使用“Ctrl+Shift+/”快捷键
	private MenuItem commentItem = new MenuItem("注释",new MenuShortcut(KeyEvent.VK_SHIFT,true));
	private MenuItem cancelItem = new MenuItem("取消注释");
	private TextArea ta = new TextArea(8,40);
	
	public void init(){
		// 创建一个匿名内部类用来进行文件的退出
		ActionListener listener = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if(e.getActionCommand().equals("退出")){
					System.exit(0);
				}
			}
		};
		// 为菜单项加上事件监听器
		this.exitFile.addActionListener(listener);
		// 同样为注释菜单也加上此事件监听器
		this.commentItem.addActionListener(listener);
		// 为文件菜单添加菜单项
		this.file.add(this.newFile);
		this.file.add(this.saveFile);
		this.file.add(this.exitFile);
		// 为编辑菜单添加菜单项
		this.edit.add(this.autoWrap);
		// 在此菜单下添加一个分隔符，添加分隔符的方式有两种，第一种
		this.edit.add(new MenuItem("-"));
		this.edit.add(this.copyItem);
		this.edit.add(this.pasteItem);
		// 在为此菜单项添加一个分隔符，通过addSeparator()方法
		this.edit.addSeparator();
		// 为格式化菜单添加菜单项
		this.format.add(this.commentItem);
		this.format.add(this.cancelItem);
		// 将format菜单加入到编辑菜单中去
		this.edit.add(this.format);
		// 将文件菜单、编辑菜单添加到菜单栏中去
		this.menuBar.add(this.file);
		this.menuBar.add(this.edit);
		
		frame.setBounds(150, 150, 400, 400);
		// 为窗体设置菜单栏
		frame.setMenuBar(this.menuBar);
		// 为窗体添加一个关闭监听器
		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});
		// 添加多行文本域
		frame.add(this.ta);
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}
12.6.2 右键菜单
右键菜单使用PopupMenu对象表示，创建右键菜单的步骤：
1、	创建PopupMenu实例
2、	创建MenuItem的多个实例，依次将这些实例添加到PopupMenu实例中
3、	将PopupMenu加入到目标组件中
4、	为需要出现上下文菜单的组件编写一个鼠标监听器，当用户释放鼠标右键时弹出右键菜单。

举例1：
package com.langsin.awt;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Menu;
import java.awt.MenuItem;
import java.awt.MenuShortcut;
import java.awt.Panel;
import java.awt.PopupMenu;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class Test {
	// 创建一个父窗体
	private Frame frame = new Frame("测试窗口");
	// 创建一个上下文菜单项
	private PopupMenu pop = new PopupMenu();
	// 创建几个菜单项
	private MenuItem autoWrap = new MenuItem("自动换行");
	private MenuItem copyItem = new MenuItem("复制");
	private MenuItem pasteItem = new MenuItem("粘贴");
	private Menu format = new Menu("格式");
	// 创建commentItem菜单项，指定使用“Ctrl+Shift+/”快捷键
	private MenuItem commentItem = new MenuItem("注释",new MenuShortcut(KeyEvent.VK_SHIFT,true));
	private MenuItem cancelItem = new MenuItem("取消注释");
	// 创建一个panel容器
	private Panel panel = new Panel();
	public void init(){
		this.pop.add(this.autoWrap);
		this.pop.addSeparator();
		this.pop.add(this.copyItem);
		this.pop.add(this.pasteItem);
		this.pop.addSeparator();
		this.format.add(this.commentItem);
		this.format.add(this.cancelItem);
		this.pop.add(this.format);
		this.panel.setPreferredSize(new Dimension(400,400));
		this.panel.addMouseListener(new MouseAdapter() {
			public void mouseReleased(MouseEvent e) {
				// 如果释放的是鼠标右键
				if(e.isPopupTrigger()){
					pop.show(panel, e.getX(), e.getY());
				}
			}
		});
		this.panel.add(this.pop);
		frame.add(this.panel,BorderLayout.SOUTH);
		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});
		frame.pack();
		frame.setVisible(true);
	}
	
	public static void main(String[] args) {
		new Test().init();
	}
}
12.7 AWT中的绘图
	很多程序如各种小游戏都需要在窗口中绘制各种图形，除此之外，即使在开发J2EE项目时，有时候也需要动态的向客户端生成各种图形、图标，例如：验证码、统计图等信息。
12.7.1 使用Graphics类
	Graphics是一个抽象的画笔对象，Graphics可以在组件上绘制丰富多彩的几何图形和位图。Graphics类提供了如下几个方法用于绘制几何图形和位图。
?	drawLine()：绘制直线
?	drawString()：绘制字符串
?	drawRect()：绘制矩形
?	drawRoundRect()：绘制圆角矩形
?	drawOval()：绘制椭圆形状
?	drawPloygon()：绘制多边形
?	drawArc()：绘制一段弧线
?	drawPloyline()：绘制一段折线
?	fillRect()：填充一个矩形
?	fillRoundRect()：填充一个圆角矩形区域
?	fillOval()：填充椭圆区域
?	fillPloygon()：填充多边形
?	fillArc()：填充圆弧两个端点的连线跟圆弧所包裹起来的区域。
?	drawImage()：绘制位图。
除此之外，Graphics还提供了setColor()和setFont()两个方法用于设置画笔的颜色和字体，其中setColor()方法需要传入一个参数Color参数，它可以使用RGB、CMYK等方式设置一个颜色，而setFont()方法需要传入一个Font参数，Font参数需要制定字体名、字体样式、字体大小三个属性。
AWT专门提供了一个Canvas类作为绘图的画布，程序可以通过创建Canvas的子类，并重写它的paint()方法来实现绘图。
举例1：
package com.langsin.awt;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class Test extends Frame {
	public Test() {
		super("绘制图形示例");
		this.setBounds(100, 100, 500, 400);
		Panel panel = new Panel();
		Button rect = new Button("矩形");
		Button oval = new Button("椭圆形");
		Button ploygon = new Button("多边形");
		Button arc = new Button("圆弧形");
		panel.add(rect);
		panel.add(oval);
		panel.add(ploygon);
		panel.add(arc);
		this.add(panel, BorderLayout.NORTH);
		class MyCanvas extends Canvas {
			public String type = "rect";
			@Override
			public void paint(Graphics g) {
				switch (type) {
				case "rect":
					g.setColor(Color.BLUE);
					g.drawRect(100, 70, 300, 200);
					g.fillRect(100, 70, 300, 200);
					break;
				case "oval":
					g.setColor(Color.PINK);
					g.drawOval(150, 70, 200, 200);
					g.fillOval(150, 70, 200, 200);
					break;
				case "ploygon":
					g.setColor(Color.GREEN);
					int[] xPoints = {100,250,400,350,150};
					int[] yPoints = {150,50,150,280,280};
					g.drawPolygon(xPoints, yPoints, 5);
					g.fillPolygon(xPoints, yPoints, 5);
					break;
				case "arc":
					g.setColor(Color.GRAY);
					g.drawArc(100, 70, 300, 300, 45, 90);
					g.fillArc(100, 70, 300, 300, 45, 90);
					break;
				}
			}
		}
		final MyCanvas can = new MyCanvas();
		this.add(can);
		rect.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				can.type = "rect";
				can.repaint();
			}
		});
		oval.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				can.type = "oval";
				can.repaint();
			}
		});
		ploygon.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				can.type = "ploygon";
				can.repaint();
			}
		});
		arc.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				can.type = "arc";
				can.repaint();
			}
		});
		this.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent e) {
				Test.this.dispose();
			}
		});
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new Test();
	}
}
12.7.2 Java实现动画
	所谓的动画就是一定的时间重新绘制新的图片，两次绘制的图像之间差异较小，可以让我们看起来像图片在运动一样。为了实现间隔一定的时间就重新调用组件的repaint()方法，可以借助于Swing提供的Timer类，Timer类就是一个定时器，有如下构造方法：
	Timer(int delay,ActionListener listener)：每间隔delay毫秒，系统自动触发ActionListener监听器里的事件处理器。
举例1：
package com.langsin.awt;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import javax.swing.Timer;
public class Test extends Frame {
	
	class MyCanvas extends Canvas{
		int rect_x = 200;
		int rect_y = 360;
		int ball_x = 140;
		int ball_y = 100;
		int x_speed = -10;
		int y_speed = 10;
		boolean flag = true;
		@Override
		public void paint(Graphics g) {
			if(flag){
				//首先绘制球拍
				g.setColor(Color.BLUE);
				g.fillRect(rect_x, rect_y, 100, 10);
				//绘制小球
				g.setColor(Color.RED);
				g.fillOval(ball_x, ball_y, 20, 20);
			}else{
				g.setColor(Color.RED);
				g.setFont(new Font("宋体",Font.ITALIC,36));
				g.drawString("游戏结束！", 150, 200);
			}
		}
	}
	final MyCanvas can = new MyCanvas();
	ActionListener listener = new ActionListener() {
		@Override
		public void actionPerformed(ActionEvent e) {
			if(can.ball_x==0 || can.ball_x+20==500){
				can.x_speed = -can.x_speed;
			}
			can.ball_x = can.ball_x + can.x_speed;
			if(can.ball_y==0 || ((can.ball_y+20)==360 && can.ball_x>can.rect_x && can.ball_x+20<can.rect_x+100)){
				can.y_speed = -can.y_speed;
			}else if(can.ball_y>can.rect_y){
				can.flag = false;
				timer.stop();
			}
			can.ball_y = can.ball_y + can.y_speed;
			can.repaint();
		}
	};
	final Timer timer = new Timer(200,listener);	
	public Test() {
		super("绘制图形示例");
		this.setBounds(100, 100, 500, 460);
		this.setResizable(false);
		this.add(can);
		this.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if(e.getKeyCode()==KeyEvent.VK_LEFT){
					if(can.rect_x>0){
						can.rect_x = can.rect_x - 10;
					}
				}
				if(e.getKeyCode()==KeyEvent.VK_RIGHT){
					if(can.rect_x+100<500){
						can.rect_x = can.rect_x + 10;
					}
				}
			}
		});
		timer.start();
		this.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent e) {
				timer.stop();
				Test.this.dispose();
			}
		});
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new Test();
	}
}
12.7.3 处理位图Image抽象类与BufferedImage实现类
	AWT不仅仅可以绘制一些简单的几何图形，同样也可以绘制位图。Graphics类提供了一个drawImage()方法用来绘制位图，该方法需要一个Image对象参数。
	Image类是一个抽象类，无法直接创建Image对象，为此Java提供了一个BufferedImage的子类，这个子类是一个可访问图像数据缓冲区的Image实现类。该类提供了一个简单的构造器，用于创建BufferedImage对象。
?	BufferedImage(int width,int height,int imageType)：创建指定大小、指定图像类型的BufferedImage对象。
BufferedImage对象还提供了一个getGraphics()方法返回该对象的Graphics对象，通过此对象可以向image中添加图形。
借助BufferedImage对象，可以实现AWT中实现缓冲技术――当需要向GUI组件上绘制图像时，如果图像较大那么往组件上绘图时，有可能会因为加载不完全而导致在组件上显示的效果是图像一点一点的画完，不能一次性的将图片画出来。通过BufferedImage对象，我们可以先将图片加载到此对象中，加载的过程在内存中实现，过程我们不需要关注，我们要看的只是结果，当图像全部加载完成，再通过此对象一次性将图片绘制到组件上。
举例1：
package com.langsin.awt;

import java.awt.Canvas;
import java.awt.CheckboxMenuItem;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.PopupMenu;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;

public class BufferedImageDemo extends Frame {
	// 定义画图区域的高度与宽度
	private final int AREA_HIEGHT = 500;
	private final int AREA_WIDTH = 400;
	// 定义一个坐标点，用于记录鼠标拖动时的下一个坐标点，初始值为-1
	private int pre_x = -1;
	private int pre_y = -1;
	// 定义一个右键菜单，用于设置画笔的颜色
	private PopupMenu pop = new PopupMenu();
	private CheckboxMenuItem redItem = new CheckboxMenuItem("红色");
	private CheckboxMenuItem greenItem = new CheckboxMenuItem("绿色");
	private CheckboxMenuItem blueItem = new CheckboxMenuItem("蓝色");
	// 定义一个缓冲图片对象
	private BufferedImage image = new 
BufferedImage(AREA_WIDTH,AREA_HIEGHT,BufferedImage.TYPE_INT_RGB);
	// 获取图像的Graphics画笔对象
	private Graphics g = image.getGraphics();
	// 定义一个Color颜色对象，默认值为红色
	private Color c = new Color(255, 0, 0);
	// 定义一个画布对象，用一个类来继承Canvas类
	class MyCanvas extends Canvas{
		public void paint(Graphics g) {
			// 将图片对象image画到画布上
			g.drawImage(image, 0, 0, null);
		}
	}
	private MyCanvas area = new MyCanvas();
	BufferedImageDemo(){
		super("简单画图示例");
		// 为菜单添加事件
		ItemListener listener = new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				if(e.getItem().equals("红色")){
					c = new Color(255,0,0);
					greenItem.setState(false);
					blueItem.setState(false);
				}else if(e.getItem().equals("绿色")){
					c = new Color(0,255,0);
					redItem.setState(false);
					blueItem.setState(false);
				}else{
					c = new Color(0,0,255);
					redItem.setState(false);
					greenItem.setState(false);
				}
			}
		};
		// 为三个菜单添加事件
		this.redItem.addItemListener(listener);
		this.greenItem.addItemListener(listener);
		this.blueItem.addItemListener(listener);
		this.redItem.setState(true);
		this.pop.add(redItem);
		this.pop.add(greenItem);
		this.pop.add(blueItem);
		this.area.add(this.pop);
		// 设置image对象的背景色填充色为白色
		g.fillRect(0, 0, AREA_WIDTH, AREA_HIEGHT);
		// 设置画布的大小
		this.area.setPreferredSize(new Dimension(AREA_WIDTH,AREA_HIEGHT));
		// 为画布添加鼠标监听事件，首先是监听鼠标拖动
		this.area.addMouseMotionListener(new MouseMotionAdapter() {
			public void mouseDragged(MouseEvent e) {
				// 因为设置的坐标初始值为-1，所以当坐标值大于0时，表示开始拖动鼠标
				// 即：开始画图
				if(pre_x>0 && pre_y>0){
					g.setColor(c);
					g.drawLine(pre_x, pre_y, e.getX(), e.getY());
				}
				pre_x = e.getX();
				pre_y = e.getY();
				area.repaint();
			}
		});
		this.area.addMouseListener(new MouseAdapter() {
			public void mouseReleased(MouseEvent e) {
				if(e.isPopupTrigger()){
					pop.show(area, e.getX(), e.getY());
				}
				pre_x = -1;
				pre_y = -1;
			}
		});
		this.add(area);
		this.pack();
		this.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});
		this.setLocation(100, 100);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new BufferedImageDemo();
	}
}
12.7.4 ImageIO输入/输出位图
	如果绘制磁盘上的GIF、JPG等格式的位图，则需要利用ImageIO工具类。ImageIO利用ImageReader和ImageWriter读写图形文件，对于底层的实现细节我们无须关注，只需要学会怎样利用该工具类来读写图形文件即可。
	ImageIO类并不支持所有格式的图形文件，但是可以支持大多数图形文件。可以通过ImageIO类的如下几个静态方法来来操作它所支持的几种格式的图形文件。
?	static String[] getReaderFileSuffixes()：返回一个String数组，该数组列出ImageIO所有能读的图形文件的文件后缀名。
?	static String[] getReaderFormatNames()：返回一个String数组，该数组列出ImageIO所有能读的图形文件的非正式格式名称。
?	static String[] getWriterFileSuffixes()：返回一个String数组，该数组列出ImageIO所有能写的图形文件的后缀名
?	static String[] getWriterFormatNames()：返回一个String数组，该数组列出ImageIO所有能写的图形文件的非正式格式名称。
ImageIO所支持的大部分格式为：bmp、jpg、jpeg、wbmp、png、gif（正式格式名称）
BMP、JPG、JPEG、GIF（非正式格式名称）
举例1：
	public static void main(String[] args) {
		String[] fileSuff = ImageIO.getReaderFileSuffixes();
		for(String str : fileSuff){
			System.out.println(str);
		}
		System.out.println("=====================");
		String[] fileRead = ImageIO.getReaderFormatNames();
		for(String str : fileRead){
			System.out.println(str);
		}
	}
ImageIO类包含两个静态的方法：read()、write()，通过这两个方法即可以完成对位图文件的读写，调用write()方法输出图形文件时，需要指定输出的图形格式，例如GIF、JPEG等。
举例2：
public static void main(String[] args) throws Exception {
		// 定义图像的高度及宽度
		int width = 300;
		int height = 400;
		// 定义一个image对象
		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		// 定义一个画笔，画笔对象从图像中获取
		Graphics g = image.getGraphics();
		Image srcImage = ImageIO.read(new File("./image/11.gif"));
		g.drawImage(srcImage, 0, 0,null);
		class MyCanvas extends Canvas{
			private BufferedImage image;
			MyCanvas(BufferedImage image){
				this.image = image;
			}
			public void paint(Graphics g) {
				g.drawImage(image, 0,0, null);
			}
		};
		MyCanvas can = new MyCanvas(image);
		can.setPreferredSize(new Dimension(width,height));
		Frame frame = new Frame("画图示例");
		frame.add(can);
		frame.setLocation(100, 100);
		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});
		frame.pack();
		frame.setVisible(true);
	}
12.7.5 实现一个五子棋
package com.langsin.awt;

import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;
import javax.swing.JPanel;

public class Gobang extends Frame {
	// 下面三个位图分别代表棋盘、黑子、白子
	BufferedImage table;
	BufferedImage black;
	BufferedImage white;
	// 当鼠标移动时候的选择框
	BufferedImage selected;
	// 定义棋盘的纵向横向上可放置的最多旗子数量，由图片上的网格决定
	private static int BOARD_SIZE = 15;
	// 定义棋盘宽、高多少个像素
	private final int TABLE_WIDTH = 535;
	private final int TABLE_HETGHT = 536;
	// 计算每张图片应该占据多大的像素，黑子或白子的宽度像素
	private final int RATE = TABLE_WIDTH / BOARD_SIZE;
	// 定义棋盘座标的像素值和棋盘数组之间的偏移距。
	private final int X_OFFSET = 5;
	private final int Y_OFFSET = 6;
	// 定义一个二维数组来充当棋盘
	private String[][] board = new String[BOARD_SIZE][BOARD_SIZE];
	// 五子棋游戏的窗口
	Frame f = new Frame("五子棋游戏");
	// 五子棋游戏棋盘对应的Canvas组件
	ChessBoard chessBoard = new ChessBoard();
	// 当前选中点的座标
	private int selectedX = -1;
	private int selectedY = -1;

	public void init() throws Exception {
		table = ImageIO.read(new File("image/board.jpg"));
		black = ImageIO.read(new File("image/black.gif"));
		white = ImageIO.read(new File("image/white.gif"));
		selected = ImageIO.read(new File("image/selected.gif"));
		// 把每个元素赋为"+"，用于在控制台画出棋盘
		for (int i = 0; i < BOARD_SIZE; i++) {
			for (int j = 0; j < BOARD_SIZE; j++) {
				board[i][j] = "+";
			}
		}
		chessBoard.setPreferredSize(new Dimension(TABLE_WIDTH, TABLE_HETGHT));
		chessBoard.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent e) {
				// 将用户鼠标事件的座标转换成棋子数组的座标。
				int xPos = (int) ((e.getX() - X_OFFSET) / RATE);
				int yPos = (int) ((e.getY() - Y_OFFSET) / RATE);
				board[xPos][yPos] = "●";
				/*
				 * 电脑随机生成2个整数，作为电脑下棋的座标，赋给board数组。 还涉及: 1.如果下棋的点已经棋子，不能重复下棋。
				 * 2.每次下棋后，需要扫描谁赢了
				 */
				chessBoard.repaint();
			}

			// 当鼠标退出棋盘区后，复位选中点座标
			public void mouseExited(MouseEvent e) {
				selectedX = -1;
				selectedY = -1;
				chessBoard.repaint();
			}
		});
		chessBoard.addMouseMotionListener(new MouseMotionAdapter() {
			// 当鼠标移动时，改变选中点的座标
			public void mouseMoved(MouseEvent e) {
				selectedX = (e.getX() - X_OFFSET) / RATE;
				selectedY = (e.getY() - Y_OFFSET) / RATE;
				chessBoard.repaint();
			}
		});
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});
		f.add(chessBoard);
		f.pack();
		f.setVisible(true);
	}

	public static void main(String[] args) throws Exception {
		Gobang gb = new Gobang();
		gb.init();

	}

	class ChessBoard extends JPanel {
		// 重写JPanel的paint方法，实现绘画
		public void paint(Graphics g) {
			// 将绘制五子棋棋盘
			g.drawImage(table, 0, 0, null);
			// 绘制选中点的红框
			if (selectedX >= 0 && selectedY >= 0)
				g.drawImage(selected, selectedX * RATE + X_OFFSET, selectedY* RATE + Y_OFFSET, null);
			// 遍历数组，绘制棋子。
			for (int i = 0; i < BOARD_SIZE; i++) {
				for (int j = 0; j < BOARD_SIZE; j++) {
					// 绘制黑棋
					if (board[i][j].equals("●")) {
						g.drawImage(black, i * RATE + X_OFFSET, j * RATE+ Y_OFFSET, null);
					}
					// 绘制白棋
					if (board[i][j].equals("○")) {
						g.drawImage(black, i * RATE + X_OFFSET, j * RATE+ Y_OFFSET, null);
					}
				}
			}
		}
	}
}
12.8 剪贴板
	AWT支持两种剪贴板：本地剪贴板和系统剪贴板。如果在同一个虚拟机的不同窗口之间进行数据传递，则使用AWT自己的本地剪贴板就可以了。本地剪贴板则与运行平台无关，可以传输任意格式的数据。如果需要在不同的虚拟机之间传递数据，或者需要在Java程序与第三方程序之间传递数据，则需要使用系统剪贴板。
12.8.1 数据传递的类和接口
	AWT中剪贴板相关操作的接口和类被放在java.awt.datatransfer包下，下面是该包下重要的接口和类的相关说明：
?	Clipboard：代表一个剪贴板实例，这个剪贴板可以是系统的，也可以使本地的
?	ClipboardOwner：剪贴板内容的持有者接口，当剪贴板内容的所有权被修改时，系统将会触发该持有者的lostOwnership事件处理器。
?	Transferable：该接口的实例代表放进剪贴板中的传输对象。
?	DataFlavor：用于表述剪贴板中的数据格式。
?	StringSelection：数据格式监听器接口
?	FlavorEvent：该类的实例封装了数据格式改变的事件。
12.8.2 传递文本
	传递文本是最简单的使用情况，AWT已经提供了一个StringSelection用于传输文本字符串。将一段文本内容：即字符串对象放进剪贴板中的步骤如下：
1、	创建一个剪贴板实例对象Clipboard，既可以创建系统的，也可以创建本地的。
创建系统的代码如下：
Clipboard board = Toolkit.getDefaultToolkit().getSystemClipboard();
创建本地的代码如下：
Clipboard board = new Clipboard(“cb”); //cb代表了剪贴板的描述名称
2、	将需要放入剪贴板中的字符串封装成StringSelection对象，代码如下：
StringSelection st = new StringSelection(“adfasdfasd”);
3、	调用剪贴板对象中的setContents()方法将StringSelection放进剪贴板中，该方法需要两个参数，第一个参数是Transferable对象，代表放进剪贴板中的对象；第二个参数是ClipborderOwner对象，代表剪贴板数据的所有者，通常我们无须关注剪贴板数据的所有者，所以把第二个参数设置为null
board.setContents(st,null)
4、	从剪贴板中取出数据则比较简单，调用Clipboard对象的getData(DataFlavor flaor)方法即可取出剪贴板中指定格式的内容，如果指定flavor的数据不存在，该方法将引发UnsupportedFlavorException异常。为了避免异常的出现，可以先调用Clipboard对象的isDataFlavorAvailbale(DataFlavor flavor)来判断指定flavor的数据是否存在。代码如下：
if(board.isDataFlavorAvailble(DataFlavor.stringFlavor)){
		String content = (String)board.getData(DataFlavor.stringFlavor)
}
举例1：
package com.langsin.awt;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.Box;
import javax.swing.BoxLayout;
public class ClipboardDemo extends Frame {
	//获取系统剪贴板
	private Clipboard board = Toolkit.getDefaultToolkit().getSystemClipboard();
	//创建本地的剪贴板
	//private Clipboard localBoard = new Clipboard("cb");
	//用于复制文本的文本框
	private TextArea copyArea = new TextArea(5,20);
	//用于粘贴文本的文本框
	private TextArea pasteArea = new TextArea(5,20);
	//创建粘贴复制的按钮
	private Button copyButt = new Button("复制");
	private Button pasetButt = new Button("粘贴");
	ClipboardDemo(){
		super("剪贴板示例");
		Panel panel = new Panel();
		panel.add(copyButt);
		panel.add(pasetButt);
		copyButt.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				//从文本域中获取字符串封装到StringSelection对象中
				StringSelection contents = new StringSelection(copyArea.getText());
				//将StringSelection对象放置到剪贴板中
				board.setContents(contents, null);
			}
		});
		pasetButt.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				//如果剪贴板中包含stringFlavor内容
				if(board.isDataFlavorAvailable(DataFlavor.stringFlavor)){
					//从剪贴板中取出stringFlavor内容
					try {
						String content = board.getData(DataFlavor.stringFlavor).toString();
						pasteArea.append(content);
					} catch (Exception e1) {
						e1.printStackTrace();
					}
				}
			}
		});
		//创建一个水平排列的盒子容器
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(copyArea);
		box.add(pasteArea);
		this.add(panel,BorderLayout.SOUTH);
		this.add(box,BorderLayout.CENTER);
		this.pack();
		this.setLocation(100, 100);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new ClipboardDemo();
	}
}
Java小游戏项目
游戏1：拼图
package com.langsin.game;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;


public class Puzzle extends JFrame implements ActionListener {
	
	private JPanel content = new JPanel();
	private Container c = this.getContentPane();
	private JLabel numLabel = new JLabel();
	private Btn[][] btn = new Btn[3][3];
	private JButton control = new JButton();
	private List<String> imageList = new ArrayList<String>();
	private int a = 2;
	private int b = 2;
	private int btnHeight = 0;
	private int btnWidth = 0;
	private int count = 0;
	private boolean flag = false;
	
	Puzzle(){
		super("拼图游戏");
		numLabel.setText("玩具所有者移动了"+count+"步，设置错乱！");
		numLabel.setAlignmentX(JLabel.CENTER_ALIGNMENT);
		content.setLayout(new GridLayout(3, 4));
		for(int i=1;i<=9;i++){
			imageList.add("pin"+i+".png");
		}
		//Collections.shuffle(imageList);
		for(int i=0;i<3;i++){
			for(int j=0;j<4;j++){
				if(j==3){
					if(i==2){
						control.setPreferredSize(new Dimension(btnWidth,btnHeight));
						control.setIcon(null);
						content.add(control);
					}else{
						if(i==0){
							content.add(new JPanel().add(new JLabel(new ImageIcon("./game/22.jpg"),JLabel.CENTER)));
						}else{
							content.add(new JPanel().add(numLabel));
						}
					}
				}else{
					btn[i][j] = new Btn();
					if(imageList.size()>0){
						ImageIcon icon = new ImageIcon("./game/"+imageList.get(0));
						icon.setDescription(imageList.get(0));
						btn[i][j].setIcon(icon);
						if(i==0){
							btnHeight = icon.getIconHeight();
							btnWidth = icon.getIconWidth();
						}
						btn[i][j].setPreferredSize(new Dimension(btnWidth,btnHeight));
						imageList.remove(0);
					}
					btn[i][j].addActionListener(this);
					content.add(btn[i][j]);
				}
			}
		}
		control.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if(btn[2][2].getIcon()!=null && control.getIcon()==null){
					control.setIcon(btn[2][2].getIcon());
					//control.setEnabled(false);
					btn[2][2].setIcon(null);
					btn[1][2].vis = true;
					btn[2][1].vis = true;
				}else if(btn[2][2].getIcon()==null && control.getIcon()!=null){
					btn[2][2].setIcon(control.getIcon());
					control.setIcon(null);
					btn[1][2].vis = false;
					btn[2][1].vis = false;
					//最后判断玩家是否完成了挑战
					boolean result = complete();
					if(result){
						numLabel.setText("玩家完成了挑战，游戏结束");
					}else{
						numLabel.setText("玩家失败没有完成挑战，游戏结束");
					}
				}
				if(control.getIcon()==null){
					count = 0;
					if(flag==false){
						numLabel.setText("请开始拼图！");
					}
					flag = true;
				}
			}
		});
		c.add(content,BorderLayout.CENTER);

		this.setBounds(100,100,370,370);
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	/**
	 * 此方法判断所有图片是否完成了拼接
	 * */
	private boolean complete(){
		boolean flag = true;
		for(int i=0;i<imageList.size()-1;i++){
			if(Integer.parseInt(imageList.get(i).charAt(3)+"")-Integer.parseInt(imageList.get(i+1).charAt(3)+"")!=-1){
				flag = false;
				break;
			}
		}
		return flag;
	}
	/**
	 * 通过此事件来进行计算哪个按钮被按下，按钮是否有图片
	 * */
	public void actionPerformed(ActionEvent e) {
		//获取鼠标点击了哪个按钮，通过参数e来获取，记录下来
		int x = 0;
		int y = 0;
		for(int i=0;i<3;i++){
			for(int j=0;j<3;j++){
				if(e.getSource().equals(btn[i][j])){
					x = i;
					y = j;
				}
			}
		}
		//如果点击了可以移动的按钮，则将按钮上的图片进行互换
		if(btn[x][y].vis){
			btn[a][b].setIcon(btn[x][y].getIcon());
			btn[x][y].setIcon(null);
			a = x;
			b = y;
			count++;
			if(flag){
				numLabel.setText("游戏玩家移动了"+count+"次");
			}else{
				numLabel.setText("玩具所有者移动了"+count+"步，设置错乱！");
			}
			
			imageList.clear();
			//将所有按钮全部再设置为不可以移动，然后再将可以移动的按钮挑选出来
			for(int i=0;i<3;i++){
				for(int j=0;j<3;j++){
					btn[i][j].vis = false;
					if(btn[i][j].getIcon()!=null){
						String png = ((ImageIcon)btn[i][j].getIcon()).getDescription();
						imageList.add(png);
					}
				}
			}
			//通过a、b来判断哪些按钮可以进行移动
			if(x+1<=2){
				//表示不含有背景图片的按钮在第一或第二行
				btn[x+1][y].vis = true;
			}
			if(x-1>=0){
				btn[x-1][y].vis = true;
			}
			if(y+1<=2){
				btn[x][y+1].vis = true;
			}
			if(y-1>=0){
				btn[x][y-1].vis = true;
			}
		}
	}
	
	public static void main(String[] args) {
		new Puzzle();
	}
	
}

class Btn extends JButton{
	//设置此按钮上的图片是否可以移动
	public boolean vis = false;
}
游戏2：赛马
package com.langsin.game;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Random;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JTextArea;

public class Horse extends JFrame {
	Horse(){
		super("赛马");
		GraphicsPanel gp = new GraphicsPanel();
		OperatorPanel op = new OperatorPanel();
		MyThread th1 = new MyThread();
		th1.setGp(gp,op);
		
		MyThread1 th2 = new MyThread1();
		th2.setGp(gp,op);
		
		MyThread2 th3 = new MyThread2();
		th3.setGp(gp,op);
		
		MyThread3 th4 = new MyThread3();
		th4.setGp(gp,op);
		Runnable[] runnable = {th1,th2,th3,th4};
		op.setRunnable(runnable);
		
		Container c = this.getContentPane();
		c.setLayout(new GridLayout(2, 1));
		c.add(gp);
		c.add(op);
		this.setSize(800, 760);
		this.setResizable(false);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setLocation(100, 100);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new Horse();
	}
}

class GraphicsPanel extends JPanel{
	int x = 10;
	int y = 0;
	int x1 = 10;
	int y1 = 85;
	int x2 = 10;
	int y2 = 170;
	int x3 = 10;
	int y3 = 255;
	GraphicsPanel(){
		this.setBackground(Color.WHITE);
	}
	@Override
	public void update(Graphics g) {
		this.paint(g);
	}
	public void fn(){
		this.repaint();
	}
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		Image image = Toolkit.getDefaultToolkit().getImage("./game/horse.gif");
		g.drawString("1", 5, 70);
		g.drawImage(image, x, y, null,this);
		g.drawString("2", 5, 160);
		g.drawImage(image, x1, y1, null,this);
		g.drawString("3", 5, 240);
		g.drawImage(image, x2, y2, null,this);
		g.drawString("4", 5, 320);
		g.drawImage(image, x3, y3, null,this);
		g.setColor(Color.RED);
		g.fillRect(770, 0, 3, 360);
	}
}

class OperatorPanel extends JPanel implements ActionListener{
	JButton btn = new JButton("开始");
	JRadioButton jrb1 = new JRadioButton("1号马");
	JRadioButton jrb2 = new JRadioButton("2号马");
	JRadioButton jrb3 = new JRadioButton("3号马");
	JRadioButton jrb4 = new JRadioButton("4号马");
	ButtonGroup bg = new ButtonGroup();
	JLabel jl = new JLabel("请选择一个：");
	int num = 1;
	JTextArea area = new JTextArea();
	JPanel jp = new JPanel();
	Runnable[] runnable;
	OperatorPanel(){
		jp.setLayout(new GridLayout(1, 6));
		
		bg.add(jrb1);
		bg.add(jrb2);
		bg.add(jrb3);
		bg.add(jrb4);
		jp.add(jl);
		jp.add(jrb1);
		jp.add(jrb2);
		jp.add(jrb3);
		jp.add(jrb4);
		jp.add(btn);
		
		btn.addActionListener(this);
		this.setLayout(new BorderLayout());
		this.add(jp,BorderLayout.NORTH);
		this.add(area,BorderLayout.CENTER);
	}
	@Override
	public void actionPerformed(ActionEvent e) {
		this.num = 1;
		new Thread(this.runnable[0]).start();
		new Thread(this.runnable[1]).start();
		new Thread(this.runnable[2]).start();
		new Thread(this.runnable[3]).start();
	}
	
	public void setRunnable(Runnable[] runnable){
		this.runnable = runnable;
	}
}

class MyThread implements Runnable{
	GraphicsPanel gp = null;
	OperatorPanel op = null;
	public void setGp(GraphicsPanel gp,OperatorPanel op){
		this.gp = gp;
		this.op = op;
	}
	@Override
	public void run() {
		try {
			while(true){
				gp.fn();
				gp.x +=10;
				Random rd = new Random();
				Thread.sleep(rd.nextInt(500));
				if(gp.x >= 770){
					gp.x = 10;
					op.area.append("1号马跑了第"+op.num+"名"+'\n');
					op.num = op.num + 1;
					return;
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

class MyThread1 implements Runnable{
	GraphicsPanel gp = null;
	OperatorPanel op = null;
	public void setGp(GraphicsPanel gp,OperatorPanel op){
		this.gp = gp;
		this.op = op;
	}
	@Override
	public void run() {
		try {
			while(true){
				gp.fn();
				gp.x1 +=10;
				Random rd = new Random();
				Thread.sleep(rd.nextInt(500));
				if(gp.x1 >= 770){
					gp.x1 = 10;
					op.area.append("2号马跑了第"+op.num+"名"+'\n');
					op.num = op.num + 1;
					return;
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

class MyThread2 implements Runnable{
	GraphicsPanel gp = null;
	OperatorPanel op = null;
	public void setGp(GraphicsPanel gp,OperatorPanel op){
		this.gp = gp;
		this.op = op;
	}
	@Override
	public void run() {
		try {
			while(true){
				gp.fn();
				gp.x2 +=10;
				Random rd = new Random();
				Thread.sleep(rd.nextInt(500));
				if(gp.x2 >= 770){
					gp.x2 = 10;
					op.area.append("3号马跑了第"+op.num+"名"+'\n');
					op.num = op.num + 1;
					return;
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
class MyThread3 implements Runnable{
	GraphicsPanel gp = null;
	OperatorPanel op = null;
	public void setGp(GraphicsPanel gp,OperatorPanel op){
		this.gp = gp;
		this.op = op;
	}
	@Override
	public void run() {
		try {
			while(true){
				gp.fn();
				gp.x3 +=10;
				Random rd = new Random();
				Thread.sleep(rd.nextInt(500));
				if(gp.x3 >= 770){
					gp.x3 = 10;
					op.area.append("4号马跑了第"+op.num+"名"+'\n');
					op.num = op.num + 1;
					return;
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
第13章：Swing编程
13.1 Swing简述
	客户端程序通常需要一个友好、完备的用户界面，以减少用户使用软件的难度，增强软件的应用效率。我们已经学习了能够实现此功能的AWT包。
	大家可能会有疑惑：既然Java已经为用户提供了AWT，为什么还要开发另外一套开发包呢？之前曾给大家说过awt中的类直接使用了一些与平台相关的底层类，使得awt类的界面效果在不同的平台上表现不一致，因此兼容性比较差。
	为此，Java2的Swing包对AWT包进行了修订和扩展，Swing中的控件类比awt更加丰富，新增了JTabbedPane、JTable和JTree等复杂控件。Swing的类不再含有与平台相关的技术，而是把这些平台相关技术留给了平台环境来处理。因此Swing是纯粹的Java产物，具有最大程度的平台兼容能力。利用Swing中的控件类可以开发出各种操作系统平台风格的应用界面。
	Swing中的类基本上都是以字母J开头，其中作为Swing的各种控件类的父类的JComponent类继承了awt包的Container类，因此Java2里还需要保留java.awt包。使用Java2开发客户端图形界面时，应尽量采用更高级的Swing包中的控件类。
13.2 MVC设计模式
MVC是一种设计模式，这个设计模式称为：模型（Model）―视图（View）―控制器（Controller），MVC是一个主流的设计模式，在软件开发中MVC让负责显示的代码、处理数据的代码、对交互进行响应并驱动变化的代码彼此进行分离。
13.3 Swing组件体系
 
 
13.4 创建基本的Swing应用程序
package com.langsin.swing;
import javax.swing.JFrame;
import javax.swing.JLabel;
public class Test {
	public static void main(String[] args) {
		// 设置窗口的外观显示，true表示java标准的外观，false为操作系统的外观
		// 本语句必须放置所有语句的前面
		JFrame.setDefaultLookAndFeelDecorated(true);
		JFrame frame = new JFrame("JFrame窗体");
		JLabel label = new JLabel("简单的Swing组件演示");
		frame.add(label);
		// 设置窗口的关闭，点击右上角的X图标时，程序退出，即关闭系统
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(400, 400);
		frame.setLocation(100, 100);
		frame.setVisible(true);
	}
}
举例2：
package com.langsin.swing;

import java.awt.Color;
import java.awt.GridLayout;
import javax.swing.JFrame;
import javax.swing.JPanel;
public class JFrameDemo extends JFrame {
	JFrameDemo(){
		super("窗体标题");
		// 设置窗口的关闭
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		// 设置窗体的背景色
		this.setBackground(Color.BLACK);
		// 设置窗体的布局管理器
		this.setLayout(new GridLayout(6,6,5,5));
		// 往窗体中加入面板
		for(int i=0;i<18;i++){
			JPanel panel = new JPanel();
			int e = 255 - i * 12;
			// 为面板的背景色添加颜色，使用Color类进行创建颜色
			// Color类使用RGB三色（红绿蓝）进行调色，每个单颜色的取值范围0-255之间
			panel.setBackground(new Color(e,e,e));
			this.add(panel);
		}
		this.setBounds(100, 100, 500, 400);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JFrameDemo();
	}
}
13.5 Swing常用的组件
13.5.1 JPanel（面板）
JPanel常作为中间容器，用于将小的轻量级组件组合在一起，其缺省的布局也是FlowLayout。
构造方法：
1、	JPanel()：建立一个面板，缺省设置为FlowLayout布局管理器
2、	JPanel(LayoutManager layout)：建立一个面板布局管理器为指定的布局管理器。
JPanel类的大部分方法都是继承自其父类：JComponent、Container和Component。
举例1：将一个含有两个按钮的JPanel面板加入到JFrame窗体的North位置
package com.langsin.swing;

import java.awt.BorderLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
public class JPanelDemo extends JFrame {
	JPanelDemo(){
		super("JPanel面板示例");
		JPanel panel = new JPanel();
		panel.add(new JButton("按钮一"));
		panel.add(new JButton("按钮二"));
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.add(panel,BorderLayout.NORTH);
		this.setBounds(100, 100, 400, 400);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		JFrame.setDefaultLookAndFeelDecorated(true);
		new JPanelDemo();
	}
}
13.5.2 JLabel（标签）
这个组件主要用来放置提示性的文本或图形。
构造方法：
1、	JLabel()：建立一个空白的标签组件
2、	JLabel(Icon image)：建立一个含有图标的标签组件，默认排列方式为CENTER
3、	JLabel(Icon image,int horizontalAliganment)：建立一个含有图标的标签组件，并指定其排列方式。
4、	JLabel(String text)：建立一个含有文字的标签组件，默认排列方式是LEFT
5、	JLabel(String text,int horzontalAliganment)：建立一个含有文字的标签组件，并指定其排列方式。
6、	JLabel(String text,Icon icon,int horzontalAlignment)：建立一个含有文字和图标的标签组件，并指定其排列方式。
在一般情况下，JLabel上面放置文字或图形，调整JLabel的相关位置，如下
TOP LEFT RIGHT BOTTOM NORTH EAST WEST SOUTH NORTH_EAST NORTH_WEST SOUTH_EAST SOUTH_WEST
HORIZONTAL VERTICAL LEADING TRAILING 
举例1：
package com.langsin.swing;
import java.awt.Color;
import java.awt.GridLayout;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
public class JLabelDemo extends JFrame {
	JLabelDemo(){
		JLabel label1 = new JLabel("第一个标签");
		label1.setForeground(Color.BLUE);
		JLabel label2 = new JLabel(new ImageIcon("./image/redButton.png"),JLabel.CENTER);
		this.setLayout(new GridLayout(1, 3));
		this.add(label1);
		this.add(label2);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setBounds(100, 100, 400, 400);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JLabelDemo();
	}
}
13.5.3 JTextField（文本框）
举例1：
package com.langsin.swing;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import javax.swing.JTextField;
public class JTextFieldDemo extends JFrame {
	JTextFieldDemo(){
		JTextField textField1 = new JTextField();
		JTextField textField2 = new JTextField("第二个文本框");
		JTextField textField3 = new JTextField("第三个文本框");
		textField1.setColumns(10);
		textField2.setEnabled(false);
		textField3.setColumns(20);
		this.setLayout(new FlowLayout());
		this.add(textField1);
		this.add(textField2);
		this.add(textField3);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setBounds(100, 100, 400, 400);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTextFieldDemo();
	}
}
13.5.4 JTextArea（文本区）
举例1：
package com.langsin.swing;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import javax.swing.JTextArea;
public class JTextAreaDemo extends JFrame {
	JTextAreaDemo(String title){
		super(title);
		JTextArea textArea1 = new JTextArea();
		JTextArea textArea2 = new JTextArea("带有初始默认值的文本区",5,15);
		JTextArea textArea3 = new JTextArea(3, 40);
		textArea1.append("往第一个文本区内追加内容");
		textArea2.setEditable(false);
		textArea3.setTabSize(15);
		textArea3.setLineWrap(true);
		this.setLayout(new FlowLayout());
		this.add(textArea1);
		this.add(textArea2);
		this.add(textArea3);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setBounds(100, 100, 500, 300);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTextAreaDemo("文本区示例");
	}
}
13.5.5 JRadioButton（单选按钮）
举例1：
package com.langsin.swing;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
public class JRadioDemo extends JFrame {
	JRadioDemo(){
		super("单选按钮示例");
		JPanel panel = new JPanel();
		panel.setLayout(new GridLayout(1,3));
		panel.setBorder(BorderFactory.createTitledBorder("喜欢哪一家速食店？"));
		JRadioButton jb1 = new JRadioButton("肯德基");
		JRadioButton jb2 = new JRadioButton("德克士");
		JRadioButton jb3 = new JRadioButton("麦当劳");
		ButtonGroup bg = new ButtonGroup();
		bg.add(jb1);
		bg.add(jb2);
		bg.add(jb3);
		panel.add(jb1 );
		panel.add(jb2);
		panel.add(jb3);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setLayout(new GridLayout(2,1));
		this.add(panel);
		this.setBounds(100, 100, 400, 200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		JFrame.setDefaultLookAndFeelDecorated(true);
		new JRadioDemo();
	}
}
13.5.6 JCheckbox（复选框）
举例1：
package com.langsin.swing;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JPanel;
public class JCheckboxDemo extends JFrame {
	JCheckboxDemo(){
		super("复选框示例");
		JPanel panel = new JPanel();
		panel.setLayout(new GridLayout(1,3));
		panel.setBorder(BorderFactory.createTitledBorder("喜欢哪一家速食店？"));
		JCheckBox jb1 = new JCheckBox("肯德基");
		JCheckBox jb2 = new JCheckBox("德克士");
		JCheckBox jb3 = new JCheckBox("麦当劳");
		panel.add(jb1 );
		panel.add(jb2);
		panel.add(jb3);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setLayout(new GridLayout(2,1));
		this.add(panel);
		this.setBounds(100, 100, 400, 200);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JCheckboxDemo();
	}
}
13.5.7 JList（列表框）
package com.langsin.swing;

import java.awt.GridLayout;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JList;
public class JListDemo extends JFrame {
	JListDemo(){
		super("JList组件演示");
		this.setLayout(new GridLayout(1, 2));
		String[] s = {"美国","日本","澳大利亚","英国","法国","意大利"};
		Vector<String> v = new Vector<String>();
		v.add("111");
		v.add("222");
		v.add("333");
		v.add("444");
		JList list1 = new JList(s);
		JList list2 = new JList(v);
		list1.setBorder(BorderFactory.createTitledBorder("最喜欢的国家？"));
		list2.setBorder(BorderFactory.createTitledBorder("最喜欢的数字？"));
		this.add(list1);
		this.add(list2);
		this.setBounds(100, 100, 400, 400);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		JFrame.setDefaultLookAndFeelDecorated(true);
		new JListDemo();
	}
}
此例虽然能很好的展示，但这样把数据和显示放在一起不是很好的方法，违反了MVC的设计模式，所以我们应尽量的将数据（Modal）和显示（View）分开。
如下列所示：

package com.langsin.swing;

import java.awt.GridLayout;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JList;
public class JListDemo extends JFrame {
	JListDemo(){
		super("JList组件演示");
		this.setLayout(new GridLayout(1, 2));
		String[] s = new ListModal().getStringArray();
		Vector<String> v = new ListModal().getData();
		JList list1 = new JList(s);
		JList list2 = new JList(v);
		list1.setBorder(BorderFactory.createTitledBorder("最喜欢的国家？"));
		list2.setBorder(BorderFactory.createTitledBorder("最喜欢的数字？"));
		this.add(list1);
		this.add(list2);
		this.setBounds(100, 100, 400, 400);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		JFrame.setDefaultLookAndFeelDecorated(true);
		new JListDemo();
	}
}

举例2：
public class ListModal{
	public Vector<String> getData(){
		Vector<String> v = new Vector<String>();
		v.add(“111”);
v.add(“222”);
v.add(“333”);
v.add(“444”);
return v;
}
public String[] getStringArray(){
	String[] s = {"美国","日本","澳大利亚","英国","法国","意大利"};
	return s;
}
}
13.5.8 JComboBox（下拉框）
举例1：
package com.langsin.swing;

import java.awt.GridLayout;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.JComboBox;
import javax.swing.JFrame;
public class JComboBoxDemo extends JFrame {
	JComboBoxDemo(){
		super("JComboBox组件演示");
		this.setLayout(new GridLayout(1, 2));
		String[] s = {"美国","日本","澳大利亚","英国","法国","意大利"};
		Vector<String> v = new Vector<String>();
		v.add("111");
		v.add("222");
		v.add("333");
		v.add("444");
		JComboBox list1 = new JComboBox(s);
		JComboBox list2 = new JComboBox(v);
		list1.setBorder(BorderFactory.createTitledBorder("最喜欢的国家？"));
		list2.setBorder(BorderFactory.createTitledBorder("最喜欢的数字？"));
		this.add(list1);
		this.add(list2);
		this.setBounds(100, 100, 400, 88);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JComboBoxDemo();
	}
}
13.6 Swing中的特色组件
13.6.1 JPasswordField（密码框）
JPanel panel = new JPanel(gird);
JLabel label = new JLabel("密码：",JLabel.CENTER);
panel.add(label);
JPasswordField password = new JPasswordField();
panel.add(password);
frame.add(panel,BorderLayout.NORTH);

13.6.2 JScrollPane（滚动条面板）
假如JTextArea包含太多的文本，而给定的空间容纳不下，那么该怎么办？如果认为会出现滚动条，那么很不幸，你猜错了。如果输入的内容超过了给定的空间大小，那么JTextArea将自动扩充。如果文本域设置了自动换行，那么它将自动增加一行，如果没有设置换行，那么文本域的宽度将自动增加。
JScrollPane为Swing组件提供了处理所有与滚动条相关的动作。
举例1：

package com.langsin.swing;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
public class JScrollPaneDemo extends JFrame {
	JScrollPaneDemo(){
		super("带有滚动条的文本域");
		JTextArea textArea = new JTextArea();
		JScrollPane scroll = 
new JScrollPane(textArea,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
		this.add(scroll);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setBounds(100, 100, 400, 400);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JScrollPaneDemo();
	}
}
13.6.3 JToolBar（工具条）
Swing提供了JToolBar来创建工具条，创建JToolBar对象时可以指定两个参数
1、	name：工具条的名称
2、	orientation：该参数指定该工具的方向。
JToolBar对象有如下常用的方法：
?	JButton add(Action act)：通过Action对象为JToolBar添加对应的工具按钮。
?	void addSeparator(Dimension size)：向工具条中添加指定大小的分隔符，如果不指定参数，则添加一个默认大小的分隔符。
?	void setFloatable(boolean b)：设置此工具条是否可浮动，即可以拖动
?	void setMargin(Insets m)：设置工具条边框和工具条中按钮之间的页边距
?	void setOrientation(int o)：设置工具条的方向
?	void setRollover(boolean rollover)：设置此工具条的rollover状态。
举例1：
package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JToolBar;

public class JToolBarDemo extends JFrame {
	private JTextArea jta = new JTextArea(6,35);
	private JToolBar jtb = new JToolBar();
	private JMenuBar jmb = new JMenuBar();
	private JMenu edit = new JMenu("编辑");
	//创建系统剪贴板
	private Clipboard board = Toolkit.getDefaultToolkit().getSystemClipboard();
	//创建粘贴的Action，该Action用于创建菜单项、工具按钮盒普通按钮
	Action pasteAction = new AbstractAction("粘贴",new ImageIcon("./image/paste.png")) {
		public void actionPerformed(ActionEvent e) {
			if(board.isDataFlavorAvailable(DataFlavor.stringFlavor)){
				try {
					String content = board.getData(DataFlavor.stringFlavor).toString();
					//将选中的内容替换成剪贴板中的内容
					jta.replaceRange(content, jta.getSelectionStart(), jta.getSelectionEnd());
				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
		}
	};
	//创建复制的Action
	Action copyAction = new AbstractAction("复制",new ImageIcon("./image/copy.png")) {
		public void actionPerformed(ActionEvent e) {
			StringSelection content = new StringSelection(jta.getSelectedText());
			//将StringSelection对象放入到剪贴板中
			board.setContents(content, null);
			if(board.isDataFlavorAvailable(DataFlavor.stringFlavor)){
				pasteAction.setEnabled(true);
			}
		}
	};
	JToolBarDemo(){
		super("JToolBar示例");
		//将文本域添加到滚动条容器中
		this.add(new JScrollPane(jta));
		pasteAction.setEnabled(false);
		JPanel jp = new JPanel();
		JButton copyBt = new JButton(copyAction);
		JButton pasteBt = new JButton(pasteAction);
		jp.add(copyBt);
		jp.add(pasteBt);
		this.add(jp,BorderLayout.SOUTH);
		this.jtb.add(copyAction);
		this.jtb.addSeparator();
		this.jtb.add(pasteAction);
		this.add(jtb,BorderLayout.NORTH);
		this.edit.add(copyAction);
		this.edit.add(pasteAction);
		this.jmb.add(this.edit);
		this.setJMenuBar(this.jmb);
		this.pack();
		this.setLocation(100, 100);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JToolBarDemo();
	}
}
13.6.4 JProgressBar（进度条）
使用JProgressBar（进度条）、ProgressMonitor（进度对话框），进度条是图形界面中广泛使用的GUI组件，当复制一个较大的文件时，操作系统会显示一个进度条，用于标识复制操作完成的比例。
一、使用JProgressBar创建进度条，有如下步骤
1、创建一个JProgressBar对象，创建该对象时可以指定3个参数，用于设置进度条的排列方向，进度条的最大值和最小值。也可以在创建该对象完成后，单独进行设置这3个属性。
JProgressBar bar = new JProgressBar(JPorgressBar.VERTICAL);
2、调用该对象的常用方法设置进度条的普通属性。JProgressBar除了提供设置排列方向、最大值、最小值的setter和getter方法之外，还提供了如下方法：
setBorderPainted(boolean b)：设置该进度条是否使用边框。
setIndeterminate(boolean newValue)：设置该进度条是否是进度不正确的进度条，如果指定一个进度条的进度不正确，将看到一个滑块在进度条中左右移动。
setStringPainted(boolean newValue)：设置是否在此进度条中显示完成百分比。
setValue()：当进度发生更改时调用此方法重新设值。
double getPercentComplete()：返回进度条的完成百分比
String getString()：返回进度字符串的当前值。
举例1：
package com.langsin.swing;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JProgressBar;
public class JProgressBarDemo extends JFrame {
	//创建一个进度条
	private JProgressBar bar = new JProgressBar(JProgressBar.HORIZONTAL);
	private JCheckBox indeterminate = new JCheckBox("不确定进度");
	private JCheckBox noBorder = new JCheckBox("不绘制边框");
	JProgressBarDemo(){
		super("进度条实例");
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(this.indeterminate);
		box.add(this.noBorder);
		this.setLayout(new FlowLayout());
		this.add(box);
		this.add(this.bar);
		this.bar.setMinimum(0);
		this.bar.setMaximum(100);
		this.bar.setStringPainted(true);
		this.noBorder.addActionListener(new ActionListener() {
			
			public void actionPerformed(ActionEvent e) {
				bar.setBorderPainted(!noBorder.isSelected());
			}
		});
		this.indeterminate.addActionListener(new ActionListener() {
			
			public void actionPerformed(ActionEvent e) {
				bar.setIndeterminate(indeterminate.isSelected());
				bar.setStringPainted(!indeterminate.isSelected());
			}
		});
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.pack();
		this.setLocation(100, 100);
		this.setVisible(true);
		for(int i=0;i<100;i++){
			bar.setValue(i+1);
			try {
				Thread.sleep(100);
			} catch (Exception e1) {
				e1.printStackTrace();
			}
		}
	}
	public static void main(String[] args) {
		new JProgressBarDemo();
	}
}
二、使用ProgressMonitor创建进度对话框，ProgressMonitor的用法与JProgressBar的用法基本相似。
构造方法如下：
ProgressMonitor(Component parentComponent,Object message,String note,int min,int max)：该构造器中parentComponent参数用于设置该进度对话框的父组件，message用于设置该进度对话框的描述信息，note用于设置该进度对话框的提示文本，min和max用于设置该对话框所包含的进度条的最小值最大值。
举例1：
package com.langsin.swing;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JFrame;
import javax.swing.ProgressMonitor;
import javax.swing.Timer;
public class ProgressMonitorDemo extends JFrame {
	private Timer timer;
	ProgressMonitorDemo(){
		//根据线程类来创建一个线程实例对象
		final SimulatedActivity target = new SimulatedActivity(1000);
		//根据线程类来构建一个新的线程实例对象
		final Thread targetThread = new Thread(target);
		targetThread.start();
		final ProgressMonitor dialog = new ProgressMonitor(null,"等待任务完成","已完成：",0,target.getAmount());
		timer = new Timer(300,new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				dialog.setProgress(target.getCurrent());
				dialog.setNote("已完成："+(target.getCurrent()*100/target.getAmount())+"%");
				if(dialog.isCanceled()){
					timer.stop();
					targetThread.interrupt();
					System.exit(0);
				}
			}
		});
		timer.start();
	}
	public static void main(String[] args) {
		new ProgressMonitorDemo();
	}
}
//通过实现Runnable接口来实现一个线程类
class SimulatedActivity implements Runnable{
	private volatile int current;
	private int amount;
	SimulatedActivity(int amount){
		this.current = 0;
		this.amount = amount;
	}
	public int getCurrent() {
		return current;
	}
	public int getAmount() {
		return amount;
	}
	public void run() {
		while(this.current<this.amount){
			try {
				Thread.sleep(100);
			} catch (Exception e) {
				e.printStackTrace();
			}
			this.current++;
		}
	}
}

实例3：读取文件显示完成的百分比
package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.ProgressMonitor;
import javax.swing.Timer;

public class Test {
	
	public Timer timer = null;
	public InputStream stream = null;
	public long totalSize = 0;
	public long currentSize = 0;
	public byte[] bts = new byte[100];
	public ProgressMonitor pm = null;
	public ActionListener action = new ActionListener(){
		@Override
		public void actionPerformed(ActionEvent e) {
			if(currentSize<totalSize){
				try {
					int read = stream.read(bts);
					if(read>0){
						currentSize = currentSize + read;
						float value = currentSize*100/totalSize;
						pm.setProgress((int)value);
						pm.setNote("已完成："+value+"%");
					}else{
						timer.stop();
					}
				} catch (Exception e2) {
					
				}	
			}else{
				timer.stop();
			}
		}
	};
	public Test(){
		final JFrame frame = new JFrame("JTree");
		frame.setBounds(100, 100, 500, 500);
		JPanel pan = new JPanel();
		JButton btn = new JButton("读取文件");
		pan.add(btn);
		frame.add(pan,BorderLayout.NORTH);
		try {
			File file = new File("./aaa.txt");
			stream = new FileInputStream(file);
			totalSize = file.length();
		} catch (Exception e1) {
			e1.printStackTrace();
		}
		pm = new ProgressMonitor(frame, "读取文件完成度", "已完成：", 0, 100);
		timer = new Timer(200,action);
		
		btn.addActionListener(new ActionListener() {
			
			@Override
			public void actionPerformed(ActionEvent e) {
				timer.start();
			}
		});
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setVisible(true);
	}
	public static void main(String[] args) {
		new Test();
	}
}
13.6.5 JSlider创建滑动条
	JSlider和JProgressBar的用法非常相似，都继承了javax.swing.JComponent类。JSlider与JProgressBar的主要区别是：
1、	JSlider允许用户手动改变滑动条的值。
2、	JSlider允许为滑动条指定刻度值，刻度值既可以是连续的数字，也可以是自定义的刻度值，甚至是图标。

使用JSlider创建滑动条的步骤如下：
1、	使用构造方法来创建一个JSlider对象，JSlider jslider = new JSlider(int orientation, int min, int max, int value);参数orientation：指定该滑动条的摆放方向，默认是水平摆放。可以接收JSlider.VERTICAL和JSlider.HORIZONTAL两个值。min：滑动条的最小值，默认为0。max：滑动条的最大值，默认为100。value指定该滑动条的当前值，该属性值默认为50。
2、	设置JSlider滑动条的外观样式。
?	setExtent(int extent)：设置滑动条上的保留区，用户拖动滑块时不能超过保留区。例如，最大值为100的滑动条，如果设置了保留区为20，则滑块最大只能拖动到80.
?	setInveted(boolean b)：设置是否需要反转滑动条，滑动条的滑轨上刻度值默认从小到大、从左到右排列。如果该方法设置为true，则排列方向会反转过来。
?	setLabelTable(Dictionary labels)：为该滑动条指定刻度标签。
?	setMajorTickSpacing(int n)：设置主刻度标记的间隔。
?	setMinorTickSpacing(int n)：设置次刻度标记的间隔。
?	setPaintLabels(boolean b)：设置是否在滑块上绘制刻度标签。如果没有为该滑块指定刻度标签则默认绘制将刻度值的数值作为标签。
?	setPaintTicks(boolean b)：设置是否在滑块上绘制刻度标记。
?	setPaintTrack(boolean b)：设置是否为滑块绘制滑轨。
?	setSnapToTicks(boolean b)：设置滑块是否必须停在滑到的有刻度处。
3、	如果程序需要在用户拖动滑块时做出相应处理，则应为该JSlider对象添加事件监听器JSlider提供了addChangeListener()方法来添加事件监听器，该监听器负责监听滑动值的变化。
4、	将JSlider对象添加到其他容器中去。
举例1：
package com.langsin.swing;

import java.awt.BorderLayout;
import java.util.Dictionary;
import java.util.Hashtable;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JSlider;
import javax.swing.JTextField;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
public class JSliderDemo extends JFrame {
	private Box silderBox = new Box(BoxLayout.Y_AXIS);
	private JTextField field = new JTextField();
	private ChangeListener listener;
	JSliderDemo(){
		super("滑动条示例");
		//定义一个监听器，监听所有的滑动条
		listener = new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				//取出滑动条的值，并在文本中显示出来
				JSlider source = (JSlider)e.getSource();
				field.setText("当前滑动条的值："+source.getValue());
			}
		};
		//==============添加一个普通的滑动条==================
		JSlider slider = new JSlider();
		this.addSlider(slider, "普通滑动条");
		//==============添加一个保留区为30的滑动条==============
		slider = new JSlider();
		slider.setExtent(30);
		this.addSlider(slider, "保留区为30");
		//==============添加一个带主次刻度的滑动条==============
		slider = new JSlider(30,200);
		slider.setMinorTickSpacing(5);
		slider.setMajorTickSpacing(20);
		slider.setPaintTicks(true);
		this.addSlider(slider, "有刻度：");
		//==============滑块必须停留在刻度处==============
		slider = new JSlider();
		slider.setSnapToTicks(true);
		slider.setPaintTicks(true);
		slider.setMinorTickSpacing(5);
		slider.setMajorTickSpacing(20);
		this.addSlider(slider, "滑块停留在刻度处：");
		//==============无滑轨的滑动条==================
		slider = new JSlider();
		slider.setPaintTicks(true);
		slider.setMinorTickSpacing(5);
		slider.setMajorTickSpacing(20);
		slider.setPaintTrack(false);
		this.addSlider(slider, "无滑轨：");
		//==============设置显示刻度值的滑动条=============
		slider = new JSlider();
		slider.setPaintTicks(true);
		slider.setMinorTickSpacing(5);
		slider.setMajorTickSpacing(20);
		slider.setPaintLabels(true);
		this.addSlider(slider, "数值刻度标签：");
		//==============添加绘制Label类型的标签==========
		slider = new JSlider();
		slider.setPaintTicks(true);
		slider.setMinorTickSpacing(5);
		slider.setMajorTickSpacing(20);
		slider.setPaintLabels(true);
		Dictionary<Integer,JLabel> labelTable = new Hashtable<Integer, JLabel>();
		labelTable.put(0, new JLabel("A"));
		labelTable.put(20, new JLabel("B"));
		labelTable.put(40, new JLabel("C"));
		labelTable.put(60, new JLabel("D"));
		labelTable.put(80, new JLabel("E"));
		labelTable.put(100, new JLabel("F"));
		slider.setLabelTable(labelTable);
		this.addSlider(slider, "JLabel标签：");
		//==============设置窗体=======================
		this.add(silderBox,BorderLayout.CENTER);
		this.add(field,BorderLayout.SOUTH);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setLocation(100, 100);
		this.pack();
		this.setVisible(true);
	}
	private void addSlider(JSlider slider,String description){
		slider.addChangeListener(listener);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add( new JLabel(description+"："));
		box.add(slider);
		this.silderBox.add(box);
	}
	public static void main(String[] args) {
		new JSliderDemo();
	}
}
13.6.6 Jtree和TreeModal
	树也是图形用户界面中使用非常广泛的GUI组件，例如Windows资源管理器看到的目录树。
	Swing中使用JTree对象来代表一颗树，JTree树中节点可以使用TreePath来标识，该对象封装了当前节点及其所有的父节点。当一个节点具有子节点时，该节点有两种状态。1、展开状态：当父节点处于展开状态时，子节点是可见的；2、折叠状态：当父节点处于折叠状态时，子节点是不可见的。如果某个节点是可见的，那么此节点的父节点以及间接的父节点都必须是可见的，即展开状态；只要有任意一个节点处于折叠状态，该节点不可见。
	创建一个树直接使用JTree的的构造方法即可，JTree提供如下几个常用构造器：
?	JTree(TreeModal newModal)：使用指定的数据模型创建JTree对象，它默认显示根节点。
?	JTree(TreeNode root)：使用root作为根节点创建JTree对象，它默认显示根节点。
?	JTree(TreeNode root,boolean asksAllowsChildren)：使用root作为根节点创建JTree对象，它默认显示根节点。asksAllowsChildren参数控制怎样的节点才算是叶子节点，如果该参数为true，则只有当程序使用setAllowsChildren(false)显式设置某个节点不允许添加子节点时，该节点才会被JTree当成叶子节点，如果该参数为false，则只要某个节点当时没有子节点，该节点都会被当成叶子节点。
常用方法：
?	void updateUI()：将当前的JTree对象进行重绘。
举例1：
package com.langsin.swing;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
public class JTreeDemo  extends JFrame{
	//创建一个树的对象
	private JTree tree = null;
	JTreeDemo(){
		super("简单的树形例子");
		//使用DefaultMutableTreeNode类来创建树的节点对象
		//首先创建一个根节点
		DefaultMutableTreeNode root = new DefaultMutableTreeNode("中国");
		//再创建root下的几个子节点
		DefaultMutableTreeNode gd = new DefaultMutableTreeNode("广东");
		DefaultMutableTreeNode gx = new DefaultMutableTreeNode("广西");
		DefaultMutableTreeNode sd = new DefaultMutableTreeNode("山东");
		//对创建的几个根节点添加他的几个子节点
		DefaultMutableTreeNode fs = new DefaultMutableTreeNode("佛山");
		DefaultMutableTreeNode st = new DefaultMutableTreeNode("汕头");
		DefaultMutableTreeNode jn = new DefaultMutableTreeNode("济南");
		DefaultMutableTreeNode qd = new DefaultMutableTreeNode("青岛");
		gd.add(fs);
		gx.add(st);
		sd.add(jn);
		sd.add(qd);
		root.add(gd);
		root.add(gx);
		root.add(sd);
		//实例化我们的tree对象
		tree = new JTree(root);
		this.add(new JScrollPane(tree));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTreeDemo();
	}
}
DefaultMutableTreeNode是JTree默认的树节点，该类提供了大量的方法来访问树中的节点，常用的方法：
?	DefaultMutableTreeNode getNextSibling()：返回此节点的下一个兄弟节点。
?	TreeNode getParent()：返回此节点的父节点，如果没有父节点则返回null。
?	TreeNode[] getPath()：返回从根节点到达此节点的所有节点组成的数组。
?	DefaultMutableTreeNode getPreviousSibing()：返回此节点的上一个兄弟节点。
?	TreeNode getRoot()：返回树的根节点
?	TreeNode getSharedAncestor(DefaultMutableTreeNode node)：返回此节点和node最近的共同祖先。
?	int getSiblingCount()：返回此节点的兄弟节点数。
?	boolean isLeaf()：返回该节点是否叶子节点。
?	boolean isNodeAncestor(TreeNode antherNode)：判断antherNode是否是当前节点的祖先节点。
?	boolean isNodeChild(TreeNode aNode)：如果aNode是此节点的子节点，则返回true。
?	boolean isRoot()：返回当前节点是否是根节点。
?	boolean isNodeSibling(TreeNode antherNode)：返回antherNode是否是当前节点的兄弟节点。
举例2：创建一个可动态编辑的节点树

package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

public class JTreeDemo  extends JFrame{
	//创建一个树的对象
	private JTree tree = null;
	private DefaultTreeModel model;
	//要进行移动的节点
	private TreePath movePath;
	JTreeDemo(){
		super("简单的树形例子");
		//使用DefaultMutableTreeNode类来创建树的节点对象
		//首先创建一个根节点
		DefaultMutableTreeNode root = new DefaultMutableTreeNode("中国");
		//再创建root下的几个子节点
		DefaultMutableTreeNode gd = new DefaultMutableTreeNode("广东");
		DefaultMutableTreeNode gx = new DefaultMutableTreeNode("广西");
		DefaultMutableTreeNode sd = new DefaultMutableTreeNode("山东");
		//对创建的几个根节点添加他的几个子节点
		DefaultMutableTreeNode fs = new DefaultMutableTreeNode("佛山");
		DefaultMutableTreeNode st = new DefaultMutableTreeNode("汕头");
		DefaultMutableTreeNode jn = new DefaultMutableTreeNode("济南");
		DefaultMutableTreeNode qd = new DefaultMutableTreeNode("青岛");
		gd.add(fs);
		gx.add(st);
		sd.add(jn);
		sd.add(qd);
		root.add(gd);
		root.add(gx);
		root.add(sd);
		//实例化我们的tree对象
		tree = new JTree(root);
		this.add(new JScrollPane(tree));
		//添加操作按钮
		JButton addSiblingButton = new JButton("添加兄弟节点");
		JButton addChildButton = new JButton("添加子节点");
		JButton deleteButton = new JButton("删除节点");
		JButton editButton = new JButton("编辑当前节点");
		JPanel panel = new JPanel();
		panel.add(addSiblingButton);
		panel.add(addChildButton);
		panel.add(deleteButton);
		panel.add(editButton);
		this.add(panel,BorderLayout.SOUTH);
		model = (DefaultTreeModel)tree.getModel();
		tree.setEditable(true);
		//为按钮添加事件处理
		MouseListener ml = new MouseAdapter() {
			/**
			 * 鼠标按下时触发事件
			 * */
			public void mousePressed(MouseEvent e) {
				//TreePath表示节点的路径。TreePath 是 TreeModel 提供的 Objects 的数组。
				TreePath tp = tree.getPathForLocation(e.getX(), e.getY());
				if(tp!=null){
					movePath = tp;
				}
			}
			/**
			 * 松开鼠标时触发的事件
			 * */
			public void mouseReleased(MouseEvent e) {
				TreePath tp = tree.getPathForLocation(e.getX(), e.getY());
				if(tp!=null && movePath!=null){
					//isDescendant(TreePath tp)方法，判断此节点tp节点是否是当前节点的子节点
					if(movePath.isDescendant(tp) && tp!=movePath){
						JOptionPane.showMessageDialog(JTreeDemo.this,"目标节点是被移动节点的子节点，无法移动！","非法操作",JOptionPane.ERROR_MESSAGE);
						return;
					}else if(movePath!=tp){
						//getLastPathComponent()方法，返回此路径下的最后一个节点组件
						((DefaultMutableTreeNode)tp.getLastPathComponent()).add((DefaultMutableTreeNode)movePath.getLastPathComponent());
						movePath = null;
						//updateUI()方法，对当前树进行重绘
						tree.updateUI();
					}
				}
			}
		};
		//为当前树组件对象添加鼠标监听器
		tree.addMouseListener(ml);
		addSiblingButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				DefaultMutableTreeNode selectNode = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
				if(selectNode==null){
					JOptionPane.showMessageDialog(JTreeDemo.this, "请选择节点进行操作！","非法操作",JOptionPane.ERROR_MESSAGE);
					return;
				}
				DefaultMutableTreeNode parent = (DefaultMutableTreeNode)selectNode.getParent();
				if(parent==null){
					JOptionPane.showMessageDialog(JTreeDemo.this, "此节点无父节点，无法添加兄弟节点！","非法操作",JOptionPane.ERROR_MESSAGE);
					return;
				}
				DefaultMutableTreeNode newNode = new DefaultMutableTreeNode("新节点");
				int selectedIndex = parent.getIndex(selectNode);
				model.insertNodeInto(newNode, parent, selectedIndex+1);
				TreeNode[] nodes = model.getPathToRoot(newNode);
				TreePath path = new TreePath(nodes);
				tree.scrollPathToVisible(path);
			}
		});
		addChildButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				DefaultMutableTreeNode selectNode = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
				if(selectNode==null){
					JOptionPane.showMessageDialog(JTreeDemo.this, "请选择节点进行操作！","非法操作",JOptionPane.ERROR_MESSAGE);
					return;
				}
				DefaultMutableTreeNode newNode = new DefaultMutableTreeNode("新节点");
				selectNode.add(newNode);
				TreeNode[] nodes = model.getPathToRoot(newNode);
				TreePath path = new TreePath(nodes);
				tree.scrollPathToVisible(path);
				tree.updateUI();
			}
		});
		deleteButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				DefaultMutableTreeNode selectNode = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
				if(selectNode==null){
					JOptionPane.showMessageDialog(JTreeDemo.this, "请选择节点进行操作！","非法操作",JOptionPane.ERROR_MESSAGE);
					return;
				}else if(selectNode.getParent()==null){
					JOptionPane.showMessageDialog(JTreeDemo.this, "至少保留一个节点！","非法操作",JOptionPane.ERROR_MESSAGE);
				}else{
					model.removeNodeFromParent(selectNode);
				}
			}
		});
		editButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				TreePath selectedPath = tree.getSelectionPath();
				if(selectedPath != null){
					//startEditingAtPath(TreePath tp)方法，选择指定路径标识的节点，并开始编辑。
					tree.startEditingAtPath(selectedPath);
				}
			}
		});
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTreeDemo();
	}
}
13.6.7 使用DefaultTreeCellRenderer改变节点外观
改变树节点的外观样式，可以有如下3种方式：
?	使用DefaultTreeCellRenderer直接改变节点的外观，这种方式可以改变整棵树所有节点的字体、颜色和图标。
?	为JTree指定DefaultTreeCellRenderer的扩展类对象作为JTree的节点绘制器，该绘制器负责为不同节点使用不同的字体、颜色和图标。通常使用这种方式来改变节点的外观。
?	为JTree指定一个实现TreeCellRenderer接口的节点绘制器，该绘制器可以为不同的节点自由绘制任意内容，这是最复杂但最灵活的节点绘制器。
举例1：第二种方式
	DefaultTreeCellRenderer实现类实现了TreeCellRenderer接口，该接口里只有一个用于绘制节点内容的方法：
getTreeCellRendererComponent()，该方法负责绘制JTree节点。
	DefaultTreeCellRenderer类继承了JLabel，实现getTreeCellRendererComponent()方法时返回this，即返回一个特殊的JLabel对象，如果需要根据节点内容来改变节点的外观，则可以再次扩展DefaultTreeCellRenderer类，并再次重写它提供的getTreeCellRendererComponent()方法。
package com.langsin.swing;

import java.awt.Component;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;

public class DefaultTreeCellRendererDemo extends JFrame {
	private JTree tree = null;
	private DefaultMutableTreeNode root = new DefaultMutableTreeNode(new NodeData(DBobjectType.ROOT,"数据库导航"));
	private DefaultMutableTreeNode salaryDb = new DefaultMutableTreeNode(new NodeData(DBobjectType.DATABASE, "公司工资数据库"));
	private DefaultMutableTreeNode customerDb = new DefaultMutableTreeNode(new NodeData(DBobjectType.DATABASE, "公司客户数据库"));
	private DefaultMutableTreeNode employee = new DefaultMutableTreeNode(new NodeData(DBobjectType.TABLE, "员工表"));
	private DefaultMutableTreeNode attend = new DefaultMutableTreeNode(new NodeData(DBobjectType.TABLE, "考勤表"));
	private DefaultMutableTreeNode contact = new DefaultMutableTreeNode(new NodeData(DBobjectType.TABLE, "联系方式表"));
	private DefaultMutableTreeNode id = new DefaultMutableTreeNode(new NodeData(DBobjectType.COLUMN, "员工ID"));
	private DefaultMutableTreeNode name = new DefaultMutableTreeNode(new NodeData(DBobjectType.COLUMN, "姓名"));
	private DefaultMutableTreeNode gender = new DefaultMutableTreeNode(new NodeData(DBobjectType.COLUMN, "性别"));
	DefaultTreeCellRendererDemo(){
		//建立父子关系
		this.root.add(this.salaryDb);
		this.root.add(this.customerDb);
		this.salaryDb.add(this.employee);
		this.salaryDb.add(this.attend);
		this.customerDb.add(this.contact);
		this.employee.add(this.id);
		this.employee.add(this.name);
		this.employee.add(this.gender);
		//以根节点root创建树
		tree = new JTree(this.root);
		//设置tree使用自定义的节点绘制器
		tree.setCellRenderer(new MyRenderer());
		//设置是否显示根节点的展开/折叠图标，默认为fasle
		tree.setShowsRootHandles(true);
		//设置节点是否可见
		tree.setRootVisible(true);
		//设置使用windows风格的外观
		try {
			UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
		} catch (Exception e) {
			e.printStackTrace();
		} 
		SwingUtilities.updateComponentTreeUI(tree);
		this.add(new JScrollPane(tree));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new DefaultTreeCellRendererDemo();
	}
}
/**
 * 定义一个NodeData类，用于封装节点数据
 * */
class NodeData{
	public int nodeType;
	public String nodeData;
	public NodeData(int nodeType,String nodeData){
		this.nodeType = nodeType;
		this.nodeData = nodeData;
	}
	public String toString(){
		return this.nodeData;
	}
}
/**
 * 定义接口，该接口中包含数据库对象类型的常量
 * */
interface DBobjectType{
	int ROOT = 0;
	int DATABASE = 1;
	int TABLE = 2;
	int COLUMN = 3;
	int INDEX = 4;
}
class MyRenderer extends DefaultTreeCellRenderer{
	//初始化5个图标
	ImageIcon  rootIcon = new ImageIcon("./image/root.gif");
	ImageIcon dataBaseIcon = new ImageIcon("./image/database.gif");
	ImageIcon tabelIcon = new ImageIcon("./image/table.gif");
	ImageIcon columnIcon = new ImageIcon("./image/column.gif");
	ImageIcon indexIcon = new ImageIcon("./image/index.gif");
	@Override
	public Component getTreeCellRendererComponent(JTree tree, Object value,
			boolean sel, boolean expanded, boolean leaf, int row,
			boolean hasFocus) {
		//执行父类默认的节点绘制操作
		super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf,
				row, hasFocus);
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
		NodeData data = (NodeData)node.getUserObject();
		ImageIcon icon = null;
		switch (data.nodeType) {
		case DBobjectType.ROOT:
				icon = this.rootIcon;
				break;
		case DBobjectType.DATABASE:
				icon = this.dataBaseIcon;
				break;
		case DBobjectType.TABLE:
				icon = this.tabelIcon;
				break;
		case DBobjectType.COLUMN:
				icon = this.columnIcon;
				break;
		case DBobjectType.INDEX:
				icon = this.indexIcon;
				break;
		}
		this.setIcon(icon);
		return this;
	}
}
13.6.8 使用TreeCellRenderer改变节点外观
	这种方式最灵活，程序实现TreeCellRenderer接口时同样需要实现getTreeCellRendererComponent()方法，该方法可以返回任意类型的组件，该组件将作为JTree的节点。通过这种方式可以最大程度地改变JTree的节点外观。
举例1：
package com.langsin.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeCellRenderer;

public class CustomTreeNode extends JFrame {
	//定义一棵树
	private JTree  tree = null;
	//定义几个节点
	private DefaultMutableTreeNode friends = new DefaultMutableTreeNode("我的好友");
	private DefaultMutableTreeNode lqz = new DefaultMutableTreeNode("李清照");
	private DefaultMutableTreeNode sgl = new DefaultMutableTreeNode("苏格拉底");
	private DefaultMutableTreeNode lb = new DefaultMutableTreeNode("李白");
	private DefaultMutableTreeNode ny = new DefaultMutableTreeNode("弄玉");
	private DefaultMutableTreeNode ht = new DefaultMutableTreeNode("虎头");
	public CustomTreeNode(){
		this.friends.add(lqz);
		this.friends.add(sgl);
		this.friends.add(lb);
		this.friends.add(ny);
		this.friends.add(ht);
		tree = new JTree(this.friends);
		tree.setShowsRootHandles(true);
		tree.setRootVisible(true);
		//设置使用定制的节点绘制器
		tree.setCellRenderer(new ImageCellRenderer());
		this.add(new JScrollPane(tree));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new CustomTreeNode();
	}
}
class ImageCellRenderer extends JPanel implements TreeCellRenderer{
	
	private ImageIcon icon = null;
	private String name = null;
	private Color background = null;
	private Color foreground = null;
	
	/**
	 * 此方法只需要对要返回的组件对象进行一个初始化即可
	 * */
	public Component getTreeCellRendererComponent(JTree tree, Object value,
			boolean selected, boolean expanded, boolean leaf, int row,
			boolean hasFocus) {
		icon = new ImageIcon("./image/"+value+".gif");
		name = value.toString();
		//设置图片选中时的背景色及前景色
		this.background = hasFocus ? new Color(140,200,235) : new Color(255,255,255);
		this.foreground = hasFocus ? new Color(255,255,3) : new Color(0,0,0);
		return this;
	}
	//重写paintComponent方法，改变JPanel的外观，在面板上进行绘画
	@Override
	protected void paintComponent(Graphics g) {
		int imageWidth = icon.getImage().getWidth(null);
		int imageHeight = icon.getImage().getHeight(null);
		g.setColor(background);
		//根据面板的宽度getWidth()和高度getHeight()来对面板进行填充背景色
		g.fillRect(0, 0, this.getWidth(), this.getHeight());
		g.setColor(foreground);
		//进行图片绘画，让图片居中显示，需要根据面板的宽度与图片的宽度值进行相减计算得出
		g.drawImage(icon.getImage(), getWidth()/2-imageWidth/2, 10, null);
		g.setFont(new Font("微软雅黑",Font.PLAIN,13));
		//绘制字体，字体的长度需呀在字符的长度上与字体的样式中的字体大小相乘得出具体的长度
		g.drawString(name,getWidth()/2-name.length()*13/2, imageHeight + 30);
	}
	
	//通过此方法来设置ImageCellRenderder的最佳大小
	public Dimension getPreferredSize() {
		return new Dimension(80,80);
	}
}
13.6.9 使用JTable创建表格
	使用JTable来创建表格式非常容易的事情，JTable可以把一个二维数据包装成一个表格，这个二维数据既可以是一个二维数组，也可以是集合元素为Vector的Vector对象，Vector里包含Vector形成二维数据。除此之外，为了给该表格的每一列指定列标题，还需要传入一个一维数据作为列标题，这个一维数据既可以是一维数组也可以是Vector对象。
举例1：
package com.langsin.swing;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
public class JTableDemo extends JFrame {
	//定义一维数据作为列标题
	private Object[] columnTitle = {"姓名","年龄","性别"};
	private JTable table = null;
	Object[][] tableData = {{"李清照","29","女"},{"苏格拉底","56","男"},{"李白","35","男"},{"弄玉","18","女"},{"虎头","2","男"}};
	JTableDemo(){
		super("表格示例");
		table = new JTable(tableData,columnTitle);
		//并将table放入带有滚动条的面板中显示出来
		this.add(new JScrollPane(table));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTableDemo();
	}
}
在默认情况下，JTable的所有单元格、列标题显示的全部是字符串内容，除此之外，通常应该将JTable对象放入在JScrollPane容器中，由JScrollPane为JTable提供展示。
JTable提供了一个setAutoResizeMode()方法来控制单元格调整方式，该方法可以接收如下几个值：
?	JTable.AUTO_RESIZE_OFF：关闭JTable的自动调整功能，当调整某一列的宽度时，其他列的宽度不会发生改变，只有表格的宽度会随之改变。
?	JTable.AUTO_RESIZE_NEXT_COLUMN：只调整下一列的宽度，其他列及表格的宽度不会发生改变。
?	JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS：平均调整当前列后面所有列的宽度，当前列的前面所有列及表格的宽度都不会发生变化，这是默认的调整方式。
?	JTable.AUTO_RESIZE_LAST_COLUMNS：只调整最后一列的宽度，其他列及表格的宽度不会发生改变。
?	JTable.AUTO_RESIZE_ALL_COLUMNS：平均调整表格中所有列的宽度，表格的宽度不会发生改版。
JTable默认采用平均调整当前列后所有列的宽度的方式，这种方式允许用户从左到右依次调整每一列的宽度。
如果需要精确控制每一列的宽度，则可通过TableColumn对象来实现。JTable使用TableColumn来标识表格中的每一列，常用方法如下：
1、	setMaxWidth(int maxWidth)：设置该列的最大宽度，如果指定的maxWidth小于该列的最小宽度，则maxWidth被设置成最小宽度。
2、	setMinWidth(int minWidth)：设置该列的最小宽度。
3、	setPerferedWidth(int perferredWidth)：设置该列的最佳宽度。
4、	setResizable(boolean isResizable)：设置是否可以调整该列的宽度。
5、	sizeWidthToFit()：调整该列的宽度，以合适其标题单元格的宽度。

在默认情况下，单击JTable的任意一个单元格时，系统默认会选中该单元格所在行的整行，也可以通过setRowSelectionAllowed()方法来改变这种设置，如果该方法传入false参数，则可以关闭这种每次选择一行的方式。调用setColumnSelectionAllowed()方法，如果传入true参数，则会选中单元格所在的列。如果同时调用了上述两个方法：setRowSelectionAllowed(true)和setColoumnSelectionAllowed(true)则会选中单元格，此操作等同于调用方法setCellSelectionEnabled(true)，如果此方法传入参数false，等同于同时调用了方法setRowSelectionAllowed(false)和setColumnSelectionAllowed(false)。
JTable使用ListSelectionModel表示该表格的选择状态，可以通过ListSelectionModel来控制JTable的选择模式。JTable有如下3中选择模式：
1、	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION：没有任何限制，可以选择表格中任何单元格。默认选择模式，可以通过shift或者Ctrl键来选择多个单元格。
2、	ListSelectionModel.SINGLE_INTERVAL_SELECTION：选择单个连续的区域，该选项可以选择多个表格单元，单是表格单元格之间必须是连续的。
3、	ListSelectionModel.SINGLE_SELECTION：只能选择单个表格单元。
举例1：
package com.langsin.swing;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.ButtonGroup;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.table.TableColumn;

public class JTableDemo1 extends JFrame {
	//定义一个菜单栏条目
	private JMenuBar menBar = new JMenuBar();
	//定义三个菜单
	private JMenu adjustModeMenu = new JMenu("调整方式");
	private JMenu selectUnitMenu = new JMenu("选择单元");
	private JMenu selectModeMenu = new JMenu("选择方式");
	//定义5个单选按钮，用于控制表格的宽度调整
	private JRadioButtonMenuItem[] adjustModesItem = new JRadioButtonMenuItem[5];
	//定义3个单选按钮，用于控制表格的选择方式
	private JRadioButtonMenuItem[] selectModesItem = new JRadioButtonMenuItem[3];
	private JCheckBoxMenuItem rowsItem = new JCheckBoxMenuItem("选择行");
	private JCheckBoxMenuItem columnsItem = new JCheckBoxMenuItem("选择列");
	private JCheckBoxMenuItem cellsItem = new JCheckBoxMenuItem("选择单元格");
	private ButtonGroup adjustBg = new ButtonGroup();
	private ButtonGroup selectBg = new ButtonGroup();
	//定义一个int类型的数组，用于保存表格所有的宽度调整方式
	int[] adjustModes = new int[]{
			JTable.AUTO_RESIZE_OFF, //关闭自动调整
			JTable.AUTO_RESIZE_NEXT_COLUMN, //只调整下一列
			JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS, //平均调整后面各列
			JTable.AUTO_RESIZE_LAST_COLUMN, //只调整最后一列
			JTable.AUTO_RESIZE_ALL_COLUMNS //平均调整各列
	};
	//定义一个int类型数组，用于保存表格的选择模式
	int[] selectModes = new int[]{
			ListSelectionModel.MULTIPLE_INTERVAL_SELECTION, //没有任何限制，默认方式
			ListSelectionModel.SINGLE_INTERVAL_SELECTION, //选择单个连续区域
			ListSelectionModel.SINGLE_SELECTION //选择单个表格单元
	};
	private JTable table = null;
	//定义二维数组作为表格数据
	private Object[][] tableData = {
			{"李清照","29","女"},
			{"苏格拉底","56","男"},
			{"李白","35","男"},
			{"弄玉","18","女"},
			{"虎头","2","男"}
	};
	//定义一维数据作为列标题
	private Object[] columnTitle = {"姓名","年龄","性别"};
	
	JTableDemo1(){
		super("调整表格列宽");
		this.table = new JTable(this.tableData,this.columnTitle);
		this.adjustModesItem[0] = new JRadioButtonMenuItem("只调整表格");
		this.adjustModesItem[1] = new JRadioButtonMenuItem("只调整下一列");
		this.adjustModesItem[2] = new JRadioButtonMenuItem("平均调整余下列");
		this.adjustModesItem[3] = new JRadioButtonMenuItem("只调整最后一列");
		this.adjustModesItem[4] = new JRadioButtonMenuItem("平均调整所有列");
		//将菜单“调整方式”加入到菜单栏中
		this.menBar.add(this.adjustModeMenu);
		//遍历菜单项，将菜单项加入到菜单“调整方式”中，默认选中调整方式为平均调整后面各列
		for(int i=0;i<this.adjustModesItem.length;i++){
			if(i==2){
				this.adjustModesItem[i].setSelected(true);
			}
			//将可选菜单项加入到组中
			this.adjustBg.add(this.adjustModesItem[i]);
			this.adjustModeMenu.add(this.adjustModesItem[i]);
			final int index = i;
			//为每个菜单添加事件，菜单选中时，更改表格中的单元格的调整方式
			this.adjustModesItem[i].addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					if(adjustModesItem[index].isSelected()){
						table.setAutoResizeMode(adjustModes[index]);
					}
				}
			});
		}
		//设置表格的选择模式
		this.selectModesItem[0] = new JRadioButtonMenuItem("无限制");
		this.selectModesItem[1] = new JRadioButtonMenuItem("单独的连续区");
		this.selectModesItem[2] = new JRadioButtonMenuItem("单选");
		this.menBar.add(this.selectModeMenu);
		for(int i=0;i<this.selectModesItem.length;i++){
			if(i==0){
				this.selectModesItem[i].setSelected(true);
			}
			this.selectBg.add(this.selectModesItem[i]);
			this.selectModeMenu.add(this.selectModesItem[i]);
			final int index = i;
			selectModesItem[i].addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(ActionEvent e) {
					//如果当前菜单项处于选中状态，表格使用对应的选择方式
					if(selectModesItem[index].isSelected()){
						table.getSelectionModel().setSelectionMode(selectModes[index]);
					}
				}
			});
		}
		this.menBar.add(this.selectUnitMenu);
		//为表格设置选择单元格的菜单
		this.rowsItem.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				//清除表格的所有选择模式
				table.clearSelection();
				//如果该菜单项处于选中状态，设置表格的选择单元是行
				table.setRowSelectionAllowed(rowsItem.isSelected());
			}
		});
		this.selectUnitMenu.add(this.rowsItem);
		columnsItem.addActionListener(new ActionListener() {
			
			public void actionPerformed(ActionEvent e) {
				table.clearSelection();
				//如果该菜单项处于选中状态，设置表格的选择单元是列
				table.setColumnSelectionAllowed(columnsItem.isSelected());
			}
		});
		selectUnitMenu.add(this.columnsItem);
		cellsItem.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				table.clearSelection();
				//如果选择行、选择列同时被选中，其实质是选择单元格
				table.setCellSelectionEnabled(cellsItem.isSelected());
				//同时将菜单项选择行与选择列更改为选中状态
				rowsItem.setSelected(table.getRowSelectionAllowed());
				columnsItem.setSelected(table.getColumnSelectionAllowed());
			}
		});
		selectUnitMenu.add(cellsItem);
		this.setJMenuBar(this.menBar);
		TableColumn nameColumn = table.getColumn(columnTitle[0]);
		nameColumn.setMinWidth(40);
		TableColumn ageColumn = table.getColumn(columnTitle[1]);
		ageColumn.setPreferredWidth(50);
		TableColumn genderColumn = table.getColumn(columnTitle[2]);
		genderColumn.setMaxWidth(50);
		this.add(new JScrollPane(table));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTableDemo1();
	}
}
13.6.10 TableColumnModel和监听器
	JTable采用TableColumnModel来保存该表格所有数据列的状态数据，如果程序需要访问JTable的所有状态信息，则可以通过获取该JTable的TableColumnModel来实现。TableColumnModel提供了如下方法来增加、删除和移动数据列。
1、	addColumn(TableColumn column)：该方法用于为TableModel添加一列。该方法主要用于将原来隐藏的数据列显示出来。
2、	moveColumn(int columnIndex,int newIndex)：该方法用于将指定列移动到其他位置。
3、	removeColumn(TableColumn column)：该方法用于从TableModel中删除制定列。实际上，该方法并为真正删除指定列，只是将该列在TableColumnModel中隐藏起来，使其不可见。
举例1：
package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;

public class JTableDemo2 extends JFrame {
	private final int COR_COUNT  = 5;
	//定义table数据模型
	private DefaultTableModel model = null;
	//定义JTable对象
	private JTable table = null;
	//定义List集合用于保存被隐藏的列
	private List<TableColumn> hiddenList = new ArrayList<TableColumn>();
	JTableDemo2(){
		super("管理数据行、数据列");
		model = new DefaultTableModel(COR_COUNT, COR_COUNT);
		//对数据模型model进行赋值，TableModel的存储数据方式类似于二维数组，包括行（row）列（column）
		for(int i=0;i<this.COR_COUNT;i++){
			for(int j=0;j<this.COR_COUNT;j++){
				this.model.setValueAt("数据"+i+"行"+j+"列", i, j);
			}
		}
		table = new JTable(model);
		this.add(new JScrollPane(table),BorderLayout.CENTER);
		//为窗口添加菜单
		JMenuBar menuBar = new JMenuBar();
		this.setJMenuBar(menuBar);
		JMenu menu = new JMenu("管理");
		menuBar.add(menu);
		//隐藏操作
		JMenuItem item = new JMenuItem("隐藏选中列");
		item.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				TableColumnModel columnModel = table.getColumnModel();
				TableColumn column = columnModel.getColumn(table.getSelectedColumn());
				columnModel.removeColumn(column);
				hiddenList.add(column);
			}
		});
		menu.add(item);
		//显示操作
		JMenuItem showItem = new JMenuItem("显示隐藏列");
		showItem.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				for(TableColumn column : hiddenList){
					table.addColumn(column);
				}
				hiddenList.clear();
			}
		});
		menu.add(showItem);
		//添加操作
		JMenuItem addItem = new JMenuItem("插入选中列");
		addItem.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				TableColumnModel columnModel = table.getColumnModel();
				TableColumn column = columnModel.getColumn(table.getSelectedColumn());
				table.addColumn(column);
			}
		});
		menu.add(addItem);
		//删除操作
		JMenuItem delItem = new JMenuItem("删除选中行");
		delItem.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				int[] indexs = table.getSelectedRows();
				for(int i=0;i<indexs.length;i++){
					model.removeRow(indexs[i]);
				}
			}
		});
		menu.add(delItem);
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setLocation(100, 100);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTableDemo2();
	}
}
13.6.11 绘制单元格内容
单元格的内容除了最简单的字符串表示形式外，还可以是更复杂的内容，比如可以显示图片，其他组件等信息。JTable使用TableCellRenderer绘制单元格，Swing为该接口提供一个实现类DefaultTableCellRenderer，该单元格绘制器可以绘制如下3种类型的单元格值：
1、	Icon：默认的单元格绘制器会把该类型的单元格绘制成Icon对象所代表的图标
2、	Boolean：默认的单元格绘制器会把该类型的单元格值绘制成复选按钮
3、	Object：默认的单元格绘制器在单元格内绘制出该对象的toString()方法返回的字符串。
在默认情况下，程序直接使用二维数组或者Vector来创建JTable，程序会使用匿名内部类或者DefaultTableModel充当该表格的model对象，无论是匿名内部类还是DefaultTableModel，这个两个model类的getColumnClass()方法的返回值都是Object。这就意味着即使二维数组里值的类型是Icon，但是由于两个默认的TableModel实现类的getColumnClass()方法总是返回Object，这将导致默认的单元格绘制器把Icon值当成Object值处理。
为了可以让默认的单元格绘制器可以将Icon类型的值绘制成图标，把Boolean类型的值绘制成复选框，创建JTable时使用的TableModel绝对不能采用默认的TableModel，必须采用扩展后的TableModel类：如下：
class ExtendsTableModel extends DefaultTableModel{
	//重写getColumnsClass方法，根据每列的第一个值来返回每列真实的数据类型。
	public Class getColumnClass(int c){
		return getValueAt(0,c).getClass();
}
}
这样就可以保证JTable根据model对象的getColumnClass()方法来获取到每列的真实数据类型，默认的单元格绘制器就会将Icon类型的单元格值绘制成图标，将Boolean类型的单元格值绘制成复选框。
	程序如果采用自己定制的单元格绘制器，则必须自己去实现单元格绘制器类，单元格绘制器必须实现TableCellRenderer接口，该接口只包含一个getTableCellReandererComponent()方法，返回Component作为指定单元格绘制的组件。
	为JTable对象安装绘制器有两种方式：
1、	列级：调用TableColumn的setCellRenderer()方法为指定的列安装单元格绘制器。
2、	表级：调用JTable的setDefaultRenderer()方法为指定的JTable对象安装单元格绘制器。
	
举例1：

package com.langsin.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

public class JTableDemo3 extends JFrame {
	//定义一个JTable变量
	private JTable table = null;
	//定义二维数组作为table的数据
	private Object[][] tableData = {
			{"李清照","29","女",new ImageIcon("./image/李清照.gif"),true},
			{"苏格拉底","56","男",new ImageIcon("./image/苏格拉底.gif"),false},
			{"李白","35","男",new ImageIcon("./image/李白.gif"),true},
			{"弄玉","18","女",new ImageIcon("./image/弄玉.gif"),true},
			{"虎头","2","男",new ImageIcon("./image/虎头.gif"),true}
	};
	//定义一维数组作为table的标题列
	private String[] titleColumn = {"姓名","年龄","性别","主头像","是否中国人"};
	
	JTableDemo3(){
		super("单元格绘制器实例");
		ExtendTableModel model = new ExtendTableModel(titleColumn,tableData);
		table = new JTable(model);
		//设置行是否可以被选中
		table.setRowSelectionAllowed(false);
		//设置行的高度
		table.setRowHeight(40);
		//将表格的第三列的信息使用我们自己的绘制器来进行绘画
		TableColumn column = table.getColumnModel().getColumn(2);
		column.setCellRenderer(new MyTableCellRanderer());
		this.add(new JScrollPane(table));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTableDemo3();
	}
}
class ExtendTableModel extends DefaultTableModel{
	ExtendTableModel(String[] titleColumn,Object[][] tableData){
		super(tableData,titleColumn);
	}
	//重写getColumnClass方法，根据每列的第一个值来返回其真实的数据类型
	public Class<?> getColumnClass(int columnIndex) {
		return this.getValueAt(columnIndex, columnIndex).getClass();
	}
}
/**
 * 实现自己的单元格绘制器
 * */
class MyTableCellRanderer extends JPanel implements TableCellRenderer{
	private String cellValue = null;
	private int iconWidth = 23;
	private int iconHeight = 21;
	
	public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column) {
		this.cellValue = (String)value;
		//设置选中状态下，即获取当前焦点的状态下绘制边框
		if(hasFocus){
			this.setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
		}else{
			this.setBorder(null);
		}
		return this;
	}
	
	private void drawImage(Graphics g,Image image){
		g.drawImage(image, (getWidth()-iconWidth)/2,(getHeight()-iconHeight)/2, null);
	}
	
	public void paint(Graphics g) {
		if("男".equals(cellValue) || "male".equalsIgnoreCase(cellValue)){
			this.drawImage(g, new ImageIcon("./image/male.gif").getImage());
		}else{
			this.drawImage(g, new ImageIcon("./image/female.gif").getImage());
		}
	}
}
13.6.12 编辑单元格内容	
当用户双击JTable表格的单元格时，或者JTree的节点时，默认采用文本框来编辑节点的内容，这种方式非常不直观，体验效果相当差，因此我们可以实现自己的单元格编辑器，为用户提供更好的操作界面。
实现JTable的单元格编辑器需要实现TableCellEditor接口，JTree的节点编辑器需要实现TreeCellEditor接口，两个接口有共同的父类接口CellEditor，有共同的实现类DefaultCellEditor。DefaultCellEditor类有3个构造器，分别使用文本框、复选框和JComboBox作为单元格编辑器，其中使用文本框编辑器是最常见的情况。
实现TableCellEditor接口可以开发自己的单元格编辑器，通常做法是扩展DefaultCellEditor类，这种方法比较简单，TableCellEditor接口里定义了一个getTableCellEditorComponent()方法，此方法会返回一个Component类型的对象，继承DefaultCellEditor类，需要重写getTableCellEditorComponent()方法。
	下面来实现一个ImageCellEditor编辑器，该编辑器由一个不可直接编辑的文本框和一个按钮组成，当用户单击该按钮时，该编辑器弹出一个文件选择器，方便用户选择图标文件。
举例1：
package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import javax.swing.DefaultCellEditor;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.filechooser.FileFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

public class JTableDemo4 extends JFrame {
	// 定义一个JTable变量
	private JTable table = null;
	// 定义二维数组作为table的数据
	private Object[][] tableData = {
			{ "李清照", "29", "女", new ImageIcon("./image/3.gif") ,new ImageIcon("./image/3.gif"), true },
			{ "苏格拉底", "56", "男", new ImageIcon("./image/1.gif") ,new ImageIcon("./image/1.gif"), false },
			{ "李白", "35", "男", new ImageIcon("./image/4.gif") ,new ImageIcon("./image/4.gif"), true },
			{ "弄玉", "18", "女", new ImageIcon("./image/2.gif") ,new ImageIcon("./image/2.gif"), true },
			{ "虎头", "2", "男", new ImageIcon("./image/5.gif"),new ImageIcon("./image/5.gif"), true } 
	};
	// 定义一维数组作为table的标题列
	private String[] titleColumn = { "姓名", "年龄", "性别", "主头像", "次头像", "是否中国人" };

	JTableDemo4() {
		super("table单元格编辑实例");
		//使用二维表格数据和一维标题列数据创建表格的数据model（模型）对象
		MyTableModel model = new MyTableModel(titleColumn, tableData);
		table = new JTable(model);
		//设置表格的行数据不被选中
		table.setRowSelectionAllowed(false);
		table.setRowHeight(40);
		table.setDefaultEditor(ImageIcon.class, new ImageCellEditor());
		TableColumn column = table.getColumnModel().getColumn(4);
		JComboBox box = new JComboBox();
		for(int i=0;i<10;i++){
			box.addItem(new ImageIcon("./image/"+i+".gif"));
		}
		column.setCellEditor(new DefaultCellEditor(box));
		this.add(new JScrollPane(table));
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}

	public static void main(String[] args) {
		new JTableDemo4();
	}
}
/**
 * 创建ImageCellEditor图标单元格编辑器来集成DefaultCellEditor
 * */
class ImageCellEditor extends DefaultCellEditor{
	//定义文件选择器
	private JFileChooser chooser = new JFileChooser();
	private JTextField field = new JTextField(15);
	private JButton button = new JButton("...");
	public ImageCellEditor() {
		super(new JTextField());
		this.initEditor();
	}
	private void initEditor(){
		this.field.setEditable(false);
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				browse();
			}
		});
		//为文件选择器添加文件过滤器，只显示我们需要的类型的文件
		chooser.addChoosableFileFilter(new FileFilter() {
			public String getDescription() {
				return "有效的图片文件格式";
			}
			public boolean accept(File f) {
				if(f.isDirectory()){
					return true;
				}
				String extension = this.getFileType(f.getName());
				if(extension!=null){
					if("jpeg".equals(extension) || "jpg".equals(extension) || "gif".equals(extension) || "png".equals(extension)){
						return true;
					}else{
						return false;
					}
				}else{
					return false;
				}
			}
			private String getFileType(String fileName){
				if(fileName.indexOf(".")!=-1){
					return fileName.substring(fileName.indexOf(".")+1).toLowerCase();
				}else{
					return null;
				}
			}
		});
		//设置文件选择框不允许接受多个文件，只能一次接受一个文件
		chooser.setAcceptAllFileFilterUsed(false);
	}
	//重写TableCellEditor接口的getTableCellEditorComponent方法
	public Component getTableCellEditorComponent(JTable table, Object value,
			boolean isSelected, int row, int column) {
		this.button.setPreferredSize(new Dimension(20,20));
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		this.field.setText(value.toString());
		panel.add(this.field,BorderLayout.CENTER);
		panel.add(this.button,BorderLayout.EAST);
		return panel;
	}
	private void browse(){
		//利用文件选择器进行处理，并设置打开的默认文件路径
		chooser.setCurrentDirectory(new File("./image/"));
		int result = chooser.showOpenDialog(null);
		//如果点击取消操作
		if(result==JFileChooser.CANCEL_OPTION){
			super.cancelCellEditing();
			return;
		}else{
			field.setText("./image/"+chooser.getSelectedFile().getName());
		}
	}
	//重写getCellEditorValue()方法，此方法返回编辑后的单元格数值
	public Object getCellEditorValue() {
		return new ImageIcon(this.field.getText());
	}
}

class MyTableModel extends DefaultTableModel{
	MyTableModel(String[] titleColumn,Object[][] tableData){
		super(tableData,titleColumn);
	}
	//重写getColumnClass方法，根据每列的第一个值来返回其真实的数据类型
	public Class<?> getColumnClass(int columnIndex) {
		return this.getValueAt(0, columnIndex).getClass();
	}
}
13.7 JTextPane和JFormattedTextField创建格式文本
	在Swing中JTextComponent是所有文本输入组件的父类，Swing为此类提供了3个子类：JTextField、JTextArea和JEditorPane。其中JEditorPane下有个子类为JTextPane，JEditorPane和JTextPane是典型的格式文本编辑器。
	JTextField下延伸出两个类：JPasswordField和JFormattedTextField，它代表密码输入框与格式文本输入框。
与其他的Swing组件一样，文本输入组件同样遵循MVC设计模式，即每个输入组件都有对应的model对象来保存其状态数据，有所区别的是文本输入组件的接口不在是xxxModel，而是Document接口，Document既包括有格式的文本，也包括无格式的文本。不同的文本输入组件对应的Document不同。
13.7.1 监听Document变化
1、	监听Document的变化
通过监听Document对象可以实现检测输入组件中文本值的变化，JTextComponent类提供了一个getDocument()的方法，用来获取文本组件对应的Document对象，Document对象提供了一个addDocumentListener方法为Document对象添加监听器，该监听器必须实现DocumentListener接口，此接口下需要实现3个方法：
?	changedUpdate(DocumentEvent e)：当Document对象里的属性或属性集发生变化时触发此方法。
?	insertUpdate(DocumentEvent e)：当向Document对象中插入文本时触发此方法。
?	removeUpdate(DocumentEvent e)：当从Document对象中删除文本时触发此方法。
2、	添加撤销监听器
为文本输入组件添加一个撤销监听器，这样就允许用户撤销以前的修改。添加撤销监听器的方法是：addUndoableEditListener()，该方法接受一个UndoableEditListener监听器，此监听器中包含undoableEditHappend方法，当文档中发生了可撤销的编辑操作时将会触发该方法。
举例1：此程序实现了为一个普通文本的document对象添加监听器，当用户在目标文本中输入、删除文本时，程序显示用户的操作。当用户按“Ctrl+Z”键时，程序会撤销用户刚刚的操作。
package com.langsin.swing;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.LinkedList;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.UndoableEditEvent;
import javax.swing.event.UndoableEditListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.undo.UndoableEdit;

public class DocumentDemo extends JFrame {
	private JTextArea target = new JTextArea(4,35);
	private JTextArea msg = new JTextArea(5,35);
	private JLabel label = new JLabel("文本域的修改信息");
	private Document document = target.getDocument();
	//保存撤销操作的List集合
	private LinkedList<UndoableEdit> list = new LinkedList<UndoableEdit>();
	//最多允许撤销多少次
	private final int UNDO_COUNT = 20;
	DocumentDemo(){
		super("监听document对象");
		//设置用于信息展示的msgTextArea不允许编辑
		msg.setEditable(false);
		//为document对象添加监听器
		document.addDocumentListener(new DocumentListener() {
			//当document对象的文本删除时触发此方法
			public void removeUpdate(DocumentEvent e) {
				int offset = e.getOffset();
				int length = e.getLength();
				msg.append("删除文本的起始位置为："+offset+"\n");
				msg.append("删除文本的长度为："+length+"\n");
			}
			//当项document文档中插入文本时触发此方法
			public void insertUpdate(DocumentEvent e) {
				//当插入文本时获取文本的起始位置
				int offset = e.getOffset();
				int length = e.getLength();
				msg.append("插入文本的起始位置为："+offset+"\n");
				msg.append("插入文本的长度为："+length+"\n");
				try {
					msg.append("插入文本的内容为："+document.getText(offset, length)+"\n");
				} catch (BadLocationException e1) {
					e1.printStackTrace();
				}
			}
			//当document中的属性或属性集发生变化时触发此方法，无甚作用
			public void changedUpdate(DocumentEvent e) {
				
			}
		});
		//添加可撤销操作的监听器
		document.addUndoableEditListener(new UndoableEditListener() {
			//每次发生可撤销操作时都会触发该方法
			public void undoableEditHappened(UndoableEditEvent e) {
				UndoableEdit edit = e.getEdit();
				if(edit.canUndo() && list.size()<UNDO_COUNT){
					//将撤销操作添加到集合中
					list.add(edit);
				}else if(edit.canUndo() && list.size()>=UNDO_COUNT){
					//弹出第一个撤销操作
					list.pop();
					//将撤销操作装入到list中
					list.add(edit);
				}
			}
		});
		target.addKeyListener(new KeyAdapter() {
			@Override
			public void keyTyped(KeyEvent e) {
				if(e.getKeyChar() == 26){
					if(list.size()>0){
						list.removeLast().undo();
					}
				}
			}
		});
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(new JScrollPane(target));
		JPanel panel = new JPanel();
		panel.add(label);
		box.add(panel);
		box.add(new JScrollPane(msg));
		this.add(box);
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new DocumentDemo();
	}
}
13.7.2 使用JFormattedTextField
在程序中如果不想用户进行随意的输入，解决的办法是对文本框添加焦点失去的监听器或者回车监听器，当触发此操作时，就检测用户输入的是否合法。此种做法是基本的解决思路，但是对程序员来说需要编写大量的代码，而且编程繁琐。Swing提供的JFormattedTextField可以很完美的解决此问题。
此输入框与普通的输入框的区别在于，它需要制定一个文本格式，只有当用户输入的格式满足该格式时，此文本框JFormattedTextField才会接收用户输入。
JFormattedTextField可以使用如下两种类型格式：
?	JFormattedTextField.AbstractFormatter：该内部类有一个子类DefaultFormatter，此类下有一个比较实用的MaskFormatter子类。
?	Format：主要由DateFormat和NumberFormat两个格式器组成，这两个格式器可以指定JFormattedTextField所能接收的格式字符串。
创建JFormattedTextField对象时可以传入任意一个格式器，创建对象后JFormattedTextField对象的用法与普通的TextField的用法基本相似，除此之外JFormattedTextField还包含3个特殊方法：
1、	Object getValue()：获取该格式化文本框里的值。
2、	void setValue(Object obj)：设置该格式化文本框的初始值。
3、	void setFocusLostBehavior(int behavior)：设置该格式化文本框失去焦点时的行为，该方法可以接收如下四个值：
a：JFormattedTextField.COMMIT，如果用户输入的内容满足格式的条件，通过getValue()方法则可以获取到文本框的值，如果不满足，文本框中显示的是用户输入的内容，但是通过getValue()方法则获取的是此文本框上一次符合条件的值；
b：JFormattedTextField.COMMIT_OR_REVERT：这是默认值，如果符合条件，则显示内容与获取内容都是用户输入的内容，不符合条件，则显示内容与获取内容都是上一次符合条件的内容。
c：JFormattedTextField.PERSIST，不管用户输入的内容是否符合格式器的要求，格式化文本框都显示用户输入的内容，但是通过getValue()方法返回的都是上一次满足值的要求。
d：JFormattedTextField.REVERT：不管用户输入的内容是否符合格式器的要求，格式化文本框显示的内容和getValue()返回的值都是上一次满足要求的值。

格式器：DefaultFormatter、MaskFormatter
DefaultFormatter格式器：功能强大、可以格式化任何类的实例，条件必须带有一个字符串参数的构造器，并包含一个对应的toString()方法。
MaskFormatter格式器：类似于正则表达式，要求用户输入的内容必须符合一定的掩码格式。此掩码格式与正则表达式有明显的区别，因此次掩码表达式只支持一下字符：
1、#：代表任何有效数字
2、’：转义字符
3、U：映射字符将所有的小写字符映射为大写字符。
4、L：映射字符将所有的大写字符映射为小写字符。
5、A：映射任何字符或数字
6、?：任何字符
7、*：匹配任何内容
8、H：匹配任何十六进制字符（0-9、a-f或者A-F）
注意：格式化文本框中的字符串内容必须与掩码完全相同，如果用户删除了文本框中的内容，则删除的部分使用占位符代替，默认使用空格字符作为占位符，也可以使用MaskFormatter类的setPlaceholderCharactor()方法进行设置。
举例1：
package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.DateFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Date;

import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JFormattedTextField;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import javax.swing.text.DefaultFormatter;
import javax.swing.text.MaskFormatter;

public class JFormatterTextFieldDemo extends JFrame {
	private JButton button = new JButton("确定");
	private JPanel panel = new JPanel();
	private JFormattedTextField[] fields = new JFormattedTextField[6];
	//定义单选按钮的文本值数组
	private String[] behaviorLabels = {
			"COMMIT",
			"COMMIT_OR_REVERT",
			"PERSIST",
			"PERVERT"
	};
	//定义文本框失去焦点后的行为值
	private int[] behaviors = {
			JFormattedTextField.COMMIT,
			JFormattedTextField.COMMIT_OR_REVERT,
			JFormattedTextField.PERSIST,
			JFormattedTextField.REVERT
	};
	private ButtonGroup bg = new ButtonGroup();
	
	JFormatterTextFieldDemo(){
		JPanel buttonPanel = new JPanel();
		buttonPanel.add(button);
		this.panel.setLayout(new GridLayout(0, 3));
		this.add(panel,BorderLayout.CENTER);
		this.fields[0] = new JFormattedTextField(NumberFormat.getIntegerInstance());
		fields[0].setValue(100);
		this.addRow("整数格式文本框：",fields[0]);
		fields[1] = new JFormattedTextField(NumberFormat.getCurrencyInstance());
		fields[1].setValue(100.0);
		this.addRow("货币格式文本框：",fields[1]);
		fields[2] = new JFormattedTextField(DateFormat.getDateInstance());
		fields[2].setValue(new Date());
		this.addRow("默认的日期格式文本框：",fields[2]);
		DateFormat format = DateFormat.getDateInstance(DateFormat.SHORT);
		format.setLenient(false);
		fields[3] = new JFormattedTextField(format);
		fields[3].setValue(new Date());
		this.addRow("short类型的语法格式器：", fields[3]);
		DefaultFormatter defaultMatter = new DefaultFormatter();
		defaultMatter.setOverwriteMode(false);
		fields[4] = new JFormattedTextField(defaultMatter);
		try {
			fields[4].setValue(new URL("http://www.baidu.com"));
		} catch (MalformedURLException e) {
			e.printStackTrace();
		}
		this.addRow("URL：", fields[4]);
		try {
			MaskFormatter maskMatter = new MaskFormatter("0531-########");
			maskMatter.setPlaceholderCharacter('#');
			fields[5] = new JFormattedTextField(maskMatter);
			fields[5].setValue("0531-85994971");
			this.addRow("电话号码：", fields[5]);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		JPanel lostPanel = new JPanel();
		for(int i=0;i<behaviorLabels.length;i++){
			final int index = i;
			final JRadioButton radio = new JRadioButton(behaviorLabels[i]);
			if(i==1){
				radio.setSelected(true);
			}
			lostPanel.add(radio);
			bg.add(radio);
			radio.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					//当某种类型被选中时，设置格式化文本框相应的失去焦点后的行为
					if(radio.isSelected()){
						for(int j=0;j<fields.length;j++){
							//设置文本框失去焦点后的行为
							fields[j].setFocusLostBehavior(behaviors[index]);
						}
					}
				}
			});
		}
		lostPanel.setBorder(new TitledBorder(new EtchedBorder(),"请选择焦点失去后的行为："));
		JPanel p = new JPanel();
		p.setLayout(new BorderLayout());
		p.add(lostPanel,BorderLayout.NORTH);
		p.add(buttonPanel,BorderLayout.SOUTH);
		this.add(p,BorderLayout.SOUTH);
		this.pack();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.setVisible(true);
	}
	private void addRow(String textLabel,final JFormattedTextField field){
		this.panel.add(new JLabel(textLabel));
		this.panel.add(field);
		final JLabel valueLabel = new JLabel();
		this.panel.add(valueLabel);
		this.button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Object value = field.getValue();
				valueLabel.setText(value.toString());
			}
		});
	}
	public static void main(String[] args) {
		new JFormatterTextFieldDemo();
	}
}
13.7.3 使用JTextPane
	在常用的编辑工具中，如：EditPuls、Eclipse，其中输入信息时，如果输入的信息是程序关键字、类名等，这些关键字将会自动变色。使用JTextPane组件，就可以进行开发出这种带有语法高亮显示的编辑器。
	JTextPane使用StyledDocument作为它的model对象，而StyledDocument允许对文档的不同段落分别设置不同的颜色、字体属性。Document使用Element来标识文档中的组成部分。Element可以表示章节、段落等，在普通的文档中Element还可以表示一行。为了设置StyledDocument中文字的字体、颜色，Swing提供了AttributeSet接口来表示文档文字、颜色等属性。
	Swing为StyledDocument提供了DefaultStyledDocument实现类，该实现类就是JTextPane的model实现类，为AttributeSet接口提供了MutableAttributeSet子接口，并为该接口提供了SimpleAttributeSet实现类，程序通过这些接口与实现类就可以来实现对JTextPane中文字的字体颜色的控制。
	StyledDocument提供了如下一个方法来设置文档中局部文字的字体、颜色。
?	setParagraphAttributes(int offset,int length,AttributeSet s,boolean replace)：设置文档中从offset开始，长度为length处的文字使用s属性（控制字体、颜色等），最后一个参数控制新属性是替换原有属性还是将新属性累加到原有属性上。
AttributeSet的常用实现类是MutableAttributeSet，为了给MutableAttributeSet对象设置字体、颜色等属性，Swing提供了StyleConstants工具类，该工具类大致包含了如下常用的静态方法来设置MutableAttributeSet里的字体、颜色等。
?	setAlignment(MutableAttributeSet a,int align)：设置文本对齐方式
?	setBackground(MutableAttributeSet a,Color fg)：设置背景色
?	setBold(MutableAttributeSet a,boolean b)：设置是否使用粗体字
?	setFirstLineIndent(MutableAttributeSet a,float i)：设置首行缩进的大小。
?	setFontFamily(MutableAttributeSet a,String fam)：设置字体
?	setFontSize(MutableAttributeSet a,int s)：设置字体大小
?	setForeground(MutableAttributeSet a,Color fg)：设置字体前景色
?	setItalic(MutableAttributeSet a,boolean b)：设置是否采用斜体字
?	setLeftIndent(MutableAttributeSet a,float i)：设置左边缩进大小
?	setRightIndent(MutableAttributeSet a,float i)：设置右边缩进大小
?	setLineSpacing(MutableAttributeSet a,float i)：设置行间距
?	setStrikeThrought(MutableAttributeSet a,boolean b)：设置是否为文字添加删除线
?	setSubscript(MutableAttributeSet a,boolean b)：设置将指定文字设置成下标
?	setSuperscript(MutableAttributeSet a,boolean b)：设置将指定文字设置成上标
?	setUnderline(MutableAttributeSet a,boolean b)：设置是否为文字添加下画线。
举例1
package com.langsin.swing;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

public class JTextPaneDemo extends JFrame {
	private JTextPane textPane = new JTextPane();
	private StyledDocument sdoc = textPane.getStyledDocument();
	private SimpleAttributeSet android = new SimpleAttributeSet();
	private SimpleAttributeSet java = new SimpleAttributeSet();
	private SimpleAttributeSet javaee = new SimpleAttributeSet();
	
	JTextPaneDemo(){
		super("JTextPane实例");
		StyleConstants.setForeground(android, Color.RED);
		StyleConstants.setFontSize(android, 24);
		StyleConstants.setFontFamily(android, "Dialog");
		
		StyleConstants.setForeground(java, Color.BLUE);
		StyleConstants.setFontSize(java, 28);
		StyleConstants.setFontFamily(java, "Arial Black");
		
		StyleConstants.setForeground(javaee, Color.GREEN);
		StyleConstants.setFontSize(javaee, 32);
		StyleConstants.setFontFamily(javaee, "微软雅黑");
		StyleConstants.setItalic(javaee, true);
		//设置不允许编辑
		this.textPane.setEditable(false);
		this.textPane.setText("浪曦android课程"+'\n'+"浪曦Java课程"+'\n'+"浪曦JavaEE企业级应用开发课程"+'\n');
		this.sdoc.setCharacterAttributes(0, 12, android, true);
		this.sdoc.setCharacterAttributes(12, 8, java, true);
		this.sdoc.setCharacterAttributes(20, 30, javaee, true);
		this.add(new JScrollPane(this.textPane),BorderLayout.CENTER);
		Dimension size = Toolkit.getDefaultToolkit().getScreenSize();
		this.setBounds(100, 100, size.width-100*2, size.height-100*2);
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.pack();
		this.setVisible(true);
	}
	public static void main(String[] args) {
		new JTextPaneDemo();
	}
}

举例2：Simple编辑器，利用自定义的SyntaxFormatter类根据语法文件来设置文档中的文字颜色

package com.langsin.swing;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;


public class JTextPaneSimpleDemo extends JTextPane {
	//定义一个样式文档对象
	private StyledDocument doc;
	//定义一个样式器对象
	private SyntaxFormatter formatter = new SyntaxFormatter("./my.stx");
	//根据样式器获取默认的样式集合对象
	private SimpleAttributeSet normalAttr = formatter.getNormalAttributeSet();
	//定义一个样式集合对象，如果文档中的字符串不在关键字列表中时，使用此样式
	private SimpleAttributeSet quoAttr = new SimpleAttributeSet();
	private int docChangeStart = 0;
	private int docChangeLength = 0;
	
	JTextPaneSimpleDemo(){
		StyleConstants.setForeground(quoAttr, new Color(255,0,255));
		//通过父类的方法，来获取样式文档对象并赋值给doc
		this.doc = super.getStyledDocument();
		//设置编辑器中输入字符串与边界的距离：上  左  下  右
		this.setMargin(new Insets(3, 40, 0, 0));
		//为此JTextPane添加监听器，当键盘松开时触发的事件
		this.addKeyListener(new KeyAdapter() {
			public void keyReleased(KeyEvent e) {
				//键盘松开时触发此方法，文档分析的方法
				syntaxParse();
			}
		});
	}
	private void syntaxParse(){
		try {
			Element root = doc.getDefaultRootElement();
			//获取文档中光标插入符的位置
			int cursorPos = this.getCaretPosition();
			//获取光标位置所在的行
			int line = root.getElementIndex(cursorPos);
			//获取光标所在的当前行对象
			Element para = root.getElement(line);
			//定义光标所在行的行头在文档中的位置
			int start = para.getStartOffset();
			//通过比较让start的值等于start与docChangeStart的较小的值
			start = start>docChangeStart ? docChangeStart : start;
			//定义被修改部分的长度
			int length = para.getEndOffset();
			length = length<docChangeLength ? docChangeLength+1 : length;
			//取出所有可能被修改的字符串
			String s = doc.getText(start, length);
			//以空格、点号等作为分隔符
			String[] tokens = s.split("\\s+|\\.|\\(|\\)|\\{|\\}|\\[|\\]");
			//定义当前分析单词在s字符串中的开始位置
			int curStart = 0;
			//定义单词是否处于引号内
			boolean isQuot = false;
			for(String token : tokens){
				//找出当前单词在S字符串中的位置
				int tokenPos = s.indexOf(token,curStart);
				if(isQuot && (token.endsWith("\"") || token.endsWith("\'"))){
					//字符串在引号内并且以单双引号结束，仍然使用此样式是为了以同样的颜色
					//显示最后的单双引号
					doc.setCharacterAttributes(start+tokenPos,token.length(),quoAttr, false);
					isQuot = false;
				}else if(isQuot && !(token.endsWith("\"") || token.endsWith("\'"))){
					//字符串在引号内没有以单双引号结束
					doc.setCharacterAttributes(start+tokenPos,token.length(),quoAttr, false);
				}else if((token.startsWith("\"") || token.startsWith("\'")) && (token.endsWith("\"") || token.endsWith("\'"))){
					//如果字符串以单引号开始、结束或者双引号开始、结束，表示文档中的字符串信息
					//让字符串显示为单独的颜色
					doc.setCharacterAttributes(start+tokenPos,token.length(),quoAttr, false);
				}else if((token.startsWith("\"") || token.startsWith("\'")) && !(token.endsWith("\"") || token.endsWith("\'"))){
					//表示以单引号或双引号开始，字符串还没有结束
					doc.setCharacterAttributes(start+tokenPos,token.length(),quoAttr, false);
					isQuot = true;
				}else{
					//使用格式器对当前单词设置颜色
					formatter.setHighLight(doc, token, start+tokenPos, token.length());
				}
				//开始分析下一个单词
				curStart = tokenPos + token.length();
			}
		} catch (BadLocationException e) {
			e.printStackTrace();
		}
	}
	//重写父类的paint方法，画行号
	public void paint(Graphics g){
		super.paint(g);
		//根据样式文档，来获取文档对象
		Element root = doc.getDefaultRootElement();
		//获得行号
		int line = root.getElementIndex(doc.getLength());
		//设置背景色
		g.setColor(new Color(230,230,230));
		//填充颜色
		g.fillRect(0, 0, this.getMargin().left-10, getSize().height);
		g.setColor(new Color(40,40,40));
		for(int count=0,j=1;count<=line;count++,j++){
			g.drawString(String.valueOf(j), 3, (int)((count+1)*1.435*StyleConstants.getFontSize(normalAttr)));
		}
	}
	public static void main(String[] args) {
		JFrame frame = new JFrame("文本编辑器");
		frame.getContentPane().add(new JScrollPane(new JTextPaneSimpleDemo()));
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Dimension size = Toolkit.getDefaultToolkit().getScreenSize();
		frame.setBounds(50, 50, size.width-50*2, size.height-50*2);
		frame.setVisible(true);
	}
}
//实现自己的样式器
class SyntaxFormatter{
	//定义一个属性集合，使用样式属性对象作为map的键值
	private Map<SimpleAttributeSet,List<String>> attMap = new HashMap<SimpleAttributeSet,List<String>>();
	//定义一个简单的样式对象
	private SimpleAttributeSet normalAttr = new SimpleAttributeSet();
	SyntaxFormatter(String syntaxFile){
		//对样式对象进行设置前景色字体大小
		StyleConstants.setForeground(normalAttr, Color.BLACK);
		StyleConstants.setFontSize(normalAttr, 16);
		//定义一个Scanner类用于读取模板文件中的已经定义好的关键字
		Scanner scanner = null;
		try {
			scanner = new Scanner(new File(syntaxFile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		int color = -1;
		List<String> keywords = new ArrayList<String>();
		while(scanner.hasNextLine()){
			String line = scanner.nextLine();
			//以#字符开始表示开启新的颜色设置，并对之前的关键字进行封装
			if(line.startsWith("#")){
				//如果关键字列表的长度大于0并且颜色值大于1，就将此列表集合封装起来
				//使用属性集合对象作为键值
				if(keywords.size()>0 && color>-1){
					SimpleAttributeSet att = new SimpleAttributeSet();
					StyleConstants.setForeground(att, new Color(color));
					StyleConstants.setFontSize(att, 16);
					attMap.put(att, keywords);
				}
				keywords = new ArrayList<String>();
				color = Integer.parseInt(line.substring(1),16);
			}else{
				//如果不是以#开始就将此关键字加入到关键字列表集合中去
				if(line.trim().length()>0){
					keywords.add(line.trim());
				}
			}
		}
		//将最后一个颜色所对应的关键字集合进行封装到map中
		if(keywords.size()>0 && color>-1){
			SimpleAttributeSet att = new SimpleAttributeSet();
			StyleConstants.setForeground(att, new Color(color));
			StyleConstants.setFontSize(att, 16);
			attMap.put(att, keywords);
		}
	}
	//获取普通的样式属性集合
	public SimpleAttributeSet getNormalAttributeSet(){
		return this.normalAttr;
	}
	//设置文档doc显示的样式
	public void setHighLight(StyledDocument doc,String token,int start,int length){
		SimpleAttributeSet currentAttributeSet = null;
		for(SimpleAttributeSet set : attMap.keySet()){
			List<String> keywords = attMap.get(set);
			for(String keyword : keywords){
				if(keyword.equals(token)){
					currentAttributeSet = set;
					break;
				}
			}
		}
		if(currentAttributeSet != null){
			doc.setCharacterAttributes(start, length, currentAttributeSet, false);
		}else{
			doc.setCharacterAttributes(start, length, normalAttr, false);
		}
	}
}
Swing项目总结






