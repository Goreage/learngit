2）类的声明
public class FirstJava{
…..
}
	在Java语言中所有的数据要先声明后使用，类也一样。
	public 和 class是Java语句中的关键字，Java语言的关键字都是小写。Java语言是大小写敏感的语言，关键字大小写不能混淆，如将public 写成Public或者PUBLIC,将产生语法错误，无法编译通过。public
用于声明公有属性，class用于声明类。
	标识符FirstJava指定所声明的类，即类名。Java语言规范约定，类名首字母都要大写，如FirstJava.
	一个Java程序中可以包含多个源文件，一个源文件可以包含多个类，但是每个文件最多只能包含一个公共类，而且这个公共类必须与其所在的文件同名，如果需要修改公共类的名称，则需要同时修改该公共类所在的文件名。除内部类外，一般不建议在一个源文件中包含多个类。
	此外，整个类体的声明有“{}”括起来。
3）main ()方法
	main()方法是所有Java应用程序执行的入口，但不是Java小应用程序的入口，因此可以独立运行的Java程序必须包含一个main()方法。
	main()方法是类FirstJava的一个组成部分，main()方法也成为main成员方法。
	public static void main(String args[]){
…….
}
main()方法前面有3个必不可少的关键字，这是Java语言规定的。
(1)	 public		public值成员方法main()具有公有属性，是一个公有的方法，能够被任何其他对象调用。能够被Java虚拟机调用，它的参数args可以接受操作系统的赋值。
(2)	static	static指明main()方法是一个静态的类方法。静态方法不用实例化对象就能直接调用。
(3)	void	void指明main()方法无返回值
main()方法的形参args是参数变量，参数类型是String[]。 参数类型不可修改，参数变量名可以改变，一般不修改main()方法的参数变量名称。参数变量可以接收来自操作系统传送参数的字符串类型的参数，这些参数之间需要用空格或者制表符分开。该数组长度可以随着操作系统传送参数的数目自动增加，以防止溢出。
Java语言使用国际字符格式标准(Unicode)和浮点数（IEEE 754）。
Unicode标准规定了世界字符和符号的一致编码规则。
标识符
	Java标识符(identifier)是以字母或下划线开头的字母数字序列。标识符是用户定义的单词，用于标准变量，常量，类，方法，对象，文件等，
	命名规则如下。
（1）“字母”，“数字”具有宽泛含义。字母通常指大小写英文字母。下划线（_），美元符（$），也可以是Unicode字符集中的其他语言字符，如汉字等。数字通常指0~9。
（2）标识符也可以是字母，数字等字符的任意组合，除此之外，不能包含其他字符（如+，-以及空格等）。
（3）标识符可以区分字母大小写，或者说大小写铭感。
（4）标识符不能使用Java中的关键字，
（5）标识符长度不受限制。
正确的标识符使用
String name;
String sex;
int age;
double salary;
public class Salary;
String 性别，籍贯，爱好;
错误的标识符使用
int 2x;					//标识符不能以数字开头
double my salary;	//标识符中间不能有空格
String x+y;			//”+”既不是Java的字母，也不是Java的数字，不能使用。
String test1-2-3;		//“-”既不是Java的字母，也不是Java的数字，不能使用。
String class;			//标识符不能用关键字
String Java&Jsp;		//&既不是Java的字母，也不是Java的数字，不能使用。
?
 
	

方法	说明
Length()	返回字符串的长度
Equals(Object Object)	将给定字符串与当前字符串进行比较，若相等返回true,否则返回false。
Substring(int beginIndex)	返回字符串从beginIndex开始的字串
Substring(int beginIndex ,int endIndex)	返回从beginIndex开始到endIndex的字串
charAt(int index)	返回index指定位置的字符
indexOf(String str)	返回str在字符串中第一次出现的位置
Replace(char oldChar,char newChar)	以newChar字符替换串中的所有oldChar字符串
Trim()	去掉字符串的首尾空格












类和对象
	在基于Java的程序开发中，首先把需要实现的功能封装到类中，然后通过对象调用类的数据和方法来实现Java应用程序的具体功能。在编写Java程序时，应以“一切皆为对象”的思维方式来思考问题，通过创建类和对象，调用类的方法来完成程序的功能，解决问题。定义类以及对类进行操作的对象是Java程序设计的主要任务。
	本章主要内容如下。
	（1）类和对象
	（2）类的封装性	
	（3）类的继承性
	（4）类的多态性
	（5）包
	（6）抽象类与接口
	（7）内部类与匿名类
类和对象
	现实世界中有各种实体，如手机，计算机，书，房子，汽车等。每种实体都有自己的属性和功能，并且每种实体都有很多的实例，实例之间有各种关系。在面向对象程序设计中，把具有属性和行为能力的实体成为对象。对象在软件运行时与其他对象合作完成程序预期的功能，类是一组对象的数据类型，是创建对象的模型。
	类
	类（class）是既包括数据又包括对数据的操作的封装体。类中的数据称为成员变量，类中对数据的操作称为成员方法。成员变量反映类的状态和特征，成员方法表示类的行为能力，不同的类具有不同的特征和功能。类实际上是对某种类型的对象定义变量和方法的原型。类表示对现实生活中一类具有公共特征的事物的抽象，是面向对象编程的基础。
1.	类的声明
类声明中包括关键词class，类中及类的属性。
类声明的格式如下：
 [修饰符]class类名<泛型>[extends 父类] [implements 接口列表]
{
		成员变量的声明；
		成员方法的声明；
}
其中：
(1)	修饰符是定义类属性的关键字，如public ,final, abstract等，用于定义类的访问权限，类是否为最终类或者抽象类等属性。方括号[]中的内容是可选项。
(2)	class是定义类的关键字，在类的声明中必须包括关键字class.类名，泛型， 父类， 接口应是合法的Java标识符，Java约定类名标识符通常首字母大写。在类的声明中必须有自定义的类名。
(3)	泛型是指将类型参数化以达到代码复用，提高软件开发工作效率的一种数据类型。也可以看做一种类型的占位符，或称为类型参数。我们知道，一个方法可以使用变量作为参数，但其实这个变量的类型本身也可以作为参数，泛型允许人们在方法调用时在指定这个类型参数是什么。通常一个方法的参数都有明确的数据类型。例如：
	public void data (int i){}
	public void data(string i){}
	public void data(double i){}
这些方法的参数类型分别是int ,string, double, 程序员调用这些方法的过程中需要提供指定类型的参数：
	data(123);
	data(“abc”);
	data(“12.12”);
如果将int, string, double 这些类型也当作一种参数传给方法，方法的定义便是这样的：
public void data<T> (T i) {} //T是int , string, double这些数据类型的指代
	用户在调用的时候便应该这样：
	data<string>(“abc”);
  data<int>(123);
	data<double>(12.23); 
	使用泛型定义方法与通常的方法的最大区别是，方法的定义实现过程只有一个，但是它具有处理不同数据类型数据的能力。
（4）extends 是关键字，用于继承类。
(5) implements 是关键字，用于实现某些接口。
例如：
public class Student
{
	…
}
	上述代码声明一个类Student。其中public 是指定类访问权限的修饰符，指定该类是公有类，可被所有类访问。
2.	类的成员变量和成员方法
1）	类成员变量
类成员变量声明的格式如下:
[修饰符] 数据类型 变量名 [=表达式] {,变量[=表达式]};
其中。
（1）	修饰符是定义成员变量属性的关键字，如public protected, private, static, final, transient（用于声明临时变量）等。
（2）	数据类型可以是基本数据类型，也可以是引用数据类型。
（3）	变量名是合法的Java标识符，表达式是合法的Java表达式。例如：
private String name;
private String sex;
private String age;
public static final MAX=1000000;
public String 籍贯 = “北京”;
2)类成员方法
类成员方法声明的格式如下：
[修饰符] 返回类型 方法名([参数列表]) [throws异常类]
{
		语句序列;		//局部变量声明及指令
		[return[返回值]];
}
其中：
		（1）修饰符是定义方法属性的关键字，如public ,
Protected, private, static, final, abstract, synchronized(实现多线程同步，具体请参考第12章)等。
（2）返回类型可以是基本数据类型或者引用数据类型，如果是void,则return语句可以省略。
（3）语句序列可包括局部变量声明和合法的Java指令。
例如：
public class Student{
	private int SID;				//学号
	private String name;			//姓名
	private String sex;				//性别
	private int age;				//年龄
public Student(int 学号,String 姓名,String 性别,int 年龄){
//定义构造方法
	SID=学号;
	name=姓名;
	sex=性别;
	age=年龄;
}
public int getSID() {
	return SID;
}
public void setSID(int SID){
	this.SID=SID;
}
public void getName(String name){
return name;
}
public void setName(String name){
			this.name=name;
}
public String getSex(){
		return sex;
}
public void setSex(String sex){
	this.sex=sex;
}
public int getAge(){
			return age;
} 
public void setAge(){
			this.age=age;
}
		该类封装的属性通过set***()和get***()方法设置和获取数据。Set***()和get***()是成员方法。
3.	变量的作用域
变量的作用域是指变量的有效范围。变量可以分为类成员，局部变量，方法参数量和异常处理参数变量。
（1）	类成员变量：值在类中方法体之外定义的变量。它的作用域是整个类，类中的所有方法均可以访问成员变量。
（2）	局部变量：值在方法体中声明的变量。它的作用域
是从定义位置开始到方法体语句块结束，当方法调用返回时，局部变量失效。
（3）	方法参数变量：值方法的参数列表。它的作用域是方法体的整个区域。
（4）	异常处理参数变量：异常对象，在异常处理内有效。具体第7章内容。
6.1.2对象
		类是用于封装数据以及对这些数据的操作的数据类型，类本身并不参与程序的执行，实际执行程序的是类的对象。
		对象是类的实例，任何一个对象都属于某个类。与变量相似，对象也需先声明后使用。
		对象是动态的，每个对象都有自己的生存周期，都经历一个从创建，运行到消亡的变化过程。在程序运行时，一个对象获得系统创建的指定类的一个实例，对象占用内存单元。程序可以获得对象的成员变量值，可以对对象的成员变量赋值，可以调用对象的成员方法。对象使用完将被销毁，释放所占的存储单元。
1.	对象的声明
对象声明的格式如下：
类		对象；
例如：
Student s;				//声明s是Student类的一个对象
对象声明后，只是代表对象属于某个类，需通过赋值才能使对象获得实例。
2.	创建实例
通过new调用类的构造方法，创建类的一个实例，为实例申请空间并初始化，再将该实例赋值给对象。
		创建实例的格式如下：
对象=new类的构造方法）（[参数列表]）;
例如：
		s=new Student(20140101001,”女”,”理想”,18);//创建类的一个实例，并赋值给s对象或者
		Student s=new Student(20140101001,”女”,”理想”,18);//声明对象，创建实例并赋值
3.	对象引用变量和调用方法
对象被实例化后，可以通过运算符”.”引用成员变量和调用成员方法。格式如下：
对象.成员变量;
对象.成员方法([参数列表]);
例如：
s.name=”张硕”;		//对象引用成员变量
s.setName(“张果”);		//对象调用成员方法
4.对象是引用类型
		Java中类和对象都是引用数据类型，对象之间的赋值是引用赋值，对象赋值时并没有创建新的实例，例如:
		Student s=new Student(20140101001,”女”,”理想”,18);
Student s1=s;		//两个对象引用同一个实例，同时指向同一个地址
4.	对象的运算
使用关系运算符==和!=可以比较两个对象是否引用同一实例。例如：
			s==s1;			//结果为true
不能使用<,<=,>=关系运算符比较对象。
6.2类的封装性
			封装是将数据以及对数据的操作组合起来构成类，类是一个不可分割的独立单位；类中提供与外部联系的方法，又尽可能隐藏类的实现细节。
			封装性提供一种软件模块化的设计思想，像组装硬件一样。类的设计者提供标准化的软件模块，使用者根据实际需求选择需要的类模块，集成为软件系统，各模块之间通过传递参数等方法进行工作，设计者需考虑类的定义，类中数据和方法的访问权限，方法如何实现等问题；使用者需知道有哪些类，每个类的特点，每个类提供哪些常量，成员变量和成员方法等，而不需要知道方法实现的细节。
6.2.1构造方法
	在类中有一种特殊的方法，该方法与类同名，没有返回值类型，是创建对象时需要调用的一个方法，在类实例化是被调用。可以根据需要定义类的构造方法，进行特定的初始化工作。
1.	构造方法的声明
构造方法的定义格式如下：
public class 类名
{
		public构造方法名([参数列表]) {	//构造方法定义语句
}
}
注意事项如下。
（1）	构造方法名必须与所在的类名相同。
（2）	构造方法没有任何返回值类型。
（3）	可以通过参数表和方法体为生成对象的成员变量赋初始值 。
如果一个类定义是没有声明构造方法，Java自动为该类生成一个默认的构造方法，该构造方法无参数。当一个类声明了有参数的构造方法时，Java不再自动为该类生成无参数的构造方法。如果需要多个不同参数表的构造方法，则需要将构造方法重载。
2.	构造方法重载
Java允许一个类中有同名的方法带有不同的参数列表，称为方法的重载。在方法调用时，可以根据参数列表的不同来辨别应该调用哪一个构造方法。
6.2.2成员方法
类的成员方法描述类或者对象具有的操作或者提供的功能，是提供某种相对独立功能的程序模块。一个类或者对象可以有多个成员方法，对象通过调用成员方法来完成某些功能。
1.成员方法的定义
类的成员方法的定义包括两个部分内容：方法声明和方法体。
类成员方法的定义格式如下：
[修饰符] 返回类型 方法 ([参数列表]) [throws异常类]
{
语句序列；
[return[返回值]];			//如果返回值类型是void, return可省略
}
2.成员方法的重载
	成员方法的重载是指一个类中可以有多个同名的成员方法，这些成员方法的参数必须不同，或者参数类型不同。
	重载的成员方法必须通过参数列表相区别，即满足以下两个条件。
（1）	参数列表必须不同，即以不同的参数个数或参数类型或参数的次序来区别重载方法。
（2）	返回值可以相同，也可以不同，即不能以不同的返回值来区别重载的方法。
例如，在Java类库的数学库Math中，abs()方法返回一个数的绝对值，参数类型不同，返回值类型也不同。其参数的数据类型共有4种：
（1）	int abs ( int  a );
（2）	long abs ( long a);
（3）	float abs ( double a);
在自定义的类中可以根据项目的需要自定义重载方法。
3构造方法与成员方法的区别
（1）作用不同：构造方法用于创建类的实例并对实例的成员变量进行初始化；成员方法实现对类中成员变量的操作，提供某些功能
(2)调用方式不同：构造方法通过new运算符调用；成员方法通过对象调用。
6.2.3 权限访问
	根据类的封装性，设计者既要为类提供与其他类或者对象联系的方法，又要尽可能地隐藏类中的实现细节。为了实现类的封装性，要为类及类中成员变量和成员方法分别设置必要的访问权限，使所有类，子类，同一包中的类，本类等不同关系之间具有不同的访问权限。
	Java语言中为类成员设置了4种访问权限，为类（内部类有3种访问权限）设置了两种访问权限。
1.	类成员的访问权限
Java语言中定义了4种权限修饰符:public (公有) ， protected(保护), 缺省和private(私有)。这4种权限修饰符均可用于声明类中成员的访问权限。
这4种权限修饰符说明如下。
（1）	public :说明该类成员变量可被所有类对象访问。public指定最大访问权限范围。
（2）	protected:说明该类成员能被同一类中的其它成员，该类子类成员或同一包中的其他类成员访问，不能被其他包的非子类成员访问。protected指定有限的访问权限范围，使被保护的成员在子类和非子类具有不同的访问权限，即保护成员变量可被子类访问，不能被非子类访问。
（3）	缺省：当没有访问权限修饰符声明成员时，说明该类成员能被同一类中的其他成员访问或被同一包中的其他类访问，不能被包之外的其他类访问。缺省权限以包为界划定访问权限范围，使同一包中的类具有访问权限，其他包中的类则没有访问权限。
（4）	private:说明该类成员只能被同一类的其它成员访问，不能被其他类的成员访问，也不能被子类成员访问。private指定最小访问权限范围，对其他类隐藏类的成员，防止其他类修改该类的私有成员。
权限修饰符	同一类	同一包	不同包的子类	所有类	
public	




protected	


	
缺省	

		
private	
			

2.类的访问权限
类的访问权限有两种：public和缺省，不能使用其他两种权限声明类。
在一个源程序文件中可以声明多个类（按照程序规范化的要求，一般不建议在一个源程序中声明多个类），但是public修饰的类只有一个，且该类名必须与所在源文件名同名。
6.2.4  this , static, final,  instanceof
1.this
	关键字this在Java类中表示对象自身的引用值。例如，当在类中使用变量x和方法f()时，本质上都是this.x或this.f().在不混淆的情况下，this.x可以简写成x,this.f()可以简写成f()。this可以有以下3种用法
1)	指代对象本身
this用于指代调用成员方法的当前对象本身。
语法格式如下：
this;
2)	访问本类的成员变量和成员方法
语法格式如下：
this.成员变量；
this.成员方法([参数列表]);
3)	调用本类重载的构造方法
语法格式如下:
this([参数列表]);
2.	static
关键字static在Java类中用于声明静态变量和静态方法。
1）	静态变量
在Java类中，静态变量在系统内存中仅有一个副本，运行时Java虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配，而不是在类的实例化阶段完成静态变量的内存分配。静态变量可以直接通过类名访问，又称为类变量。非static的变量是对象变量（又称实例变量）。一般在Java类中，静态变量都是常量，例如:
public static final double PI=Math.PI;
2)静态方法
	被static修饰的方法就是静态方法，又称为类方法。使用类方法时不用创建类的对象，调用静态方法时，应该使用类名做前缀，而不是某一个具体的对象名。非static的方法是对象方法（或称实例方法）。
3.	final
关键字final可用于声明变量，类和方法。
1）	声明变量
用fianl声明变量，表示变量在声明之后不能修改，并且在必须声明时初始化，这样的变量就是常量。例如：
public final static int TOW=2;
2)声明final类
声明为final的类不能是父类或超类。final类中所有方法都是隐式final方法，类String就是final类，它不能被扩展。声明final类还能防止程序员绕过安全限制的子类。例如：
public final class Math extends Object	//数学类，最终类
Java API中的大多数没有声明为final，这保证了继承和多态的实现，它们是面向对象编程的基本特征。然而，在某些情况下，例如，出于安全性的需要，声明final类也是很有必要的。
3）final方法
声明为final方法也称为最终方法。父类或者超类中的final方法不能在子类中被覆盖。声明为private方法也是隐含final方法，因为不能在子类中覆盖private方法（尽管子类可以声明一个新的同名的方法）。声明为static的方法也是隐含final方法，因为static也不能被覆盖。final方法的声明永远不能改变，因此所有子类使用同样的方法实现。对final方法的调用在编译时展开，这种方式称为静态绑定。由于编译器知道final方法不能被覆盖，所以它可在每个方法调用处用声明的扩展代码替换final方法的调用，从而实现优化。
public class Circle extends Graphics
{
public final double area()	//最终方法，不能被子类覆盖
			{
				return Math.PI*this.radius*this.radius;
			}
}
4.instanceof
	instanceof关键字是对象运算符，用于判断一个对象是否属于指定类或其子类，返回boolean类型。例如：
		Date oday2=new Date(2014,1,2);
		oday instanceof Date;		//结果为true，说明oday2是Date类的对象

6.3类的继承性
	继承是软件重用的一种形式，在声明新类时复用现有类的成员，也可赋予其新的功能，或修改原有的功能。通过继承，程序员在程序开发中可以利用已验证和调试过的高质量软件，以节省开发时间，也使系统更有可能得到有效的实现。
6.3.1父类和子类
1.继承的概念
	当程序员创建类时，可以指定新类从现有的类中继承某些成员，而不需要完全从头开始声明新的成员。这个现有的类叫做超类，基类或者父类，新创建的类称为子类。子类也可以成为其他类的父类。
	通常子类会添加自己的变量和方法，因此子类比其父类更详细，可以表示更为特定的对象。典型的情况是，子类既有父类的功能，又有其专门的性能。
	新类可以由类库中的类继承。许多开发组织都开发了自己的类库，也可以利用其他可用的类库。也许有那么一天，最终的软件将有标准的可重用组件构造，就像今天的汽车和许多的计算机硬件一样。这样利于开发出更强大，丰富并且更经济的软件。
	继承性在父类和子类之间建立起联系。子类自动拥有父类的全部成员，包括成员变量和成员方法，使父类成员得以传承和延续；子类可以更改父类的成员，使父类成员适应新的需求；子类也可以增加自己的成员，使类的功能得以扩充。但是，子类不能删除父类的成员。
	Java中的类都是Object类的子类，即使在定义类时没有声明父类，Java也会自动将类定义为Object类子类，Object类是Java类库提供的类。
	Java语言只支持单重继承，但可以通过接口实现多重继承。在单重继承中父类与子类是一对多的关系。一个子类只有一个父类；一个父类可以有多个子类，每个子类又可以作为父类在定义自己的子类。
	继承是实现软件可重用性的一种重要的方式，继承增强了软件的可扩充能力，提高了软件的可维护性。后代类继承祖先类的成员，使祖先类的优良特性得以代代相传。如果更改祖先类的内容，这些修改过的内容将直接作用于后代类，后代类本身无须进行维护工作。同时，后代类还可以增加自己的成员，从而不断地扩充功能，或者重写祖先类的方法，让祖先类的方法适应新的需求。因此，通常将通用性的功能设计在祖先类中，而将特殊性的功能设计在后代中。
2.继承原则
	类的继承需要以下基本原则。
（1）子类继承父类的所有成员变量，包括实例成员变量和类成员变量。
（2）子类继承父类除构造方法外的所有成员方法，包括实例成员方法，和类成员方法。因为父类构造方法创建的是父类对象，子类必须声明自己的构造方法，用于创建子类自己的对象。
（3）子类不能删除从父类继承的成员。
（4）子类虽然继承了父类的私有成员，但子类不能使用父类的私有成员（私有变量，私有方法）。
（5）子类可以增加自己的成员变量和成员方法。
（6）子类可以重定义父类成员。
6.3.2 子类的声明与方法覆盖
1.子类的声明
	在Java语言中，子类对父类的继承是通过类的声明，即用关键字extends来实现。
子类声明的语法格式如下：
[修饰符] class类名 [extends 父类] [implements 接口列表]
其中：
	extends说明当前声明的类将要继承父类的属性和方法。父类中哪些属性和方法将被继承取决于父类对成员的访问控制。
	子类对父类的私有成员没有访问权限。子类对父类的公有成员和保护成员具有访问权限。子类对父类中缺省权限成员的访问分两种情况，对同一包中父类的缺省权限成员具有访问权限，而对不同包中的父类的缺省权限成员则没有访问权限。
	类中成员的访问权限体现了类封装的信息隐藏原则：如果类中成员仅限于该类自己使用，则声明为private；如果类中成员允许子类使用，则声明为protected;如果类中成员没有权限限制，所有类均可使用，则声明为public.例如:
public class Student extends Person{	//该类继承已有的类Person
		String 专业;
}
2.子类方法的覆盖
	如果父类成员适用于子类，则子类不需要定义父类成员，此时子类继承了父类的成员变量和成员方法，子类对象引用的是父类定义的成员变量，调用的是父类定义的成员方法。
	如果从父类继承来的成员不适合于子类，子类不能删除它们，但可以重定义它们，扩充父类成员方法的功能，使父类成员能够适应子类新的需求。
	在面向对象的程序设计中，子类可以把从父类那里继承来的某个方法改写，形成同父类方法同名，解决问题也相似，但具体实现和功能却不尽一致的新方法，这就是方法的覆盖。
	定义与父类完全相同的方法，实现对父类方法的覆盖，必须注意以下几点。
（1）完全相同的方法名
（2）完全相同的参数列表。
（3）完全相同类型的返回值。
注意：在满足上述3个条件的同时，还必须保证，访问权限不能缩小。
	3个条件中有一个不满足，就不是方法的覆盖，因而仍然存在。
	调用被覆盖的父类方法的格式如下：
		super.方法名;
6.3.3 super
	在子类的方法中，可以使用关键字super调用父类成员。super的使用有两种方法。
1.调用父类的构造方法
	父类的构造方法不能被继承，但在子类的构造方法体中，可以使用super调用父类的构造方法。语法格式如下：
	super([参数列表]);
其中，参数列表是父类构造方法的参数列表。
2.调用父类的同名成员
	子类继承父类的成员，当子类没有重定义父类成员时，不存在同名成员问题。子类对象使用父类成员名访问的都是父类声明的成员变量，调用的也都是父类定义的成员方法，所以不需要使用super。
	当子类重定义了父类成员时，则存在同名成员问题。此时，在子类方法体中，使用的成员变量和方法均默认为子类的成员变量和成员方法。如果需要引用父类的同名成员，则需要使用super。在以下两种存在同名成员的情况下，需要使用super。
1）子类隐藏父类成员变量
	当子类成员隐藏了父类同名成员变量时，如果需要访问被子类隐藏的父类同名成员变量，需要使用super指代父类对象来引用父类的同名成员变量。语法格式如下：
	super.成员变量;
2)子类覆盖父类的成员方法	
	当子类成员方法覆盖了父类同名成员方法时，如果需要调用被子类覆盖的父类同名成员方法，可以使用super指代父类对象来调用父类的同名成员方法。语法格式如下：
	super.成员方法([参数列表])
	使用protected变量会带来一些潜在的问题。第一个问题是子类可以不用set方法就能为继承的父类变量直接赋值，从而使子类对象可能将无效值赋给继承变量，使对象处于矛盾状态中，例如，假设将CommissionEmployee2的变量grossSales 声明为protected，子类对象（如BasePlusCommissionEmployee2）就可以讲一个负值赋给grossSales。使用protected变量带来的第二个问题是，子类的代码编写很可能依赖于父类的数据操作。实际上，子类应该只依赖父类的服务（即非private方法），而不依赖父类的数据。如果父类中有protected变量，那么当改变父类的实现时，就可能必须修改所有子类。
	第三个问题是，类的protected成员对同一程序包中的所有类都是可见的，通常人们并不希望这样。
	使用protected时应注意以下问题。
（1）当父类的方法应当只由其子类和同一包中的其他类使用时，可使用protected修饰符。
（2）将父类的变量声明为private(而不是protected)，可以使父类改变对它的操作时不会影响子类的实现。
6.4类的多态性
	类的多态性表现为方法的多态性，方法的多态性主要表现在方法的重载和方法的覆盖。
方法的重载和覆盖
1.方法的重载
	重载(overload)是指同一个类的多个方法可以同名但参数列表必须不同。
	重载表现为同一类中方法的多态性。一个类中可以定义多个参数不同的同名方法，程序运行时，究竟执行重载同名方法中的哪一个方法，取决于调用该方法时实际参数的个数，参数的数据类型和参数的次序。
2.方法的覆盖
	覆盖(override)是指子类重新定义了超类（即父类）中的同名方法。
	覆盖表现为父类与子类之间方法的多态性。如果一个父类方法不适用于子类，子类可以重新定义它，即声明并实现父类中的同名方法并且参数列表也完全相同，则父类和子类具有两个同名方法，此时称子类方法覆盖了父类方法。子类方法覆盖父类方法时，既可以完全重新定义，也可以在父类方法的基础上进一步增加功能，
	程序运行时，究竟执行同名覆盖方法中的哪一个方法。取决于调用方法对象所属是父类还是子类。Java寻找执行方法的原则是：从对象所属的类开始，寻找匹配的方法执行；如果当前类中没有匹配方法，则逐层向上依次在父类或祖先类中寻找匹配方法，直到Object类。
	从类的使用者角度看，方法的多态性使类及其子类具有统一的风格，不但同一个类中具有相同含义的多个方法可以共用同一个方法名，而且父类与子类之间具有相同含义的多个方法也可以共用同一个方法名。
	从类的设计者角度看，类的继承性和方法的多态性使类更易于扩充功能，同时增强了软件的可维护性。

包名	功能
java.lang	存放Java语言的核心类库，包含Java语言必需的系统类，如Object类，基本数据类型封装类，
字符串类，数学运算类，异常处理类，线程类
java.util	工具类库，包含日期类，集合类等
java.awt	图形用户界面的类库，包括组件，时间，绘图功能等类。
java.applet	编写Applet应用程序的类
java.text	各种文本，日期格式等类
java.io	标准输入，输出流，文件操作系统
java.net	高级功能的网络编程等有关的类库，如Socket通信等
java.sql	高级功能的数据库编程的类库
 java.swing	高级功能的图形用户界面的类库
	


3.抽象类与抽象方法的作用
	抽象类不能创建实例，而且抽象方法没有具体实现，其作用如下。
（1）抽象类的作用是让其子类来继承它所定义的属性及方法，以避免各子类重复定义这些相同的内容。程序员可以先建立抽象类（定义子类公有的属性及方法），在从抽象类派生出不同具体特性的子类。
（2）抽象类用于描述抽象的概念，抽象方法仅声明方法的参数和返回的类型。抽象方法的具体实现有抽象类的子类完成，子类必须覆盖父类的抽象方法。
（3）抽象类声明抽象方法约定了多个子类公用的方法声明，每个子类可以根据自身的实际情况，给出抽象方法的具体实现，显然不同的子类可以有不同的方法实现。因此一个抽象方法在多个子类中表现出多态性。抽象类提供方发声明与方法实现相分离的机制，使得多个不同的子类能够表现出共同的行为能力。
6.2.2接口
接口（interface）被定义为由常量和抽象方法组成的特殊类，但在JDK8中，接口中也可以定义非抽象方法了
1.接口的概念
在Java中，接口是一种引用数据类型。接口是一组常量和抽象方法，默认方法，静态方法的集合。其中，只有默认方法和静态方法有方法体。接口中的默认方法又称为虚拟扩展方法(virtual extension methods)或defender方法。抽象方法的具体实现由实现接口的类完成，完成接口的类必须覆盖接口中所有抽象方法。
2.声明接口
接口也必须先声明后使用。接口的定义类似于类的创建。接口的声明语法格式如下：
[public] interface 接口名 [extends 父接口]{
	[public] [static] [final] 数据类型 成员变量=常量值；
	[default] [public] [static] [abstract] 返回值类型 成员方法 ]]
	`[;]
..
	[[
}
声明接口时应注意的事项如下。
（1）interface关键字是用来声明接口的。
（2）接口中的属性（即成员变量）只能是常量。
（3）方法的修饰符default, static, abstract 在同一个方法声明中不能同时出现。
（4）default方法，static方法必须有方法体。
	接口声明以关键字interface开始，它可以包含常量和抽象方法，默认方法，静态方法。与类不同的是，所有接口成员成员都必须为public.接口中声明的所有抽象方法都隐含为public abstract 方法，而所有的常量都隐含为public static final.根据Java语言规范，声明接口抽象方法时不带关键字public 和abstract 是正确的风格，因为它们是多余的。类似地，声明常量是也不需带关键字public, static 以及 final, 它们也是多余的。
	接口是public 类型的，因此与public 类一样，它们通常与接口同名的文件中声明，文件扩展名为java。例如：
public interface Plane		//平面图形接口
{
			double PI = 3.14;		//常量
			public abstract double area();	//计算面积的抽象方法
			default void printtMessage(){	//默认方法，抽出提示信息
			System.out.println(“平面图形接口!”);
} 
static void printArea(){				//静态方法，输出输出默认的面积值 
			System.out.println(0);
}
}
3.声明实现接口的类
	在类定义中可以使用implements关键字指定实现哪些接口。类中必须具体实现这些接口中定义的抽象方法。
	实现接口的类声明语法格式如下。
[修饰符] class类<泛型> [extends 父类]  [implenments 接口列表]
例如：
public class Rectangle implements 	Plane{
….
}
为了使用接口，具体类必须实现接口，并且必须实现接口中定义的所有抽象方法。如果一个类没有没有实现接口的所有抽象方法，那么它必须被定义成抽象类，必须被声明为abstract类型。实现接口就好像与编译器签订协议”我将实现接口指定的所有方法，或者我将类声明为抽象类”。
	如果一个具体类实现某个接口，却没有实现该接口的所有方法，也没有声明为抽象类，在编译时将会产生语法错误，提示该类必须声明为抽象类。
	实现接口的类要实现接口中的抽象方法。即使不需要使用某个方法，也要为其定义一个空方法体。每个实现接口的类可以根据自身的实际情况，给出抽象方法的具体实现，不同的类可以用不同的方法实现。
	对于接口中的默认方法，实现类可以直接使用，因为接口已经给出默认实现，也可以根据需要重新定义即覆盖默认方法。如果一个类实现两个接口，而这两个接口中各自定义了一个同名的default方法，就必须在实现类中覆盖冲突的方法，否则会导致编译失败。通过使用默认方法，程序员可以方便地修改已经存在的接口而不会影响现有的实现架构，即可以在现有接口中加入新方法，又能保持向后的兼容性。但是建议谨慎使用默认方法，因为在类层次结构较复杂的情况下，过多使用默认方法容易引起混淆，甚至导致错误。
	接口中的静态方法类似于类中的静态方法，实现类必须使用接口名才能调用。
4.接口的作用
	接口通常用于需要在异质（即不相关）的类之间公用方法或常量的情况下，这使得能够对不相关的类对象进行多态处理，即实现相同接口的不同类对象可以相应同样的方法调用。程序员可以创建接口来描述所需的功能，然后在需要该功能的类中实现这一接口。
	接口提供了方法声明与方法实现相分离的机制，使多个类之间出共同的行为能力。接口中声明的方法约定了多个类共用的方发声明。接口中的一个抽象方法或默认方法在实现接口的多个类中表现多态性。与抽象类相似，接口也用于描述抽象的概念，只能约定多个共同使用的常量，成员方法，抽象方法，默认方法。因此，接口也不能被实例化，只能被类实现或者被其他接口扩展。
	接口机制使java具有了实现多重继承的能力。
5.用接口实现多重继承
	Java只支持单重继承机制，即一个类只能有一个父类，不支持 c++ 语言中的多重继承。
	单继承性使得Java结构简单，层次清晰，易于管理，更安全可靠，从而避免了 c++ 语言中因多重继承而引起的难于预测的冲突。但在实际应用中有时也需要使用多重继承功能，Java提供了接口用于实现多继承，一个类可以实现多个接口。
这样，既实现了多重继承的功能，同时又避免了c++语言中应多重继承而存在的隐患。
	在开发Java应用程序时，经常需要使用Java提供的接口，接口的典型应用有事件处理和线程等。
	接口可以继承别的接口。
	一个类可以继承一个父类并实现多个接口。例如：
public class A extends B implements C, D{
}
	在声明一个类时，可以在继承一个直接父类的同时声明实现多个接口，从而实现多重继承，
		父类
继承			继承
子类1			子类2			――――――――单重继承

			父类		接口1		接口2
	继承				实现					实现
				子类						+++++++继承并实现接口
		接口1			接口2
	实现							实现
				类			￥￥￥￥￥实现多个接口
类的继承机制

6.声明和实现接口程序
	利用多态性开发一个计算员工工资和通过发票报销的应用程序。

异常

?
 
异常处理
Java语言处理异常的方式有两种：捕获异常并处理和抛出异常
	捕获异常并处理：
捕获异常并处理的方式是通过try-catch-finally来实现，语法格式如下：
try
{
		…//可能会产生异常的语句序列
}
catch (ExceptionTypel el)
{
		…//异常处理代码，捕获到ExceptionTypel类型异常后在此进行处理
}
		….
catch (ExceptionTypeN eN)
{
		….//异常处理代码，捕捉到ExceptionTypeN类型异常后在此进行处理
}
finally
{
		….//语句序列，无论是否捕捉到异常都必须执行
}
其中：
（1）Try引导的语句是应用程序中有可能出现异常代码段，一旦try捕捉到异常就交给对应的catch子句处理。
（2）el,…,eN表示不同异常类型的对象
（3）ExceptionType是异常类名
（4）catch语句块用于处理try捕捉到的异常，可以有多个catch子句，每个子句处理的异常类型不同。一旦捕获到异常将自动匹配各catch子句中的异常类型，找到相应的异常类型就执行catch语句。如果没有捕捉到异常则所有catch语句将不执行。
（5）在异常处理过程中，finally语句块总是会被执行到，无论有没有异常产生，也无论有没有异常被捕捉到。finally语句块是可选项，通常位于所有catch语句块的后面。一般用于释放try语句块中获得的资源，如关闭在try语句块中打开的文件等。
（6）catch和finally二者可以有一项或者两项都有，但必须至少有一项。
